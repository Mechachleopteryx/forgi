

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>forgi.graph.bulge_graph &#8212; forgi 2.0.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '2.0.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../../index.html">
          <span>forgi 2.0.0 documentation</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for forgi.graph.bulge_graph</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>

<span class="sd">&quot;&quot;&quot;bulge_graph.py: A graph representation of RNA secondary structure based</span>
<span class="sd">   on its decomposition into primitive structure types: stems, hairpins,</span>
<span class="sd">   interior loops, multiloops, etc...&quot;&quot;&quot;</span>

<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">chr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">hex</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span>   <span class="c1"># pylint: disable=W0611</span>
                      <span class="nb">map</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span> <span class="nb">oct</span><span class="p">,</span> <span class="nb">pow</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">round</span><span class="p">,</span>   <span class="c1"># pylint: disable=W0611</span>
                      <span class="nb">str</span><span class="p">,</span> <span class="nb">super</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>   <span class="c1"># pylint: disable=W0611</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">collections</span> <span class="k">as</span> <span class="nn">col</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pformat</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">from</span> <span class="nn">logging_exceptions</span> <span class="k">import</span> <span class="n">log_to_exception</span><span class="p">,</span> <span class="n">log_at_caller</span>

<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">stuff</span> <span class="k">as</span> <span class="n">fus</span>
<span class="kn">from</span> <span class="nn">..utilities.exceptions</span> <span class="k">import</span> <span class="n">GraphConstructionError</span><span class="p">,</span> <span class="n">GraphIntegrityError</span>
<span class="kn">from</span> <span class="nn">.sequence</span> <span class="k">import</span> <span class="n">Sequence</span><span class="p">,</span> <span class="n">_insert_breakpoints_simple</span><span class="p">,</span> <span class="n">SequenceLoader</span><span class="p">,</span> <span class="n">_seq_ids_from_seq_str</span><span class="p">,</span> <span class="n">VALID_CHAINIDS</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">transform_graphs</span> <span class="k">as</span> <span class="n">fgt</span>
<span class="kn">from</span> <span class="nn">.residue</span> <span class="k">import</span> <span class="n">RESID</span>
<span class="kn">from</span> <span class="nn">._basegraph</span> <span class="k">import</span> <span class="n">BaseGraph</span>
<span class="kn">from</span> <span class="nn">._graph_construction</span> <span class="k">import</span> <span class="n">_BulgeGraphConstruction</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">_cofold</span> <span class="k">as</span> <span class="n">fgc</span>

<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="n">profile</span>  <span class="c1"># The @profile decorator from line_profiler (kernprof)</span>
<span class="k">except</span><span class="p">:</span> <span class="c1"># pylint: disable=W0702</span>
<div class="viewcode-block" id="profile"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.profile">[docs]</a>    <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="BulgeGraph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph">[docs]</a><span class="k">class</span> <span class="nc">BulgeGraph</span><span class="p">(</span><span class="n">BaseGraph</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">graph_construction</span><span class="p">,</span> <span class="n">seq_obj</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">infos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">_dont_split</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>   <span class="c1"># pylint: disable=W0231</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A bulge graph object.</span>

<span class="sd">        Users of the forgi library should use the provided factory functions</span>
<span class="sd">        instead of invoking BulgeGraph() directly!</span>

<span class="sd">        :param graph_construction: A forgi.graph._graph_construction.Graph-construction</span>
<span class="sd">                                   instance that contains defines and edges.</span>
<span class="sd">        :param seq_obj: A forgi.graph.sequence.Sequence instance</span>
<span class="sd">        :param name: A string</span>
<span class="sd">        :param infos: A dict of lists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># :param _dont_split: Internal, used if the graph-construction is already splitted</span>
        <span class="c1">#                     e.g. for graph transformations.</span>
        <span class="c1">#                     TODO: It would be better to move split_at_cofold_cutpoints</span>
        <span class="c1">#                     Somewhere out of BulgeGraph.</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mst</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;untitled&quot;</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;No name given. name was set to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Setting name to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="c1">#: The coarse grain element definitions: Keys are for example &#39;s1&#39;/ &#39;m2&#39;/ &#39;h3&#39;/ &#39;f1&#39;/ &#39;t1&#39;</span>
        <span class="c1">#: Values are the positions in the sequence (1D-coordinate) of start , end, ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">graph_construction</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">graph_construction</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>

        <span class="c1"># Some cached values:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_node_to_resnum</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># Additional infos as key-value pairs are stored here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infos</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">infos</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">infos</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_seq</span> <span class="o">=</span> <span class="n">seq_obj</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">_dont_split</span><span class="p">:</span>
            <span class="n">fgc</span><span class="o">.</span><span class="n">split_at_cofold_cutpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="c1"># Factory functions.</span>
    <span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<div class="viewcode-block" id="BulgeGraph.from_dotbracket"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_dotbracket">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_dotbracket</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dotbracket_str</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a BulgeGraph object from a dotbracket string.</span>

<span class="sd">        :param dotbracket_str: A string</span>
<span class="sd">        :param seq: A string, with the same length as the dotbracket string,</span>
<span class="sd">                    a forgi.graph.sequence.Sequence instance or None.</span>
<span class="sd">                    If it is None, the sequence will be all &#39;N&#39;s</span>
<span class="sd">        :param name: Optional string to use as molecule name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;From dotbracket </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dotbracket_str</span><span class="p">)</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="n">fus</span><span class="o">.</span><span class="n">dotbracket_to_pairtable</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="n">fus</span><span class="o">.</span><span class="n">pairtable_to_tuples</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">seq</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">seq</span> <span class="o">=</span> <span class="n">_seq_of_Ns_from_db</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span>
            <span class="n">seq_ids</span> <span class="o">=</span> <span class="n">_seq_ids_from_seq_str</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">seq_ids</span><span class="p">)</span>
        <span class="n">graph_constr</span> <span class="o">=</span> <span class="n">_BulgeGraphConstruction</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Defines are </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">graph_constr</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">graph_constr</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_cleaned_bg</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="p">,</span> <span class="n">remove_pseudoknots</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.from_ct_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_ct_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_ct_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">ct_string</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the graph from a string holding a connectivity table.</span>
<span class="sd">        See http://x3dna.org/highlights/dssr-derived-secondary-structure-in-ct-format</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">ct_string</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[</span><span class="n">line</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span> <span class="k">if</span> <span class="n">line</span><span class="p">]</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">num_nts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">header</span><span class="p">[</span><span class="n">num_nts</span><span class="p">:]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="n">haswarned_circ</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">breakpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">seq_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">seq</span> <span class="o">+=</span> <span class="n">fields</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">!=</span> <span class="n">i</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">&gt;</span> <span class="n">i</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="n">num_nts</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                        <span class="s2">&quot;Ignoring alternative structure in ct-file. Using only the first structure&quot;</span><span class="p">)</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Missing residue number </span><span class="si">{}</span><span class="s2">, foun </span><span class="si">{}</span><span class="s2"> instead&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">))</span>
            <span class="n">seqid</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">seq_ids</span> <span class="ow">and</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">breakpoints</span> <span class="ow">and</span> <span class="n">seq_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">seqid</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">seq_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot; &quot;</span><span class="p">:</span>
                    <span class="n">insertion</span> <span class="o">=</span> <span class="s2">&quot;A&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">insertion</span> <span class="o">=</span> <span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="n">seq_ids</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">insertion</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span>
            <span class="n">seq_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">RESID</span><span class="p">(</span><span class="n">VALID_CHAINIDS</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">breakpoints</span><span class="p">)],</span> <span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">5</span><span class="p">]),</span> <span class="n">insertion</span><span class="p">)))</span>
            <span class="n">tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">4</span><span class="p">])))</span>
            <span class="n">next_nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">next_nt</span> <span class="o">&lt;</span> <span class="n">pos</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">next_nt</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">haswarned_circ</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;Circular RNA not supported. Treating it as non-circular.&quot;</span><span class="p">)</span>
                        <span class="n">haswarned_circ</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">breakpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="n">prev_nt</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fields</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">prev_nt</span> <span class="o">!=</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">breakpoints</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;3rd and 4th column not consistent in ct-file &quot;</span>
                                     <span class="s2">&quot;at pos </span><span class="si">{}</span><span class="s2">. Expecting residue at </span><span class="si">{}</span><span class="s2"> to have &quot;</span>
                                     <span class="s2">&quot;next-residue set to 0 or the beginning &quot;</span>
                                     <span class="s2">&quot;of the chain.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">prev_nt</span> <span class="o">&gt;</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">haswarned_circ</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span>
                            <span class="s2">&quot;Circular RNA not supported. Treating it as non-circular.&quot;</span><span class="p">)</span>
                        <span class="n">haswarned_circ</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span> <span class="o">!=</span> <span class="n">num_nts</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Insufficient nts (</span><span class="si">{}</span><span class="s2">) present in ct file, expecting </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">),</span> <span class="n">num_nts</span><span class="p">))</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">_insert_breakpoints_simple</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">breakpoints</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">seq_ids</span><span class="p">)</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="n">seq_ids</span><span class="p">)</span>
        <span class="n">graph_constr</span> <span class="o">=</span> <span class="n">_BulgeGraphConstruction</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">graph_constr</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">_cleaned_bg</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="p">,</span> <span class="n">remove_pseudoknots</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bg</span></div>

<div class="viewcode-block" id="BulgeGraph.from_bpseq_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_bpseq_str">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_bpseq_str</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bpseq_str</span><span class="p">,</span> <span class="n">breakpoints</span><span class="o">=</span><span class="p">(),</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the graph from a string listing the base pairs.</span>

<span class="sd">        The string should be formatted like so:</span>

<span class="sd">            1 G 115</span>
<span class="sd">            2 A 0</span>
<span class="sd">            3 A 0</span>
<span class="sd">            4 U 0</span>
<span class="sd">            5 U 112</span>
<span class="sd">            6 G 111</span>

<span class="sd">        :param bpseq_str: The string, containing newline characters.</span>
<span class="sd">        :param breakpoints: A list of positions, after which there is a backbone break.</span>
<span class="sd">        :return: A new BulgeGraph object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tuples</span><span class="p">,</span> <span class="n">seq_str</span> <span class="o">=</span> <span class="n">fus</span><span class="o">.</span><span class="n">bpseq_to_tuples_and_seq</span><span class="p">(</span><span class="n">bpseq_str</span><span class="p">)</span>
        <span class="n">seq_str</span> <span class="o">=</span> <span class="n">_insert_breakpoints_simple</span><span class="p">(</span><span class="n">seq_str</span><span class="p">,</span> <span class="n">breakpoints</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">seq_ids</span> <span class="o">=</span> <span class="n">_seq_ids_from_seq_str</span><span class="p">(</span><span class="n">seq_str</span><span class="p">)</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">seq_str</span><span class="p">,</span> <span class="n">seq_ids</span><span class="p">)</span>
        <span class="n">graph_constr</span> <span class="o">=</span> <span class="n">_BulgeGraphConstruction</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">graph_constr</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">_cleaned_bg</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="p">,</span> <span class="n">remove_pseudoknots</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;From bpseq_str: Secondary structure: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                     <span class="n">bg</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">bg</span></div>

<div class="viewcode-block" id="BulgeGraph.from_bg_file"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_bg_file">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_bg_file</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bg_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load a BulgeGraph from a file containing a text-based representation.</span>

<span class="sd">        :param bg_file: The filename.</span>
<span class="sd">        :return: A bulge Graph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">bg_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">bg_string</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_bg_string</span><span class="p">(</span><span class="n">bg_string</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.from_bg_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_bg_string">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_bg_string</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">bg_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a BulgeGraph from the string created by the method</span>
<span class="sd">        to_bg_string.</span>

<span class="sd">        :param bg_str: The string representation of a BugleGraph.</span>
<span class="sd">        :returns: A BulgeGraphObject</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize an empty BulgeGraph. (this is cumbersome by design)</span>
        <span class="k">class</span> <span class="nc">DummyGraphConstr</span><span class="p">:</span>
            <span class="n">defines</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Creating empty BG&quot;</span><span class="p">)</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">DummyGraphConstr</span><span class="p">(),</span> <span class="n">Sequence</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="p">[]))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Now loading BG&quot;</span><span class="p">)</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">bg_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">length</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">seq_loader</span> <span class="o">=</span> <span class="n">SequenceLoader</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># blank line</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">seq_loader</span><span class="o">.</span><span class="n">consume_fields</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
                <span class="n">length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;define&#39;</span><span class="p">:</span>
                <span class="n">bg</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;connect&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
                    <span class="n">bg</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="n">bg</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span>
                <span class="n">bg</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;info&#39;</span><span class="p">:</span>
                <span class="n">bg</span><span class="o">.</span><span class="n">infos</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
        <span class="n">bg</span><span class="o">.</span><span class="n">_seq</span> <span class="o">=</span> <span class="n">seq_loader</span><span class="o">.</span><span class="n">sequence</span>
        <span class="k">return</span> <span class="n">bg</span></div>

<div class="viewcode-block" id="BulgeGraph.from_fasta_text"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_fasta_text">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_fasta_text</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">fasta_text</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                        <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create one or more Bulge Graphs from some fasta text.</span>

<span class="sd">        :returns: A list of BulgeGraphs</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compile searches for the fasta id, sequence and</span>
        <span class="c1"># secondary structure respectively</span>
        <span class="n">id_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;&gt;(.+)&#39;</span><span class="p">)</span>
        <span class="n">seq_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^([acgutACGUT&amp;]+)$&#39;</span><span class="p">)</span>
        <span class="n">stru_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;^([()</span><span class="si">{}</span><span class="s1">&lt;&gt;.A-Za-z&amp;\[\]]+)$&#39;</span><span class="p">)</span>

        <span class="n">prev_id</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">prev_seq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">prev_struct</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">curr_id</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">bgs</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fasta_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)):</span>
            <span class="c1"># newlines suck</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="c1"># We allow comments</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="c1"># find out what this line contains</span>
            <span class="n">id_match</span> <span class="o">=</span> <span class="n">id_search</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">seq_match</span> <span class="o">=</span> <span class="n">seq_search</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="n">stru_match</span> <span class="o">=</span> <span class="n">stru_search</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">id_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">prev_id</span> <span class="o">=</span> <span class="n">curr_id</span>
                <span class="c1"># we found an id, check if there&#39;s a previous</span>
                <span class="c1"># sequence and structure, and create a BG</span>
                <span class="n">curr_id</span> <span class="o">=</span> <span class="n">id_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">prev_seq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prev_struct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># must be the first sequence/structure</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">prev_struct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span>
                        <span class="s2">&quot;No structure for id: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prev_id</span><span class="p">))</span>

                <span class="n">bg</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="n">prev_struct</span><span class="p">,</span> <span class="n">prev_seq</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">prev_id</span><span class="p">,</span>
                                         <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="n">dissolve_length_one_stems</span><span class="p">,</span>
                                         <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="n">remove_pseudoknots</span><span class="p">)</span>
                <span class="n">bgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span>
                <span class="n">prev_seq</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">prev_struct</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">prev_id</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">seq_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">curr_seq</span> <span class="o">=</span> <span class="n">seq_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">if</span> <span class="s2">&quot;t&quot;</span> <span class="ow">in</span> <span class="n">curr_seq</span> <span class="ow">or</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">curr_seq</span><span class="p">:</span>
                    <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                        <span class="s2">&quot;Original sequence contained T. All occurrences of T/t were replaced by U/u respectively!&quot;</span><span class="p">)</span>
                    <span class="n">curr_seq</span> <span class="o">=</span> <span class="n">curr_seq</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">)</span>
                    <span class="n">curr_seq</span> <span class="o">=</span> <span class="n">curr_seq</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">prev_seq</span><span class="p">:</span>
                    <span class="n">prev_seq</span> <span class="o">+=</span> <span class="n">curr_seq</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev_seq</span> <span class="o">=</span> <span class="n">curr_seq</span>

            <span class="k">if</span> <span class="n">id_match</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">seq_match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">stru_match</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">prev_struct</span><span class="p">:</span>
                        <span class="n">prev_struct</span> <span class="o">+=</span> <span class="n">line</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">prev_struct</span> <span class="o">=</span> <span class="n">line</span>
                <span class="k">elif</span> <span class="n">line</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span>
                        <span class="s2">&quot;Cannot parse line </span><span class="si">{}</span><span class="s2">: &#39;</span><span class="si">{}</span><span class="s2">&#39; is neither sequence, nor structure, nor name (starting with &#39;&gt;&#39;), nor comment (starting with &#39;#&#39;).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">prev_struct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span>
                <span class="s2">&quot;Error during parsing of fasta file. No structure found for id </span><span class="si">{}</span><span class="s2"> and sequence </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prev_id</span><span class="p">,</span> <span class="n">prev_seq</span><span class="p">))</span>

        <span class="n">bg</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="n">prev_struct</span><span class="p">,</span> <span class="n">prev_seq</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">curr_id</span><span class="p">,</span>
                                 <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="n">dissolve_length_one_stems</span><span class="p">,</span>
                                 <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="n">remove_pseudoknots</span><span class="p">)</span>
        <span class="n">bgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">bgs</span></div>

<div class="viewcode-block" id="BulgeGraph.from_fasta"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_fasta">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_fasta</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of BulgeGraphs from a fasta file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">fasta_text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_fasta_text</span><span class="p">(</span><span class="n">fasta_text</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="p">)</span></div>

    <span class="c1">############################################################################</span>
    <span class="c1"># Convert this object to different file formats.</span>
    <span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

<div class="viewcode-block" id="BulgeGraph.to_bg_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_bg_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_bg_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output a string representation that can be stored and reloaded.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_name_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_length_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">get_bg_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_define_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_connect_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_info_str</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="BulgeGraph.to_file"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">out_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_element_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_element_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_element_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_numbers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a string similar to dotbracket notation that identifies what</span>
<span class="sd">        type of element is present at each location.</span>

<span class="sd">        For example the following dotbracket:</span>

<span class="sd">        ..((..))..</span>

<span class="sd">        Should yield the following element string:</span>

<span class="sd">        ffsshhsstt</span>

<span class="sd">        Indicating that it begins with a fiveprime region, continues with a</span>
<span class="sd">        stem, has a hairpin after the stem, the stem continues and it is terminated</span>
<span class="sd">        by a threeprime region.</span>

<span class="sd">        :param with_numbers: show the last digit of the element id in a second line.::</span>

<span class="sd">                                 (((.(((...))))))</span>

<span class="sd">                             Could result in::</span>

<span class="sd">                                 sssissshhhssssss</span>
<span class="sd">                                 0000111000111000</span>

<span class="sd">                             Indicating that the first stem is named &#39;s0&#39;, followed by &#39;i0&#39;,&#39;</span>
<span class="sd">                             s1&#39;, &#39;h0&#39;, the second strand of &#39;s1&#39; and the second strand of &#39;s0&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;To element_string from defines </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span>
        <span class="n">output_str</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">output_nr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">resi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="n">output_str</span><span class="p">[</span><span class="n">resi</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">output_nr</span><span class="p">[</span><span class="n">resi</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">with_numbers</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_str</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_nr</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_str</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span></div>

<div class="viewcode-block" id="BulgeGraph.to_neato_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_neato_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_neato_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="c1"># The different nodes for different types of bulges</span>
        <span class="n">node_lines</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">fontsize</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;graph G {&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">graph [overlap=false,splines=true];&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">node [shape=box];&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># Create the nodes with a different color for each type of element</span>
            <span class="k">if</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,fillcolor=&quot;#B3E2CD&quot;,fontsize=</span><span class="si">%d</span><span class="s1">,label=</span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\\</span><span class="s1">n(</span><span class="si">%d</span><span class="s1">)</span><span class="se">\&quot;</span><span class="s1">] </span><span class="si">%s</span><span class="s1">};&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">fontsize</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">key2</span><span class="p">),</span> <span class="n">key2</span><span class="p">))</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#FFF2AE&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#F4CAE4&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#FDCDAC&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#E6F5C9&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#CBD5E8&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">))</span>

            <span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;,label=</span><span class="se">\&quot;</span><span class="si">%s</span><span class="s1"> </span><span class="se">\\</span><span class="s1">n&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key2</span><span class="p">)</span>

            <span class="c1"># figure out the size of the node and use that as a label</span>
            <span class="n">node_dims</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_dimensions</span><span class="p">(</span><span class="n">key2</span><span class="p">)</span>
            <span class="n">total_bulge</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node_dims</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">node_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">node_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">node_dims</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">node_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">node_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">node_dims</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Dims of node </span><span class="si">%s</span><span class="s2"> are </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">node_dims</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_dims</span><span class="p">)</span>

            <span class="c1"># make bigger interior loops visually bigger</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">total_bulge</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">)</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">width</span>

            <span class="k">if</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">,width=</span><span class="si">%f</span><span class="s2">,heigh=</span><span class="si">%f</span><span class="s2">] </span><span class="si">%s</span><span class="s2">};&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">key2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">] </span><span class="si">%s</span><span class="s2">};&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key1</span><span class="p">]:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="si">%s</span><span class="s2"> -- </span><span class="si">%s</span><span class="s2">;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">))</span>

        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_pair_table"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_pair_table">[docs]</a>    <span class="k">def</span> <span class="nf">to_pair_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pair table from the list of elements.</span>

<span class="sd">        The first element in the returned list indicates the number of</span>
<span class="sd">        nucleotides in the structure.</span>

<span class="sd">        i.e. [5,5,4,0,2,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pair_tuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_tuples</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fus</span><span class="o">.</span><span class="n">tuples_to_pairtable</span><span class="p">(</span><span class="n">pair_tuples</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_pair_tuples"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_pair_tuples">[docs]</a>    <span class="k">def</span> <span class="nf">to_pair_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">remove_basepairs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list of tuples corresponding to all of the base pairs in the</span>
<span class="sd">        structure. Unpaired bases will be shown as being paired with a</span>
<span class="sd">        nucleotide numbered 0.</span>

<span class="sd">        i.e. [(1,5),(2,4),(3,0),(4,2),(5,1)]</span>

<span class="sd">        :param remove_basepairs: A list of 2-tuples containing</span>
<span class="sd">                                 basepairs that should be removed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># iterate over each element</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="c1"># iterate over each nucleotide in each element</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">table</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">remove_basepairs</span><span class="p">:</span>
            <span class="n">nt</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">table</span><span class="p">:</span>
                <span class="n">to_add</span> <span class="o">=</span> <span class="n">p</span>
                <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">remove_basepairs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                        <span class="n">to_add</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                        <span class="k">break</span>
                <span class="n">nt</span> <span class="o">+=</span> <span class="p">[</span><span class="n">to_add</span><span class="p">]</span>
            <span class="n">table</span> <span class="o">=</span> <span class="n">nt</span>
        <span class="k">return</span> <span class="n">table</span></div>

<div class="viewcode-block" id="BulgeGraph.to_bpseq_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_bpseq_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_bpseq_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bpseq string from this structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="BulgeGraph.to_dotbracket_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_dotbracket_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_dotbracket_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the BulgeGraph representation to a dot-bracket string</span>
<span class="sd">        and return it.</span>

<span class="sd">        :return: A dot-bracket representation of this BulgeGraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_table</span><span class="p">()</span>
        <span class="n">db_string</span> <span class="o">=</span> <span class="n">fus</span><span class="o">.</span><span class="n">pairtable_to_dotbracket</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">include_missing</span><span class="p">:</span>
            <span class="n">db_string</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">with_missing</span><span class="o">.</span><span class="n">update_dotbracket</span><span class="p">(</span><span class="n">db_string</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">breakpoint</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">)):</span>
                <span class="n">db_string</span> <span class="o">=</span> <span class="n">db_string</span><span class="p">[:</span><span class="n">breakpoint</span><span class="p">]</span> <span class="o">+</span> \
                    <span class="s2">&quot;&amp;&quot;</span> <span class="o">+</span> <span class="n">db_string</span><span class="p">[</span><span class="n">breakpoint</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">db_string</span></div>

<div class="viewcode-block" id="BulgeGraph.to_fasta_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_fasta_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_fasta_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">include_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output the BulgeGraph representation as a fast string of the</span>
<span class="sd">        format::</span>

<span class="sd">            &gt;id</span>
<span class="sd">            AACCCAA</span>
<span class="sd">            ((...))</span>

<span class="sd">        :param include_missing: Whether or not residues for which no structure</span>
<span class="sd">                                information is present should be included in the output.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">include_missing</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">with_missing</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span>
        <span class="k">return</span> <span class="s2">&quot;&gt;</span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="se">\n</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">(</span><span class="n">include_missing</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.to_networkx"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_networkx">[docs]</a>    <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this graph to a networkx representation. This representation</span>
<span class="sd">        will contain all of the nucleotides as nodes and all of the base pairs</span>
<span class="sd">        as edges as well as the adjacent nucleotides.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">residues</span> <span class="o">+=</span> <span class="p">[</span><span class="n">r</span><span class="p">]</span>

        <span class="c1"># Add links along the backbone</span>
        <span class="n">residues</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c1"># Add links along basepairs</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>

    <span class="c1">###########################################################################</span>
    <span class="c1"># Helper functions only used for conversion</span>
    <span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
    <span class="k">def</span> <span class="nf">_get_single_define_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a define string for a single key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;define </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]]))</span>

    <span class="k">def</span> <span class="nf">_get_define_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the defines into a string.</span>

<span class="sd">        Format:</span>

<span class="sd">        define [name] [start_res1] [end_res1] [start_res2] [end_res2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defines_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># a method for sorting the defines</span>
        <span class="k">def</span> <span class="nf">define_sorter</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">drni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">drni</span><span class="p">)</span>  <span class="c1"># .next()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">define_sorter</span><span class="p">):</span>
            <span class="n">defines_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_single_define_str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># defines_str += &quot;define %s %s&quot; % ( key, &quot; &quot;.join([str(d) for d in self.defines[key]]))</span>
            <span class="n">defines_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">defines_str</span>

    <span class="k">def</span> <span class="nf">_get_length_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;length &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

    <span class="k">def</span> <span class="nf">_get_info_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">[</span><span class="n">info</span><span class="p">]:</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="s2">&quot;info &quot;</span> <span class="o">+</span> <span class="n">info</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span> <span class="o">+</span> <span class="n">value</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">_get_connect_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the connections of the bulges in the graph.</span>

<span class="sd">        Format:</span>

<span class="sd">        connect [from] [to1] [to2] [to3]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">whole_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Our graph will be defined by the stems and the bulges they connect to</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">out_str</span> <span class="o">=</span> <span class="s2">&quot;connect </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">dest</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>

                <span class="n">whole_str</span> <span class="o">+=</span> <span class="n">out_str</span>
                <span class="n">whole_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">return</span> <span class="n">whole_str</span>

    <span class="k">def</span> <span class="nf">_get_name_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the name of this structure along with its keyword:</span>

<span class="sd">            name 1y26</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;name </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

    <span class="c1">############################################################################</span>
    <span class="c1"># Descriptors of the BulgeGraph as a whole</span>
    <span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">seq_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">seq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seq</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">backbone_breaks_after</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">backbone_breaks_after</span>

<div class="viewcode-block" id="BulgeGraph.get_domains"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_domains">[docs]</a>    <span class="k">def</span> <span class="nf">get_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get secondary structure domains.</span>

<span class="sd">        Currently domains found are:</span>
<span class="sd">          * multiloops (without any connected stems)</span>
<span class="sd">          * rods: stretches of stems + interior loops (without branching), with trailing hairpins</span>
<span class="sd">          * pseudoknots</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">domains</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">multiloops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_mlonly_multiloops</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ml</span> <span class="ow">in</span> <span class="n">multiloops</span><span class="p">:</span>
            <span class="n">ml</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loop_pseudoknot</span><span class="p">(</span><span class="n">ml</span><span class="p">):</span>
                <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;pseudoknots&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;multiloops&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>

        <span class="n">doublestr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">doublestr</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">region</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="n">region</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">):</span>
                    <span class="n">curr_region</span> <span class="o">=</span> <span class="n">region</span>
                    <span class="n">curr_region</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">doublestr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">s</span><span class="p">]))</span>
                <span class="n">curr_region</span> <span class="o">=</span> <span class="n">doublestr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;sih&quot;</span><span class="p">:</span>
                    <span class="n">curr_region</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1"># print(doublestr)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">doublestr</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">reg1</span> <span class="o">&amp;</span> <span class="n">reg2</span><span class="p">:</span>
                    <span class="n">doublestr</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">reg1</span><span class="p">)</span>
                    <span class="n">doublestr</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">reg2</span><span class="p">)</span>
                    <span class="n">doublestr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg1</span> <span class="o">|</span> <span class="n">reg2</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">doublestr</span><span class="p">:</span>
            <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;rods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="nb">sorted</span><span class="p">(</span><span class="n">region</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">))</span>
        <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;pseudoknots&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;multiloops&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;rods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1"># print(domains)</span>
        <span class="k">return</span> <span class="n">domains</span></div>

    <span class="c1">############################################################################</span>
    <span class="c1"># Domains 2.0</span>
    <span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">junctions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get all regular multiloops of this structure.</span>

<span class="sd">        :return: A list of tuples of multiloop segments.</span>
<span class="sd">                 Each tuple contains the segments of one regular</span>
<span class="sd">                 (i.e. not pseudoknotted) multiloop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">multiloops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_mlonly_multiloops</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ml</span> <span class="ow">in</span> <span class="n">multiloops</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loop_pseudoknot</span><span class="p">(</span><span class="n">ml</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">rods</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">domains</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_domains</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;rods&quot;</span><span class="p">]</span>

    <span class="c1">############################################################################</span>
    <span class="c1"># Descriptors of individual elements</span>
    <span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
<div class="viewcode-block" id="BulgeGraph.element_length"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.element_length">[docs]</a>    <span class="k">def</span> <span class="nf">element_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of residues that are contained within this element.</span>

<span class="sd">        :param key: The name of the element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">length</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_length"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_length">[docs]</a>    <span class="k">def</span> <span class="nf">stem_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the length of a particular element. If it&#39;s a stem, it&#39;s equal to</span>
<span class="sd">        the number of paired bases. If it&#39;s an interior loop, it&#39;s equal to the</span>
<span class="sd">        number of unpaired bases on the strand with less unpaired bases. If</span>
<span class="sd">        it&#39;s a multiloop, then it&#39;s the number of unpaired bases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span> <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.define_a"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.define_a">[docs]</a>    <span class="k">def</span> <span class="nf">define_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="c1"># Special case, because interior loops can have</span>
        <span class="c1"># defines of length 2 or 4</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span><span class="p">:</span>
            <span class="n">conns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">conns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">conns</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The following may call this classes</span>
            <span class="c1"># _define_a_nonzero implementation.</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">BulgeGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.is_single_stranded"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.is_single_stranded">[docs]</a>    <span class="k">def</span> <span class="nf">is_single_stranded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does this node represent a single-stranded region?</span>

<span class="sd">        Single stranded regions are five-prime and three-prime unpaired</span>
<span class="sd">        regions, multiloops, and hairpins</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Interior loops are never considered single stranded by this function.</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        :return: True if yes, False if no</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BulgeGraph.get_node_dimensions"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_node_dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">with_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimensions of a node.</span>

<span class="sd">        If the node is a stem, then the dimensions will be l where l is</span>
<span class="sd">        the length of the stem.</span>

<span class="sd">        Otherwise, see get_bulge_dimensions(node)</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        :return: A pair containing its dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">with_missing</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;get_node_dimensions: &#39;with_missing&#39;-flag is currently ignored for stems!&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">with_missing</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;BulgeDimensions of </span><span class="si">%s</span><span class="s2"> are </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">bd</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">bd</span></div>

<div class="viewcode-block" id="BulgeGraph.get_bulge_dimensions"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_bulge_dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">get_bulge_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">,</span> <span class="n">with_missing</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimensions of the bulge.</span>

<span class="sd">        If it is single stranded it will be (x, -1) for h,t,f or (x, 1000) for m.</span>
<span class="sd">        Otherwise it will be (x, y).</span>

<span class="sd">        :param bulge: The name of the bulge.</span>
<span class="sd">        :return: A pair containing its dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Stems are not allowed in get_bulge_dimensions&quot;</span><span class="p">)</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">bulge</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">with_missing</span><span class="p">:</span>
            <span class="n">get_define_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">with_missing</span><span class="o">.</span><span class="n">define_length</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">get_define_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">define_length</span>

        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># if this interior loop only has one unpaired region</span>
            <span class="c1"># then we have to find out if it&#39;s on the 5&#39; strand or</span>
            <span class="c1"># the 3&#39; strand</span>
            <span class="c1"># Example:</span>
            <span class="c1"># s1 1 3</span>
            <span class="c1"># 23 25</span>
            <span class="c1"># s2 5 10</span>
            <span class="c1"># 15 20</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Getting bulge dimensions for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">get_define_len</span><span class="p">([</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">get_define_len</span><span class="p">([</span><span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bd</span><span class="p">:</span>
                <span class="n">dim0</span> <span class="o">=</span> <span class="n">get_define_len</span><span class="p">([</span><span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dim0</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
                <span class="n">dim1</span> <span class="o">=</span> <span class="mi">1000</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dim1</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">dim0</span><span class="p">,</span> <span class="n">dim1</span></div>

<div class="viewcode-block" id="BulgeGraph.get_length"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_length">[docs]</a>    <span class="k">def</span> <span class="nf">get_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the minimum length of a vertex.</span>

<span class="sd">        If it&#39;s a stem, then the result is its length (in base pairs).</span>

<span class="sd">        If it&#39;s a bulge, then the length is the smaller of it&#39;s dimensions.</span>

<span class="sd">        :param vertex: The name of the vertex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">vertex</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span></div>

    <span class="c1">############################################################################</span>
    <span class="c1"># Private functions related to descriptors</span>
    <span class="c1">#~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span>
    <span class="k">def</span> <span class="nf">_define_a_nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a define including the adjacent nucleotides.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;define_a nonzero of BulgeGraph called for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
        <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
        <span class="n">new_def</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">define</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Left-side adjacent nt is in &quot;</span>
                          <span class="s2">&quot;backbone-breaks: </span><span class="si">%s</span><span class="s2"> in </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">)</span>
                <span class="n">new_def</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_def</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
                <span class="n">new_def</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">new_def</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">new_def</span>

    <span class="k">def</span> <span class="nf">_all_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the connected elements in order along the backbone.</span>

<span class="sd">        The difference to self.connections is that the returned list</span>
<span class="sd">        always contains as many elements, as the define of elem has numbers.</span>
<span class="sd">        If there is no connected element at this side,the returned list contains None.</span>
<span class="sd">        If elem is a stem connected to a hairpin or interior loop,</span>
<span class="sd">        this loop will be contained twice in the resulting output list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># To correctly account for 0-length elements, we have to treat stems seperately.</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
                <span class="n">neighbor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="o">==</span> <span class="n">elem</span><span class="p">:</span>
                    <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">elem</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="n">side</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)):</span>
                        <span class="n">connections</span><span class="p">[</span><span class="n">side</span><span class="p">]</span> <span class="o">=</span> <span class="n">neighbor</span>
        <span class="k">return</span> <span class="n">connections</span>
    <span class="c1">############################################################################</span>

<div class="viewcode-block" id="BulgeGraph.get_elem"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_elem">[docs]</a>    <span class="k">def</span> <span class="nf">get_elem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">position</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the secondary structure element from a nucleotide position</span>

<span class="sd">        :param position: An integer or a fgr.RESID instance, describing the nucleotide number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">position</span><span class="p">,</span> <span class="n">RESID</span><span class="p">):</span>
            <span class="n">position</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_integer</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">position</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_to_resnum</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_node_to_resnum</span><span class="p">[</span><span class="n">position</span><span class="p">]</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span>
                <span class="n">BulgeGraph</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_node_to_resnum</span><span class="p">[</span><span class="n">position</span><span class="p">]</span></div>

<div class="viewcode-block" id="BulgeGraph.get_node_from_residue_num"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_node_from_residue_num">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_from_residue_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        USE get_elem instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_elem</span><span class="p">(</span><span class="n">base_num</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">transformed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">fgt</span><span class="o">.</span><span class="n">BGTransformer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<div class="viewcode-block" id="BulgeGraph.add_info"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.add_info">[docs]</a>    <span class="k">def</span> <span class="nf">add_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_bp_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_bp_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">stem_bp_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all the base pairs in the stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">stem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>
        <span class="n">stem_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stem_length</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">seq_ids</span><span class="p">:</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_resid</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_resid</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">stem_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the stems in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">assert</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;ftsmih&quot;</span><span class="p">,</span> <span class="s2">&quot;stem_iterator should only be called after relabelling of nodes during GraphConstruction&quot;</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.pairing_partner"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.pairing_partner">[docs]</a>    <span class="k">def</span> <span class="nf">pairing_partner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nucleotide_number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the base pairing partner of the nucleotide at position</span>
<span class="sd">        nucleotide_number. If this nucleotide is unpaired, return None.</span>

<span class="sd">        :param nucleotide_number: The position of the query nucleotide in the</span>
<span class="sd">                                  sequence or a RESID instance.</span>
<span class="sd">        :return: The number of the nucleotide base paired with the one at</span>
<span class="sd">                 position nucleotide_number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nucleotide_number</span><span class="p">,</span> <span class="n">RESID</span><span class="p">):</span>
                <span class="n">bp_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">bp_iter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">bp_iter</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">r1</span> <span class="o">==</span> <span class="n">nucleotide_number</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">r2</span>
                <span class="k">elif</span> <span class="n">r2</span> <span class="o">==</span> <span class="n">nucleotide_number</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">r1</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.iterate_over_seqid_range"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.iterate_over_seqid_range">[docs]</a>    <span class="k">def</span> <span class="nf">iterate_over_seqid_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_id</span><span class="p">,</span> <span class="n">end_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the seq_ids between the start_id and end_id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">iter_resids</span><span class="p">(</span><span class="n">start_id</span><span class="p">,</span> <span class="n">end_id</span><span class="p">):</span> <span class="c1"># TODO: replace with yield from, once we drop python 2 support</span>
            <span class="k">yield</span> <span class="n">res</span></div>

<div class="viewcode-block" id="BulgeGraph.seq_id_to_pos"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.seq_id_to_pos">[docs]</a>    <span class="k">def</span> <span class="nf">seq_id_to_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a pdb seq_id to a 1-based nucleotide position</span>

<span class="sd">        :param seq_id: An instance of RESID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">RESID</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> of type </span><span class="si">{}</span><span class="s2"> is not RESID&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="nb">repr</span><span class="p">(</span><span class="n">seq_id</span><span class="p">),</span> <span class="nb">type</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_integer</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.shortest_bg_loop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.shortest_bg_loop">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_bg_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a shortest loop containing this node. The vertex should</span>
<span class="sd">        be a multiloop.</span>

<span class="sd">        :param vertex: The name of the vertex to find the loop.</span>
<span class="sd">        :return: A list containing the elements in the shortest cycle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Starting shortest BG loop for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">vertex</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;nx graph  </span><span class="si">%r</span><span class="s2"> with edges </span><span class="si">%r</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span>

        <span class="c1"># use the nucleotide in the middle of this element as the starting point</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span>
            <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
        <span class="n">mid_res</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;mid_residue </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">mid_res</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># no-residue multiloop</span>
            <span class="c1"># find the neighbor which isn&#39;t part of the multiloop</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">mid_res</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># break the chain so that we don&#39;t get cycles within a stem</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">mid_res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mid_res</span><span class="p">)</span>
                        <span class="k">break</span>

        <span class="kn">import</span> <span class="nn">forgi.utilities.graph</span> <span class="k">as</span> <span class="nn">fug</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">fug</span><span class="o">.</span><span class="n">shortest_cycle</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">mid_res</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Shortest cycle is </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span></div>

    <span class="k">def</span> <span class="nf">_chain_start_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Pos </span><span class="si">{}</span><span class="s2"> is not at the end of a chain.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

<div class="viewcode-block" id="BulgeGraph.get_next_ml_segment"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_next_ml_segment">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">get_next_ml_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ml_segment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the adjacent multiloop-segment (or 3&#39; loop) next to the 3&#39; side of ml_segment.</span>

<span class="sd">        If there is no other single stranded RNA after the stem, the backbone must end there.</span>
<span class="sd">        In that case return None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;get_next_ml_segment called for </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ml_segment</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ml_segment</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ml_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;mf&quot;</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">ml_segment</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a multiloop&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ml_segment</span><span class="p">))</span>

            <span class="c1"># The stem following the ml-segment</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">ml_segment</span><span class="p">:</span>
                <span class="c1"># The Cg consists of only a single f-element.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">side_stem</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sides_plus</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ml_segment</span><span class="p">)</span>
            <span class="c1"># Get the stem-side where we expect to find the next ML-segment</span>
            <span class="k">if</span> <span class="n">side_stem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">side_stem</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="n">side_stem</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">side_stem</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">side_stem</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">side_stem</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="n">side_stem</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">side_stem</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;flanking_nuc_at_stem_side called for </span><span class="si">%s</span><span class="s2">, side </span><span class="si">%s</span><span class="s2"> with defines </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span>
                  <span class="n">s</span><span class="p">,</span> <span class="n">side_stem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="n">ml_nuc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nuc_at_stem_side</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">side_stem</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;ml_nucleotide is </span><span class="si">%s</span><span class="s2"> (sequence length is </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="p">,</span>
                  <span class="n">ml_nuc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">)</span>
        <span class="c1"># End of the backbone</span>
        <span class="k">if</span> <span class="n">ml_nuc</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="ow">or</span> <span class="n">ml_nuc</span> <span class="o">-</span> <span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">ml_nuc</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;side now </span><span class="si">%s</span><span class="s2">, ml_nuc </span><span class="si">%s</span><span class="s2">, ml </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">side_stem</span><span class="p">,</span> <span class="n">ml_nuc</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>
            <span class="c1"># 0-length multiloop</span>
            <span class="n">elems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_length</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">elem</span>
            <span class="k">assert</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;mft&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a multiloop node&quot;</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
            <span class="k">assert</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">elem</span></div>

<div class="viewcode-block" id="BulgeGraph.shortest_mlonly_multiloop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.shortest_mlonly_multiloop">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_mlonly_multiloop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ml_segment</span><span class="p">):</span>
        <span class="n">loops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_mlonly_multiloops</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">loops</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ml_segment</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">loop</span></div>

<div class="viewcode-block" id="BulgeGraph.flanking_nuc_at_stem_side"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.flanking_nuc_at_stem_side">[docs]</a>    <span class="k">def</span> <span class="nf">flanking_nuc_at_stem_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the nucleotide number that is next to the stem at the given stem side.</span>

<span class="sd">        :param side: 0, 1, 2 or 3, as returned by self._get_sides_plus</span>
<span class="sd">        :returns: The nucleotide position. If the stem has no neighbor at that side,</span>
<span class="sd">                  0 or self.seq_length+1 is returned instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a stem&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">stem_nuc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stem_nuc</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stem_nuc</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="BulgeGraph.nucleotides_to_elements"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.nucleotides_to_elements">[docs]</a>    <span class="k">def</span> <span class="nf">nucleotides_to_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nucleotides</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a list of nucleotides (nucleotide numbers) to element names.</span>

<span class="sd">        Remove redundant entries and return a set.</span>

<span class="sd">        ..note::</span>
<span class="sd">            Use `self.get_node_from_residue_num` if you have only a single nucleotide number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nucleotides</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.elements_to_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.elements_to_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">elements_to_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a list of element names to a list of nucleotide numbers.</span>

<span class="sd">        Remove redundant entries.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nucs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">def_range</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_range_iterator</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">def_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">def_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">nucs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nuc</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nucs</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.find_bulge_loop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.find_bulge_loop">[docs]</a>    <span class="k">def</span> <span class="nf">find_bulge_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a set of nodes that form a loop containing the</span>
<span class="sd">        given vertex and being no greater than max_length nodes long.</span>

<span class="sd">        :param vertex: The vertex to start the search from.</span>
<span class="sd">        :param max_length: Only fond loops that contain no more then this many elements</span>
<span class="sd">        :returns: A list of the nodes in the loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">vertex</span><span class="p">]]</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="n">in_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertex</span><span class="p">]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_visit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

            <span class="n">in_path</span> <span class="o">=</span> <span class="n">in_path</span><span class="p">[:</span><span class="n">depth</span><span class="p">]</span>
            <span class="n">in_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">vertex</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_path</span><span class="p">[:</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">in_path</span><span class="p">[:</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">to_visit</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[]</span></div>


<div class="viewcode-block" id="BulgeGraph.length_one_stem_basepairs"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.length_one_stem_basepairs">[docs]</a>    <span class="k">def</span> <span class="nf">length_one_stem_basepairs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of basepairs that correspond to length-1 stems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># dissolve all stems which have a length of one</span>
        <span class="n">stems_to_dissolve</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">log</span><span class="o">.</span><span class="n">isEnabledFor</span><span class="p">(</span><span class="n">logging</span><span class="o">.</span><span class="n">WARNING</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stems_to_dissolve</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">()))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;All stems of the structure have length 1!&quot;</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Stems with length 1: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stems_to_dissolve</span><span class="p">)</span>
        <span class="n">bps_to_dissolve</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stems_to_dissolve</span><span class="p">:</span>
            <span class="n">bps_to_dissolve</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">bps_to_dissolve</span></div>

<div class="viewcode-block" id="BulgeGraph.has_connection"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.has_connection">[docs]</a>    <span class="k">def</span> <span class="nf">has_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is there an edge between these two nodes &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">v2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># two multiloops can be connected at the end of a stem</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">v2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
                    <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">s1e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">s2b</span><span class="p">,</span> <span class="n">s2e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">s1b</span> <span class="o">==</span> <span class="n">s2b</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BulgeGraph.connection_type"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.connection_type">[docs]</a>    <span class="k">def</span> <span class="nf">connection_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify the way that two stems are connected according to the type</span>
<span class="sd">        of bulge that separates them.</span>

<span class="sd">        Potential angle types for single stranded segments, and the ends of</span>
<span class="sd">        the stems they connect:</span>

<span class="sd">        =   = ======  ===========</span>
<span class="sd">        1   2 (1, 1)  #pseudoknot</span>
<span class="sd">        1   0 (1, 0)</span>
<span class="sd">        3   2 (0, 1)</span>
<span class="sd">        3   0 (0, 0)</span>
<span class="sd">        =   = ======  ===========</span>

<span class="sd">        :param define: The name of the bulge separating the two stems</span>
<span class="sd">        :param connections: The two stems and their separation</span>

<span class="sd">        :returns: INT connection type</span>

<span class="sd">                  =   ======================================================================</span>
<span class="sd">                  +   positive values mean forward (from the connected stem starting at the</span>
<span class="sd">                      lower nucleotide number to the one starting at the higher nuc. number)</span>
<span class="sd">                  -   negative values mean backwards.</span>
<span class="sd">                  1   interior loop</span>
<span class="sd">                  2   first multi-loop segment of normal multiloops and most pseudoknots</span>
<span class="sd">                  3   middle segment of a normal multiloop</span>
<span class="sd">                  4   last segment of normal multiloops and most pseudoknots</span>
<span class="sd">                  5   middle segments of pseudoknots</span>
<span class="sd">                  =   ======================================================================</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># interior loop, we just have to check if</span>
            <span class="c1"># connections[0] &lt; connections[1]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">b1c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">define</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s2c</span><span class="p">,</span> <span class="n">b2c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">define</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">2</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">3</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">4</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">4</span>

            <span class="c1"># the next two refer to pseudoknots</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s2">&quot;Weird angle type: (s1c, s2c) = (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                          <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;connection_type called on non-interior loop/multiloop&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.connection_ends"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.connection_ends">[docs]</a>    <span class="k">def</span> <span class="nf">connection_ends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find out which ends of the stems are connected by a particular angle</span>
<span class="sd">        type.</span>

<span class="sd">        :param connection_type: The angle type, as determined by which corners</span>
<span class="sd">                                of a stem are connected</span>
<span class="sd">        :return: (s1e, s2b) 0 means the side of the stem with the lowest nucleotide, 1 the other side</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ends</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span>
                <span class="s1">&#39;Unknown connection type: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">connection_type</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">connection_type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ends</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ends</span></div>

    <span class="c1"># This function seems to be unused. Consider deprecation...</span>
<div class="viewcode-block" id="BulgeGraph.get_multiloop_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_multiloop_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">get_multiloop_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiloop_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of nucleotides which make up a particular</span>
<span class="sd">        multiloop.</span>

<span class="sd">        :param multiloop_loop: The elements which make up this multiloop</span>
<span class="sd">        :return: A list of nucleotides</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">multiloop_loop</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">]</span>
        <span class="n">multis</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">multiloop_loop</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">]</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
            <span class="n">relevant_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">multiloop_loop</span><span class="p">]</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_sides_plus</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">relevant_edges</span><span class="p">]</span>
            <span class="n">sides</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="c1"># the whole stem is part of this multiloop</span>
            <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">or</span> <span class="n">sides</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">residues</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
                                       <span class="p">[</span><span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">residues</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">multis</span><span class="p">:</span>
            <span class="n">residues</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">residues</span></div>

<div class="viewcode-block" id="BulgeGraph.find_mlonly_multiloops"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.find_mlonly_multiloops">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">find_mlonly_multiloops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
        <span class="n">ml_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">floop_iterator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">tloop_iterator</span><span class="p">()):</span>
            <span class="n">next_ml</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_ml_segment</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_ml</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ml_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">next_ml</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ml_graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">loops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">ml_graph</span><span class="p">):</span>
            <span class="c1"># Order along the cycle, in arbitrary direction.</span>

            <span class="c1"># We need to start at a node with only 1 connection, if present</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ml_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">st_node</span> <span class="o">=</span> <span class="n">x</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">st_node</span> <span class="o">=</span> <span class="n">x</span>  <span class="c1"># Just take any node</span>
            <span class="c1"># Sort nodes along the cycle</span>
            <span class="n">loop</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span>
                <span class="n">ml_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">comp</span><span class="p">),</span> <span class="n">st_node</span><span class="p">))</span>
            <span class="c1"># See if we need to reverse the order</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
                <span class="n">next_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_ml_segment</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">loop</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">next_l</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">loop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">next_l</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loop</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="c1"># Find first node</span>
            <span class="n">first</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="n">first_i</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
            <span class="n">loop</span> <span class="o">=</span> <span class="n">loop</span><span class="p">[</span><span class="n">first_i</span><span class="p">:]</span> <span class="o">+</span> <span class="n">loop</span><span class="p">[:</span><span class="n">first_i</span><span class="p">]</span>
            <span class="n">loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">loop</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">loops</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.describe_multiloop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.describe_multiloop">[docs]</a>    <span class="k">def</span> <span class="nf">describe_multiloop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiloop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param multiloop: An iterable of nodes (only &quot;m&quot;, &quot;t&quot; and &quot;f&quot; elements)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">descriptors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">all_stems</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="n">angle_types</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">multiloop</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;ft&quot;</span><span class="p">:</span>
                <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;open&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Non multiloop element &#39;</span><span class="si">{}</span><span class="s2">&#39; encountered in describe_multiloop.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">conn</span><span class="p">))</span>
            <span class="n">angle_types</span><span class="p">[</span><span class="n">ctype</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;pseudoknot&quot;</span><span class="p">)</span>
            <span class="n">all_stems</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">elem</span><span class="p">])</span>
        <span class="c1"># Odd number of occurrences for 2 stems.</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_stems</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;open&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;open&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">descriptors</span><span class="p">:</span>
            <span class="c1"># if any(v!=2 for v in all_stems.values()):</span>
            <span class="c1">#    print(all_stems)</span>
            <span class="c1">#    print(multiloop)</span>
            <span class="c1">#    print(self.to_dotbracket_string())</span>
            <span class="c1">#    print (self.to_element_string(True))</span>
            <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_stems</span><span class="o">.</span><span class="n">values</span><span class="p">())</span> <span class="o">==</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;pseudoknot&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">descriptors</span><span class="p">:</span>
            <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;regular_multiloop&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;pseudoknot&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;open&quot;</span> <span class="ow">in</span> <span class="n">descriptors</span> <span class="ow">and</span> <span class="p">(</span><span class="n">angle_types</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
            <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;pseudoknot&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">descriptors</span></div>

    <span class="k">def</span> <span class="nf">_zerolen_defines_a_between</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Searching for zerolen-coordinates&quot;</span><span class="p">)</span>
        <span class="n">zl_coordinates</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem2</span><span class="p">][</span><span class="n">l</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem2</span><span class="p">][</span><span class="n">l</span><span class="p">]]</span>
                <span class="n">d</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Zero-length element found: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
                    <span class="n">zl_coordinates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;But backbone-break encountered!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">zl_coordinates</span>

<div class="viewcode-block" id="BulgeGraph.log"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.log">[docs]</a>    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">log_at_caller</span><span class="p">(</span><span class="n">log</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">())</span>
            <span class="n">es</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_element_string</span><span class="p">(</span><span class="n">with_numbers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">es</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">es</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="s2">&quot;DEFINES: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="s2">&quot;EDGES: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.sorted_stem_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.sorted_stem_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_stem_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over a list of the stems sorted by the lowest numbered</span>
<span class="sd">        nucleotide in each stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">]</span>
        <span class="n">stems</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">s</span></div>

<div class="viewcode-block" id="BulgeGraph.sorted_element_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.sorted_element_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_element_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over a list of the coarse grained elements sorted by the lowest numbered</span>
<span class="sd">        nucleotide in each stem. Multiloops with no nucleotide coordinates come last.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">]</span>
        <span class="n">elements</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span>
            <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">else</span> <span class="mi">10000</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">e</span></div>

<div class="viewcode-block" id="BulgeGraph.adjacent_stem_pairs_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.adjacent_stem_pairs_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">adjacent_stem_pairs_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all pairs of stems which are separated by some element.</span>

<span class="sd">        This will always yield triples of the form (s1, e1, s2) where s1 and</span>
<span class="sd">        s2 are the stem identifiers and e1 denotes the element that separates</span>
<span class="sd">        them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.get_connected_residues"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_connected_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_connected_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">bulge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nucleotides which are connected by the element separating</span>
<span class="sd">        s1 and s2. They should be adjacent stems.</span>

<span class="sd">        :param s1, s2: 2 adjacent stems</span>
<span class="sd">        :param bulge: Optional: The bulge seperating the two stems.</span>
<span class="sd">                      If s1 and s2 are connected by more than one element,</span>
<span class="sd">                      this has to be given, or a ValueError will be raised.</span>
<span class="sd">                      (useful for pseudoknots)</span>

<span class="sd">        The connected nucleotides are those which are spanned by a single</span>
<span class="sd">        interior loop or multiloop. In the case of an interior loop, this</span>
<span class="sd">        function will return a list of two tuples and in the case of multiloops</span>
<span class="sd">        if it will be a list of one tuple.</span>

<span class="sd">        If the two stems are not separated by a single element, then return</span>
<span class="sd">        an empty list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span>

        <span class="c1"># find out which edges they share</span>
        <span class="n">common_edges</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># not connected</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">bulge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many connections between the stems. &quot;</span>
                             <span class="s2">&quot;Please provide the connectiong bulge you are interested in.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge</span> <span class="ow">and</span> <span class="n">bulge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">  does not connecty the stems </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>

        <span class="c1"># the element linking the two stems</span>
        <span class="k">if</span> <span class="n">bulge</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">bulge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># find out the sides of the stems that face the bulge</span>
        <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">s1e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
        <span class="p">(</span><span class="n">s2b</span><span class="p">,</span> <span class="n">s2e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>

        <span class="c1"># get the nucleotides on the side facing the stem</span>
        <span class="n">s1_nucleotides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s1b</span><span class="p">)</span>
        <span class="n">s2_nucleotides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s2b</span><span class="p">)</span>

        <span class="c1"># find out the distances between all the nucleotides flanking</span>
        <span class="c1"># the bulge</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">s1_nucleotides</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">s2_nucleotides</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">+=</span> <span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n2</span> <span class="o">-</span> <span class="n">n1</span><span class="p">),</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)]</span>
        <span class="n">dists</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># return the ones which are closest to each other first</span>
        <span class="k">if</span> <span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]),</span> <span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span></div>

<div class="viewcode-block" id="BulgeGraph.get_link_direction"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_link_direction">[docs]</a>    <span class="k">def</span> <span class="nf">get_link_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the direction in which stem1 and stem2 are linked (by the bulge)</span>

<span class="sd">        :returns: 1 if the bulge connects stem1 with stem2 in forward direction (5&#39; to 3&#39;)</span>
<span class="sd">                  -1 otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connected_residues</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linked</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">linked</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="BulgeGraph.get_side_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_side_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">get_side_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nucleotide numbers on the given side of</span>
<span class="sd">        them stem. Side 0 corresponds to the 5&#39; end of the</span>
<span class="sd">        stem whereas as side 1 corresponds to the 3&#39; side</span>
<span class="sd">        of the stem.</span>

<span class="sd">        :param stem: The name of the stem</span>
<span class="sd">        :param side: Either 0 or 1, indicating the 5&#39; or 3&#39; end of the stem</span>
<span class="sd">        :return: A tuple of the nucleotide numbers on the given side of</span>
<span class="sd">                 the stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid side (</span><span class="si">%d</span><span class="s2">) for the stem (</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">side</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.get_stem_edge"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_stem_edge">[docs]</a>    <span class="k">def</span> <span class="nf">get_stem_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the side (strand) of the stem that position is on.</span>

<span class="sd">        Side 0 corresponds to the 5&#39; pairing residues in the</span>
<span class="sd">        stem whereas as side 1 corresponds to the 3&#39; pairing</span>
<span class="sd">        residues in the stem.</span>
<span class="sd">        :param stem: The name of the stem</span>
<span class="sd">        :param pos: A position in the stem</span>
<span class="sd">        :return: 0 if pos on 5&#39; edge of stem</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fp_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tp_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">fp_edge</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">fp_side</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">tp_side</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">tp_edge</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">tp_side</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">fp_side</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">fp_edge</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">tp_edge</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position (</span><span class="si">%d</span><span class="s2">) not in stem (</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">stem</span><span class="p">))</span></div>


<div class="viewcode-block" id="BulgeGraph.get_sides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_sides">[docs]</a>    <span class="k">def</span> <span class="nf">get_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the side of s1 that is next to b.</span>

<span class="sd">        s1e -&gt; s1b -&gt; b</span>

<span class="sd">        :param s1: The stem.</span>
<span class="sd">        :param b: The bulge.</span>
<span class="sd">        :return: A tuple indicating which side is the one next to the bulge</span>
<span class="sd">                 and which is away from the bulge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="c1"># Special case if the bulge is a length 0 multiloop</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span>
                <span class="s2">&quot;Faulty bulge </span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2"> connected to </span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s1d</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_resn_to_stem_vres_side"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_resn_to_stem_vres_side">[docs]</a>    <span class="k">def</span> <span class="nf">stem_resn_to_stem_vres_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">res</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">res</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">res</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">side</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">res</span> <span class="o">&lt;=</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">res</span> <span class="o">&gt;=</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">pos</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">res</span>
            <span class="n">side</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Residue </span><span class="si">{}</span><span class="s2"> not in stem </span><span class="si">{}</span><span class="s2"> with define </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pos</span><span class="p">,</span> <span class="n">side</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_side_vres_to_resn"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_side_vres_to_resn">[docs]</a>    <span class="k">def</span> <span class="nf">stem_side_vres_to_resn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">vres</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the residue number given the stem name, the strand (side) it&#39;s on</span>
<span class="sd">        and the virtual residue number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vres</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">vres</span></div>

<div class="viewcode-block" id="BulgeGraph.hloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.hloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">hloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the hairpin in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.mloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.mloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">mloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the multiloops in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.iloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.iloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">iloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the interior loops in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.floop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.floop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">floop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the name of the 5&#39; prime unpaired region if it is</span>
<span class="sd">        present in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.tloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.tloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">tloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the name of the 3&#39; prime unpaired region if it is</span>
<span class="sd">        present in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.get_define_seq_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_define_seq_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_define_seq_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list containing the sequences for the given define.</span>

<span class="sd">        :param d: The element name for which to get the sequences</span>
<span class="sd">        :param adjacent: Boolean. Include adjacent nucleotides (for single stranded RNA only)</span>
<span class="sd">        :return: A list containing the sequence(s) corresponding to the defines</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
            <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
        <span class="n">seqs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">define</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">define</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>
            <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;i&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">adjacent</span><span class="p">:</span>
                <span class="n">def_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">def_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seqs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seqs</span></div>

<div class="viewcode-block" id="BulgeGraph.get_multiloop_side"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_multiloop_side">[docs]</a>    <span class="k">def</span> <span class="nf">get_multiloop_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find out which strand a multiloop is on. An example of a situation in</span>
<span class="sd">        which the loop can be on both sides can be seen in the three-stemmed</span>
<span class="sd">        structure below:</span>

<span class="sd">            (.().().)</span>

<span class="sd">        In this case, the first multiloop section comes off of the 5&#39; strand of</span>
<span class="sd">        the first stem (the prior stem is always the one with a lower numbered</span>
<span class="sd">        first residue). The second multiloop section comess of the 3&#39; strand of</span>
<span class="sd">        the second stem and the third loop comes off the 3&#39; strand of the third</span>
<span class="sd">        stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sides_plus</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sides_plus</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

    <span class="c1"># This function seems to be unused here. This code is possible duplicated somewhere.</span>
    <span class="c1"># Requires cleanup.</span>
<div class="viewcode-block" id="BulgeGraph.get_strand"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_strand">[docs]</a>    <span class="k">def</span> <span class="nf">get_strand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiloop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the strand on which this multiloop is located.</span>

<span class="sd">        :param multiloop: The name of the multiloop</span>
<span class="sd">        :return: 0 for being on the lower numbered strand and 1 for</span>
<span class="sd">                 being on the higher numbered strand.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">multiloop</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">multiloop</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="BulgeGraph.get_flanking_region"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_flanking_region">[docs]</a>    <span class="k">def</span> <span class="nf">get_flanking_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If a bulge is flanked by stems, return the lowest residue number</span>
<span class="sd">        of the previous stem and the highest residue number of the next</span>
<span class="sd">        stem.</span>

<span class="sd">        :param bulge_name: The name of the bulge</span>
<span class="sd">        :param side: The side of the bulge (indicating the strand)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># interior loop</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multiloop_side</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]</span>

            <span class="n">ends</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># go through the two sides and stems and pick</span>
            <span class="c1"># the other end of the same strand</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ss</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s2">&quot;Weird multiloop sides: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                              <span class="n">bulge_name</span><span class="p">)</span>

            <span class="n">ends</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ends</span><span class="p">)</span>
            <span class="c1"># multiloop</span>

        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.get_flanking_sequence"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_flanking_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">get_flanking_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sequence of a bulge and the adjacent strand of the adjacent stems.</span>

<span class="sd">        :param bulge_name: The name of the bulge, e.g. &#39;h0&#39;</span>
<span class="sd">        :param side: Used for interior loops: The strand of interest (0=forward, 1=backward)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;No sequence present in the bulge_graph: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_flanking_region</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">m1</span><span class="p">:</span><span class="n">m2</span><span class="p">]</span>  <span class="c1"># 1 based indexing</span></div>

<div class="viewcode-block" id="BulgeGraph.get_flanking_handles"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_flanking_handles">[docs]</a>    <span class="k">def</span> <span class="nf">get_flanking_handles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the indices of the residues for fitting bulge regions.</span>

<span class="sd">        So if there is a loop like so (between residues 7 and 16)::</span>

<span class="sd">          (((...))))</span>
<span class="sd">          7890123456</span>
<span class="sd">            ^   ^</span>

<span class="sd">        Then residues 9 and 13 will be used as the handles against which</span>
<span class="sd">        to align the fitted region.</span>

<span class="sd">        In the fitted region, the residues (2,6) will be the ones that will</span>
<span class="sd">        be aligned to the handles.</span>

<span class="sd">        :return: (orig_chain_res1, orig_chain_res1, flanking_res1, flanking_res2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_flanking_region</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multiloop_side</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">s2</span><span class="p">[</span><span class="n">sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
            <span class="n">ab</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># probably still have to include the 5&#39; and 3&#39; regions, but that</span>
        <span class="c1"># will come a little later</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.are_adjacent_stems"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.are_adjacent_stems">[docs]</a>    <span class="k">def</span> <span class="nf">are_adjacent_stems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">multiloops_count</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Are two stems separated by only one element. If multiloops should not</span>
<span class="sd">        count as edges, then the appropriate parameter should be set.</span>

<span class="sd">        :param s1: The name of the first stem</span>
<span class="sd">        :param s2: The name of the second stem</span>
<span class="sd">        :param multiloops_count: Whether to count multiloops as an edge linking</span>
<span class="sd">                                 two stems</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">multiloops_count</span> <span class="ow">and</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BulgeGraph.random_subgraph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.random_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">random_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subgraph_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random subgraph of this graph.</span>

<span class="sd">        :return: A list containing a the nodes comprising a random subgraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subgraph_length</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subgraph_length</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">))</span>

        <span class="n">start_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">))</span>
        <span class="n">curr_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">next_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_node</span><span class="p">]</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">curr_length</span> <span class="o">&lt;</span> <span class="n">subgraph_length</span><span class="p">:</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">next_nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span> <span class="ow">or</span> <span class="n">curr_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="c1"># if it&#39;s an interior loop or a multiloop, then we have to</span>
                <span class="c1"># add the adjacent stems</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">new_graph</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">next_nodes</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
                    <span class="n">curr_length</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
            <span class="n">next_nodes</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">curr_node</span><span class="p">])</span>
            <span class="n">next_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">next_nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">]</span>
            <span class="n">new_graph</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_node</span><span class="p">]</span>
            <span class="n">curr_length</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># self.element_length(curr_node)</span>

        <span class="k">return</span> <span class="n">new_graph</span></div>

<div class="viewcode-block" id="BulgeGraph.get_resseqs"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_resseqs">[docs]</a>    <span class="k">def</span> <span class="nf">get_resseqs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the pdb ids of the nucleotides in this define.</span>

<span class="sd">        :param define: The name of this element.</span>
<span class="sd">        :param: Return a tuple of two arrays containing the residue ids</span>
<span class="sd">                on each strand</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#raise NotImplementedError(&quot;Removed. Use define_residue_num_iterator instead!&quot;)</span>
        <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">define</span><span class="p">])]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">strand_resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seq_ids</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">res_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_resid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">log_to_exception</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Index </span><span class="si">%s</span><span class="s2"> not in seq_ids.&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                        <span class="k">raise</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;chain&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">res_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span>
                    <span class="n">strand_resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_id</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">strand_resnames</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

            <span class="n">resnames</span> <span class="o">+=</span> <span class="p">[</span><span class="n">strand_resnames</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">resnames</span></div>

    <span class="k">def</span> <span class="nf">_insert_cutpoints_into_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">breakpoint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Inserting breakpoint into seq &#39;</span><span class="si">%s</span><span class="s2">&#39;&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">subseq_with_cutpoints</span><span class="p">(</span>
                    <span class="mi">1</span><span class="p">,</span> <span class="n">breakpoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;&amp;&quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">subseq_with_cutpoints</span><span class="p">(</span><span class="n">breakpoint</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;seq now has </span><span class="si">%s</span><span class="s2"> cutpoints&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">))</span>

    <span class="c1"># This function seems to be dead code, but might be useful in the future.</span>
    <span class="c1"># Consider adding this to whitelist.py</span>
<div class="viewcode-block" id="BulgeGraph.connected_stem_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.connected_stem_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">connected_stem_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all pairs of connected stems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloop_iterator</span><span class="p">()):</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">edge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.sorted_edges_for_mst"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.sorted_edges_for_mst">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_edges_for_mst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep track of all linked nodes. Used for the generation of the minimal spanning tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">priority</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">(),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">iloop_iterator</span><span class="p">()),</span>
                       <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">priority</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_dimensions</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span> <span class="n">x</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">edges</span></div>

<div class="viewcode-block" id="BulgeGraph.get_mst"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_mst">[docs]</a>    <span class="k">def</span> <span class="nf">get_mst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a minimum spanning tree from this BulgeGraph. This is useful</span>
<span class="sd">        for constructing a structure where each section of a multiloop is</span>
<span class="sd">        sampled independently and we want to introduce a break at the largest</span>
<span class="sd">        multiloop section.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># keep track of all linked nodes</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_edges_for_mst</span><span class="p">()</span>

        <span class="n">mst</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">floop_iterator</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">tloop_iterator</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">hloop_iterator</span><span class="p">()))</span>

        <span class="c1"># store all of the disconnected trees</span>
        <span class="n">forest</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">([</span><span class="n">m</span><span class="p">])</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mst</span><span class="p">]</span>

        <span class="c1"># get the tree containing a particular element</span>
        <span class="k">def</span> <span class="nf">get_tree</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">forest</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">t</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">conn</span><span class="p">])</span>

            <span class="c1"># get the trees containing the neighbors of this node</span>
            <span class="c1"># the node should be an interior loop or multiloop so</span>
            <span class="c1"># the neighbors should necessarily be stems, 5&#39; or 3&#39;</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">get_tree</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">get_tree</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if this node connects two disparate trees, then add it to the mst</span>
                <span class="n">new_tree</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
                <span class="n">forest</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                <span class="n">forest</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
                <span class="n">forest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tree</span><span class="p">)</span>

                <span class="n">mst</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mst</span></div>

<div class="viewcode-block" id="BulgeGraph.traverse_graph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.traverse_graph">[docs]</a>    <span class="k">def</span> <span class="nf">traverse_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Traverse the graph to get the angle types. The angle type depends on</span>
<span class="sd">        which corners of the stem are connected by the multiloop or internal</span>
<span class="sd">        loop.</span>

<span class="sd">        :returns: A list of triples (stem, loop, stem)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mst</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mst</span><span class="p">()</span>

        <span class="n">build_order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;s0&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">)]</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;s0&#39;</span><span class="p">])</span>
        <span class="n">build_paths</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_visit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">to_visit</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_dimensions</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span> <span class="ow">and</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mst</span><span class="p">:</span>
                    <span class="c1"># make sure the node hasn&#39;t been visited</span>
                    <span class="c1"># and is in the minimum spanning tree</span>
                    <span class="n">to_visit</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>

                    <span class="n">build_paths</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">build_paths</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+=</span> <span class="n">build_paths</span><span class="p">[</span><span class="n">current</span><span class="p">]</span>

                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># multiloop or interior loop</span>

                <span class="c1"># overkill method of getting the stem that isn&#39;t</span>
                <span class="c1"># equal to prev</span>
                <span class="n">next_stem</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">],</span>
                                           <span class="nb">set</span><span class="p">([</span><span class="n">prev</span><span class="p">]))</span>
                <span class="n">build_order</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">prev</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">next_stem</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="o">=</span> <span class="n">build_order</span>

        <span class="k">return</span> <span class="n">build_order</span></div>

<div class="viewcode-block" id="BulgeGraph.set_angle_types"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.set_angle_types">[docs]</a>    <span class="k">def</span> <span class="nf">set_angle_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill in the angle types based on the build order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.get_angle_type"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_angle_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_angle_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">,</span> <span class="n">allow_broken</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return what type of angle this bulge is, based on the way this</span>
<span class="sd">        would be built using a breadth-first traversal along the minimum</span>
<span class="sd">        spanning tree.</span>

<span class="sd">        :param allow_broken: How to treat broken multiloop segments.</span>

<span class="sd">                             * False (default): Return None</span>
<span class="sd">                             * True: Return the angle type according to the build-order</span>
<span class="sd">                               (i.e. from the first built stem to the last-built stem)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_angle_types</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">bulge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span><span class="p">[</span><span class="n">bulge</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_broken</span><span class="p">:</span>
                <span class="n">stems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge</span><span class="p">)</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">stems</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">buildorder_of</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.buildorder_of"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.buildorder_of">[docs]</a>    <span class="k">def</span> <span class="nf">buildorder_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index into build_order where the element FIRST appears.</span>

<span class="sd">        :param element: Element name, a string. e.g. &quot;m0&quot; or &quot;s0&quot;</span>
<span class="sd">        :returns: An index into self.build_order or None, if the element is not</span>
<span class="sd">                  part of the build_order (e.g. hairpin loops)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elements</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">build_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.is_loop_pseudoknot"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.is_loop_pseudoknot">[docs]</a>    <span class="k">def</span> <span class="nf">is_loop_pseudoknot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is a particular loop a pseudoknot?</span>

<span class="sd">        :param loop: A list of elements that are part of the loop (only m,f and t elements).</span>

<span class="sd">        :return: Either True or false</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;pseudoknot&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">describe_multiloop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.iter_elements_along_backbone"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.iter_elements_along_backbone">[docs]</a>    <span class="k">def</span> <span class="nf">iter_elements_along_backbone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startpos</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate all coarse grained elements along the backbone.</span>

<span class="sd">        Note that stems are yielded twice (for forward and backward strand).</span>
<span class="sd">        Interior loops may be yielded twice or once (if one side has no nucleotide)</span>

<span class="sd">        0-length multiloop-segments are correctly yielded.</span>

<span class="sd">        :param startpos: The nucleotide position at which to start</span>
<span class="sd">        :yields: Coarse grained element names, like &quot;s0&quot;, &quot;i0&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nuc</span> <span class="o">=</span> <span class="n">startpos</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">nuc</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;Empty Graph&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Yielding node </span><span class="si">%s</span><span class="s2"> with edges </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;si&quot;</span><span class="p">:</span>  <span class="c1"># The strand matters</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;s&quot;</span><span class="p">:</span>
                    <span class="n">strand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stem_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nuc</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># forward</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nuc_at_stem_side</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nuc_at_stem_side</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span><span class="p">,</span> <span class="n">f4</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">f1</span> <span class="o">&lt;</span> <span class="n">nuc</span> <span class="o">&lt;</span> <span class="n">f2</span><span class="p">:</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="n">f2</span>
                    <span class="k">elif</span> <span class="n">f3</span> <span class="o">&lt;</span> <span class="n">nuc</span> <span class="o">&lt;</span> <span class="n">f4</span><span class="p">:</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="n">f4</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">next_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">nuc</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;End of chain reached&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># We need to make sure there is no 0-length multiloop between the two stems.</span>
                    <span class="n">intersect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">intersect</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;ML </span><span class="si">%s</span><span class="s2"> between </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">el</span><span class="p">,</span>
                                      <span class="n">node</span><span class="p">,</span> <span class="n">next_node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
                    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">intersect</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
                            <span class="c1"># In case of this structuire ([)], there are 2 0-length multiloops between the two stems.</span>
                            <span class="n">prev_nuc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;prev_nuc = </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prev_nuc</span><span class="p">)</span>
                            <span class="k">if</span> <span class="n">nuc</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">prev_nuc</span><span class="p">:</span>
                                <span class="n">node</span> <span class="o">=</span> <span class="n">el</span>
                                <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>  <span class="c1"># Too few values to unpack</span>
                    <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;Single stranded-only RNA&quot;</span><span class="p">)</span>
                        <span class="n">nuc</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;End of chain reached&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">f1</span> <span class="o">&gt;</span> <span class="n">f2</span><span class="p">:</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="n">f1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="n">f2</span>
                <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">nuc</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Next nuc is </span><span class="si">%s</span><span class="s2"> (</span><span class="si">%s</span><span class="s2">), node is </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">nuc</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">nuc</span><span class="p">),</span> <span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.pseudoknotted_basepairs"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.pseudoknotted_basepairs">[docs]</a>    <span class="k">def</span> <span class="nf">pseudoknotted_basepairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ignore_basepairs</span><span class="o">=</span><span class="p">()):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of base-pairs that will be removed to</span>
<span class="sd">        remove pseudoknots using the knotted2nested.py script.</span>

<span class="sd">        :param ignore_basepairs: An optional list of basepairs that</span>
<span class="sd">                                 knested2knotted will not consider present</span>
<span class="sd">                                 in the structure.</span>
<span class="sd">        :return: A list of base-pairs that can be removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># remove unpaired bases and redundant pairs (i.e. (2,3) and (3,2))</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
                        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_tuples</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">pairs</span><span class="p">)</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pairs</span> <span class="k">if</span> <span class="n">p</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore_basepairs</span>
                 <span class="ow">and</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ignore_basepairs</span><span class="p">)]</span>

        <span class="kn">import</span> <span class="nn">forgi._k2n_standalone.knots</span> <span class="k">as</span> <span class="nn">fakk</span>

        <span class="n">pk_function</span> <span class="o">=</span> <span class="n">fakk</span><span class="o">.</span><span class="n">eg</span>
        <span class="n">nested_pairs</span><span class="p">,</span> <span class="n">removed_pairs</span> <span class="o">=</span> <span class="n">pk_function</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">return_removed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">removed_pairs</span></div>

<div class="viewcode-block" id="BulgeGraph.ss_distance"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.ss_distance">[docs]</a>    <span class="k">def</span> <span class="nf">ss_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the distance between two elements (e1, e2)</span>
<span class="sd">        along the secondary structure. The distance only starts</span>
<span class="sd">        at the edge of each element, and is the closest distance</span>
<span class="sd">        between the two elements.</span>

<span class="sd">        :param e1: The name or nucleotide number of the first element</span>
<span class="sd">        :param e2: The name or nucleotide number of the second element</span>
<span class="sd">        :return: The integer distance between the two elements / residues along the secondary</span>
<span class="sd">                 structure. (if a element is given, we use its corner for the distance, otherwise the exact nucleotide)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># get the edge nucleotides</span>
        <span class="c1"># thanks to:</span>
        <span class="c1"># http://stackoverflow.com/questions/2154249/identify-groups-of-continuous-numbers-in-a-list</span>
        <span class="c1"># we get the edges, except that they might be one too close because we use adjacent</span>
        <span class="c1"># nucleotides, nevertheless we&#39;ll take care of that later</span>
        <span class="n">d1_corners</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d2_corners</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">correction</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">d1_corners</span><span class="o">=</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">RESID</span><span class="p">):</span>
            <span class="n">d1_corners</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_integer</span><span class="p">(</span><span class="n">e1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d1_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">d1_corners</span><span class="p">:</span>
                <span class="n">d1_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">e1</span><span class="p">)</span>
                <span class="n">correction</span><span class="o">+=</span><span class="mi">1</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">d2_corners</span><span class="o">=</span><span class="p">[</span><span class="n">e2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">RESID</span><span class="p">):</span>
            <span class="n">d2_corners</span><span class="o">=</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_integer</span><span class="p">(</span><span class="n">e2</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">d2_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e2</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">d2_corners</span><span class="p">:</span>
                <span class="n">d2_corners</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">e2</span><span class="p">)</span>
                <span class="n">correction</span><span class="o">+=</span><span class="mi">1</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Corners for distance are </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">d1_corners</span><span class="p">,</span> <span class="n">d2_corners</span><span class="p">)</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
        <span class="n">path_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">d1_corners</span><span class="p">,</span> <span class="n">d2_corners</span><span class="p">):</span>
            <span class="n">path_lengths</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)]</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span><span class="o">+</span><span class="n">correction</span></div>

<div class="viewcode-block" id="BulgeGraph.define_residue_num_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.define_residue_num_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">define_residue_num_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the residue numbers that belong to this node.</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_range_iterator</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">adjacent</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seq_ids</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_resid</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_resid</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">to_resid</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">i</span></div>

<div class="viewcode-block" id="BulgeGraph.shortest_path"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.shortest_path">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determine the shortest path between two elements (e1, e2)</span>
<span class="sd">        along the secondary structure.</span>

<span class="sd">        :param e1: The name of the first element</span>
<span class="sd">        :param e2: The name of the second element</span>
<span class="sd">        :return: A list of the element names along the shortest path</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="c1"># Get residue numbers of source and targets, for shortest_path in nx</span>
        <span class="n">source</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e1</span><span class="p">)])</span>
        <span class="n">target</span> <span class="o">=</span> <span class="nb">min</span><span class="p">([</span><span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e2</span><span class="p">)])</span>

        <span class="c1"># Get nx graph, and the shortest path</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
        <span class="n">nx_sp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>

        <span class="c1"># Convert shortest path of residue numbers to a shortest path of node names</span>
        <span class="n">sp</span><span class="p">,</span> <span class="n">sp_set</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()</span>  <span class="c1"># Use set to keep track of additions for faster lookup</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">nx_sp</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
                <span class="n">sp_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># assymetric bulges with a length of 0 on 1 side are missed,</span>
        <span class="c1"># two adjacent stems indicate a bulge with length 0 along the path</span>
        <span class="n">shortest_path</span><span class="p">,</span> <span class="n">sp_set</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()</span>
        <span class="c1"># Connections are ordered compared to connected_stem_iterator()</span>
        <span class="n">traversal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span>

        <span class="c1"># Iterate through adjacent pairs of elements in the list</span>
        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="c1"># If two elements are both stems</span>
            <span class="k">if</span> <span class="n">n1</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n2</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">):</span>
                <span class="c1"># Find their connection in graph traversal</span>
                <span class="n">connection</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                    <span class="p">[</span><span class="n">conn</span> <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">traversal</span> <span class="k">if</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">conn</span> <span class="ow">and</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">conn</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="c1"># If we&#39;re moving &#39;backwards&#39; on the traversal</span>
                <span class="k">if</span> <span class="n">connection</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">connection</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">connection</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
                        <span class="n">sp_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                        <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
                    <span class="n">sp_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
                    <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
            <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span>  <span class="c1"># Append last item in path</span>

        <span class="k">return</span> <span class="n">shortest_path</span></div>

<div class="viewcode-block" id="BulgeGraph.get_position_in_element"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_position_in_element">[docs]</a>    <span class="k">def</span> <span class="nf">get_position_in_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resnum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position of the residue in the cg-element and the length of the element.</span>

<span class="sd">        :param resnum: An integer. The 1-based position in the total sequence.</span>
<span class="sd">        :returns: A tuple (p,l) where p is the position of the residue in the cg-element</span>
<span class="sd">                  (0-based for stems, 1-based for loops) and p/l gives a measure for the position</span>
<span class="sd">                  of the residue along the cg-element&#39;s axis (0 means at cg.coords[elem][0],</span>
<span class="sd">                  1 at cg.coords[elem][1] and 0.5 exactely in the middle of these two. )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">resnum</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">resnum</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">3</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="n">s0</span><span class="p">,</span> <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">resnum</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">pos1</span> <span class="o">=</span> <span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pos2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">resnum</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">resnum</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">2</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.connected"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.connected">[docs]</a>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Are the nucleotides n1 and n2 connected?</span>

<span class="sd">        :param n1: A node in the BulgeGraph</span>
<span class="sd">        :param n2: Another node in the BulgeGraph</span>
<span class="sd">        :return: True or False indicating whether they are connected.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">n1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">n2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># two multiloops can be considered connected if they both</span>
        <span class="c1"># link to the same side of the same stem</span>
        <span class="k">if</span> <span class="n">n1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">and</span> <span class="n">n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">common_stems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_stems</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">common_stem</span> <span class="o">=</span> <span class="n">common_stems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">b1c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sides_plus</span><span class="p">(</span><span class="n">common_stem</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s2c</span><span class="p">,</span> <span class="n">b1c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_sides_plus</span><span class="p">(</span><span class="n">common_stem</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BulgeGraph.min_max_bp_distance"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.min_max_bp_distance">[docs]</a>    <span class="k">def</span> <span class="nf">min_max_bp_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the minimum and maximum base pair distance between</span>
<span class="sd">        these two elements.</span>

<span class="sd">        If they are connected, the minimum distance will be 1.</span>
<span class="sd">        The maximum will be 1 + length(e1) + length(e1)</span>

<span class="sd">        :param e1: The name of the first element</span>
<span class="sd">        :param e2: The name of the second element</span>
<span class="sd">        :return:   A tuple containing the minimum and maximum distance between</span>
<span class="sd">                   the two elements.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">:</span>  <span class="c1"># Shortcut if cached.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">[(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)]</span>

        <span class="n">min_bp</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
        <span class="n">max_bp</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span>
                <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># col.defaultdict(dict)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">floyd_warshall_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span><span class="p">))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">n1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span>
                                                 <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e1</span><span class="p">]),</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e2</span><span class="p">])):</span>
            <span class="c1">#d =  nx.dijkstra_path_length(self.nx_graph, f1, f2)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">min_bp</span><span class="p">:</span>
                <span class="n">min_bp</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">max_bp</span><span class="p">:</span>
                <span class="n">max_bp</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">[(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_bp</span><span class="p">,</span> <span class="n">max_bp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">[(</span><span class="n">e2</span><span class="p">,</span> <span class="n">e1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_bp</span><span class="p">,</span> <span class="n">max_bp</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">min_bp</span><span class="p">,</span> <span class="n">max_bp</span><span class="p">)</span></div></div>

<span class="c1"># Free functions</span>


<div class="viewcode-block" id="print_brackets"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.print_brackets">[docs]</a><span class="k">def</span> <span class="nf">print_brackets</span><span class="p">(</span><span class="n">brackets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print the brackets and a numbering, for debugging purposes</span>

<span class="sd">    :param brackets: A string with the dotplot passed as input to this script.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">))]</span>
    <span class="n">tens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">))]</span>
    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;brackets:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">brackets</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span>
           <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tens</span><span class="p">),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span></div>


<span class="k">def</span> <span class="nf">_seq_of_Ns_from_db</span><span class="p">(</span><span class="n">dotbracket</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Get a sequence containing only &#39;N&#39;-characters with the same length and</span>
<span class="sd">    the same position of cutpoints as the dotbracketstring.</span>

<span class="sd">    :param dotbracket: A string, optionally containing &#39;&amp;&#39; to indicate</span>
<span class="sd">                       seperate cofolded structures.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">substr</span> <span class="ow">in</span> <span class="n">dotbracket</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">):</span>
        <span class="n">seq</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;N&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">substr</span><span class="p">))</span>
    <span class="k">return</span> <span class="s2">&quot;&amp;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_cleaned_bg</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new BulgeGraph with a cleaned secondary structure</span>
<span class="sd">    or a reference to the original BulgeGraph.</span>

<span class="sd">    This function performs the cleaning operations requested by the flags</span>
<span class="sd">    dissolve_length_one_stems and remove_pseudoknots.</span>

<span class="sd">    :param dissolve_length_one_stems: If true, all stems with only a single</span>
<span class="sd">                                      basepair are removed from the structure.</span>
<span class="sd">    :param remove_pseudoknots: If true, nested2knotted is used to generate a</span>
<span class="sd">                               pseudoknot-free structure by removing</span>
<span class="sd">                               conflicting basepairs.</span>
<span class="sd">    :returns: A modified copy of or a reference to the original BulgeGraph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cleaning BG with type </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
    <span class="n">bps_to_remove</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">dissolve_length_one_stems</span><span class="p">:</span>
        <span class="n">bps_to_remove</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">length_one_stem_basepairs</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">remove_pseudoknots</span><span class="p">:</span>
        <span class="n">bps_to_remove</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">pseudoknotted_basepairs</span><span class="p">(</span>
            <span class="n">ignore_basepairs</span><span class="o">=</span><span class="n">bps_to_remove</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">bps_to_remove</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Recreating without the following &quot;</span>
                 <span class="s2">&quot;basepairs: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bps_to_remove</span><span class="p">)</span>
        <span class="n">new_tuples</span> <span class="o">=</span> <span class="n">bg</span><span class="o">.</span><span class="n">to_pair_tuples</span><span class="p">(</span><span class="n">bps_to_remove</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">_BulgeGraphConstruction</span><span class="p">(</span><span class="n">new_tuples</span><span class="p">)</span>
        <span class="c1"># Create and init new object with only the Structure changed.</span>
        <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">bg</span><span class="p">)(</span><span class="n">c</span><span class="p">,</span> <span class="n">bg</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="n">bg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">bg</span><span class="o">.</span><span class="n">infos</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Cleaning bg is no-op, returning bg with defines </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bg</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bg</span>
</pre></div>

      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016 Peter Kerpedjiev &lt;pkerp@tbi.univie.ac.at&gt;; 2015-2018 Bernhard Thiel &lt;thiel@tbi.univie.ac.at&gt;.
      Last updated on Feb 25, 2019.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>