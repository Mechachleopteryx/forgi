

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>forgi.graph.bulge_graph &#8212; forgi 1.1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../../index.html">
          <span>forgi 1.1.0 documentation</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for forgi.graph.bulge_graph</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">chr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">hex</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span>
                      <span class="nb">map</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span> <span class="nb">oct</span><span class="p">,</span> <span class="nb">pow</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">round</span><span class="p">,</span>
                      <span class="nb">str</span><span class="p">,</span> <span class="nb">super</span><span class="p">,</span> <span class="nb">zip</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;bulge_graph.py: A graph representation of RNA secondary structure based</span>
<span class="sd">   on its decomposition into primitive structure types: stems, hairpins,</span>
<span class="sd">   interior loops, multiloops, etc...&quot;&quot;&quot;</span>


<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">collections</span> <span class="k">as</span> <span class="nn">col</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">debug</span> <span class="k">as</span> <span class="n">fud</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">stuff</span> <span class="k">as</span> <span class="n">fus</span>
<span class="kn">from</span> <span class="nn">..utilities.exceptions</span> <span class="k">import</span> <span class="n">GraphConstructionError</span><span class="p">,</span> <span class="n">GraphIntegrityError</span>
<span class="kn">from</span> <span class="nn">..threedee.utilities</span> <span class="k">import</span> <span class="n">mcannotate</span> <span class="k">as</span> <span class="n">ftum</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">operator</span> <span class="k">as</span> <span class="nn">oper</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">functools</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">from</span> <span class="nn">string</span> <span class="k">import</span> <span class="n">ascii_lowercase</span><span class="p">,</span> <span class="n">ascii_uppercase</span>
<span class="n">VALID_CHAINIDS</span> <span class="o">=</span> <span class="n">ascii_uppercase</span><span class="o">+</span><span class="n">ascii_lowercase</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pprint</span><span class="p">,</span> <span class="n">pformat</span>

<span class="kn">from</span> <span class="nn">logging_exceptions</span> <span class="k">import</span> <span class="n">log_to_exception</span><span class="p">,</span> <span class="n">log_at_caller</span>

<span class="kn">from</span> <span class="nn">.residue</span> <span class="k">import</span> <span class="n">RESID</span><span class="p">,</span> <span class="n">resid_to_str</span><span class="p">,</span> <span class="n">resid_from_str</span>

<span class="k">try</span><span class="p">:</span>
  <span class="n">profile</span>  <span class="c1">#The @profile decorator from line_profiler (kernprof)</span>
<span class="k">except</span><span class="p">:</span>
<div class="viewcode-block" id="profile"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.profile">[docs]</a>  <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span></div>



<div class="viewcode-block" id="add_bulge"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.add_bulge">[docs]</a><span class="k">def</span> <span class="nf">add_bulge</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="n">bulge</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper for a simple dictionary addition</span>
<span class="sd">    Added so that debugging can be made easier</span>

<span class="sd">    :param bulges:</span>
<span class="sd">    :param bulge:</span>
<span class="sd">    :param context:</span>
<span class="sd">    :param message:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># bulge = (context, bulge)</span>
    <span class="n">bulges</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulges</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span><span class="n">bulge</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">bulges</span></div>


<div class="viewcode-block" id="from_id_seq_struct"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.from_id_seq_struct">[docs]</a><span class="k">def</span> <span class="nf">from_id_seq_struct</span><span class="p">(</span><span class="n">id_str</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">struct</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new BulgeGraph with the given id,</span>
<span class="sd">    sequence and structure.</span>

<span class="sd">    :param id_str: The id (i.e. &gt;1y26)</span>
<span class="sd">    :param seq: the sequence (i.e. &#39;ACCGGG&#39;)</span>
<span class="sd">    :param struct: The dotplot secondary structure (i.e. &#39;((..))&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">seq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">struct</span><span class="p">):</span>
        <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Sequence and structure length are not equal for id </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">id_str</span><span class="p">))</span>
    <span class="n">bg</span> <span class="o">=</span> <span class="n">BulgeGraph</span><span class="p">()</span>
    <span class="n">bg</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">id_str</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bg</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">id_str</span>
    <span class="k">if</span> <span class="n">seq</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">bg</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span>
    <span class="n">bg</span><span class="o">.</span><span class="n">seq_ids_from_seq</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">bg</span></div>


<div class="viewcode-block" id="from_fasta_text"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.from_fasta_text">[docs]</a><span class="k">def</span> <span class="nf">from_fasta_text</span><span class="p">(</span><span class="n">fasta_text</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a bulge graph or multiple bulge</span>
<span class="sd">    graphs from some fasta text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compile searches for the fasta id, sequence and</span>
    <span class="c1"># secondary structure respectively</span>
    <span class="n">id_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&gt;(.+)&#39;</span><span class="p">)</span>
    <span class="n">seq_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^([acgutACGUT&amp;]+)$&#39;</span><span class="p">)</span>
    <span class="n">stru_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^([()</span><span class="si">{}</span><span class="s1">&lt;&gt;.A-Za-z&amp;\[\]]+)$&#39;</span><span class="p">)</span>

    <span class="n">prev_id</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">prev_seq</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">prev_struct</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">curr_id</span><span class="o">=</span><span class="kc">None</span>

    <span class="n">bgs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fasta_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)):</span>
        <span class="c1"># newlines suck</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="c1"># We allow comments</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">):</span>
            <span class="k">continue</span>
        <span class="c1"># find out what this line contains</span>
        <span class="n">id_match</span> <span class="o">=</span> <span class="n">id_search</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">seq_match</span> <span class="o">=</span> <span class="n">seq_search</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">stru_match</span> <span class="o">=</span> <span class="n">stru_search</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">id_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">prev_id</span><span class="o">=</span><span class="n">curr_id</span>
            <span class="c1"># we found an id, check if there&#39;s a previous</span>
            <span class="c1"># sequence and structure, and create a BG</span>
            <span class="n">curr_id</span> <span class="o">=</span> <span class="n">id_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">prev_seq</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">prev_struct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># must be the first sequence/structure</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">prev_struct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;No structure for id: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">prev_id</span><span class="p">)</span>

            <span class="n">bg</span> <span class="o">=</span> <span class="n">from_id_seq_struct</span><span class="p">(</span><span class="n">prev_id</span><span class="p">,</span> <span class="n">prev_seq</span><span class="p">,</span> <span class="n">prev_struct</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dissolve_length_one_stems</span><span class="p">:</span>
                <span class="n">bg</span><span class="o">.</span><span class="n">dissolve_length_one_stems</span><span class="p">()</span>
            <span class="n">bgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span>

            <span class="n">prev_seq</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">prev_struct</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">prev_id</span><span class="o">=</span><span class="kc">None</span>

        <span class="k">if</span> <span class="n">seq_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_seq</span> <span class="o">=</span> <span class="n">seq_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;t&quot;</span> <span class="ow">in</span> <span class="n">curr_seq</span> <span class="ow">or</span> <span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">curr_seq</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Original sequence contained T. All occurrences of T/t were replaced by U/u respectively!&quot;</span><span class="p">)</span>
                <span class="n">curr_seq</span><span class="o">=</span><span class="n">curr_seq</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="s2">&quot;U&quot;</span><span class="p">)</span>
                <span class="n">curr_seq</span><span class="o">=</span><span class="n">curr_seq</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;u&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prev_seq</span><span class="p">:</span>
                <span class="n">prev_seq</span><span class="o">+=</span><span class="n">curr_seq</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev_seq</span><span class="o">=</span><span class="n">curr_seq</span>

        <span class="k">if</span> <span class="n">id_match</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">seq_match</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">stru_match</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">prev_struct</span><span class="p">:</span>
                    <span class="n">prev_struct</span> <span class="o">+=</span> <span class="n">line</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev_struct</span> <span class="o">=</span> <span class="n">line</span>
            <span class="k">elif</span> <span class="n">line</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Cannot parse line </span><span class="si">{}</span><span class="s2">: &#39;</span><span class="si">{}</span><span class="s2">&#39; is neither sequence, nor structure, nor name (starting with &#39;&gt;&#39;), nor comment (starting with &#39;#&#39;).&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">line</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">prev_struct</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Error during parsing of fasta file. No structure found for id </span><span class="si">{}</span><span class="s2"> and sequence </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">prev_id</span><span class="p">,</span> <span class="n">prev_seq</span><span class="p">))</span>

    <span class="n">bg</span> <span class="o">=</span> <span class="n">from_id_seq_struct</span><span class="p">(</span><span class="n">curr_id</span><span class="p">,</span> <span class="n">prev_seq</span><span class="p">,</span> <span class="n">prev_struct</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">dissolve_length_one_stems</span><span class="p">:</span>
        <span class="n">bg</span><span class="o">.</span><span class="n">dissolve_length_one_stems</span><span class="p">()</span>
    <span class="n">bgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bg</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bgs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bgs</span></div>

<div class="viewcode-block" id="from_fasta"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.from_fasta">[docs]</a><span class="k">def</span> <span class="nf">from_fasta</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">fasta_text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">from_fasta_text</span><span class="p">(</span><span class="n">fasta_text</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="p">)</span></div>

<div class="viewcode-block" id="any_difference_of_one"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.any_difference_of_one">[docs]</a><span class="k">def</span> <span class="nf">any_difference_of_one</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See if there&#39;s any difference of one between the two</span>
<span class="sd">    ends of the stem [(a,b),(c,d)] and a bulge (e,f)</span>

<span class="sd">    :param stem: A couple of couples (2 x 2-tuple) indicating the start and end</span>
<span class="sd">                 nucleotides of the stem in the form ((s1, e1), (s2, e2))</span>
<span class="sd">    :param bulge: A couple (2-tuple) indicating the first and last position</span>
<span class="sd">                  of the bulge.</span>
<span class="sd">    :return: True if there is an overlap between the stem nucleotides and the</span>
<span class="sd">                  bulge nucleotides. False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">stem_part</span> <span class="ow">in</span> <span class="n">stem</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">stem_part</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bulge_part</span> <span class="ow">in</span> <span class="n">bulge</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bulge_part</span> <span class="o">-</span> <span class="n">part</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="kc">True</span>
    <span class="k">return</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="print_bulges"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.print_bulges">[docs]</a><span class="k">def</span> <span class="nf">print_bulges</span><span class="p">(</span><span class="n">bulges</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print the names and definitions of the bulges.</span>

<span class="sd">    :param bulges: A list of tuples of the form [(s, e)] where s and e are the</span>
<span class="sd">                   numbers of the nucleotides at the start and end of the bulge.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulges</span><span class="p">)):</span>
        <span class="c1"># print &quot;bulge:&quot;, bulge</span>
        <span class="n">bulge_str</span> <span class="o">=</span> <span class="s2">&quot;define b</span><span class="si">{}</span><span class="s2"> 1&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">bulge</span> <span class="o">=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">bulge_str</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="nb">print</span> <span class="p">(</span><span class="n">bulge_str</span><span class="p">)</span></div>


<div class="viewcode-block" id="condense_stem_pairs"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.condense_stem_pairs">[docs]</a><span class="k">def</span> <span class="nf">condense_stem_pairs</span><span class="p">(</span><span class="n">stem_pairs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of stem pairs, condense them into stem definitions</span>

<span class="sd">    I.e. the pairs (0,10),(1,9),(2,8),(3,7) can be condensed into</span>
<span class="sd">    just the ends of the stem: [(0,10),(3,7)]</span>

<span class="sd">    :param stem_pairs: A list of tuples containing paired base numbers.</span>

<span class="sd">    :returns: A list of tuples of tuples of the form [((s1, e1), (s2, e2))]</span>
<span class="sd">                  where s1 and e1 are the nucleotides at one end of the stem</span>
<span class="sd">                  and s2 and e2 are the nucleotides at the other.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stem_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="n">prev_pair</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span>

    <span class="n">stems</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start_pair</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">stem_pairs</span><span class="p">:</span>
        <span class="c1"># There&#39;s a potential bug here since we don&#39;t check the direction</span>
        <span class="c1"># but hopefully it won&#39;t bite us in the ass later</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">prev_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prev_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start_pair</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">stems</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">start_pair</span><span class="p">,</span> <span class="n">prev_pair</span><span class="p">)]</span>
            <span class="n">start_pair</span> <span class="o">=</span> <span class="n">pair</span>

        <span class="n">prev_pair</span> <span class="o">=</span> <span class="n">pair</span>

    <span class="k">if</span> <span class="n">start_pair</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">stems</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">start_pair</span><span class="p">,</span> <span class="n">prev_pair</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">stems</span></div>


<div class="viewcode-block" id="print_brackets"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.print_brackets">[docs]</a><span class="k">def</span> <span class="nf">print_brackets</span><span class="p">(</span><span class="n">brackets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print the brackets and a numbering, for debugging purposes</span>

<span class="sd">    :param brackets: A string with the dotplot passed as input to this script.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">))]</span>
    <span class="n">tens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">))]</span>
    <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;brackets:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">brackets</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tens</span><span class="p">),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span></div>

<span class="c1"># @Coverage: Seems to be unused. If this is removed, condense_stem_pairs can be removed as well.</span>
<div class="viewcode-block" id="find_bulges_and_stems"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.find_bulges_and_stems">[docs]</a><span class="k">def</span> <span class="nf">find_bulges_and_stems</span><span class="p">(</span><span class="n">brackets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterate through the structure and enumerate the bulges and the stems that are</span>
<span class="sd">    present.</span>

<span class="sd">    The returned stems are of the form [[(s1, s2), (e1,e2)], [(s1,s2),(e1,e2)],...]</span>
<span class="sd">    where (s1,s2) are the residue numbers of one end of the stem and (e1,e2) are the</span>
<span class="sd">    residue numbers at the other end of the stem</span>
<span class="sd">    (see condense_stem_pairs)</span>

<span class="sd">    The returned bulges are of the form [(s,e), (s,e),...] where s is the start of a bulge</span>
<span class="sd">    and e is the end of a bulge</span>

<span class="sd">    :param brackets: A string with the dotbracket passed as input to this script.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
    <span class="n">context</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">bulges</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">finished_bulges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">context_depths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">opens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stem_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">dots_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">context_depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">opens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
                <span class="n">context_depths</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="n">context_depths</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">context_depths</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                <span class="n">dots_end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">bulges</span> <span class="o">=</span> <span class="n">add_bulge</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="p">(</span><span class="n">dots_start</span><span class="p">,</span> <span class="n">dots_end</span><span class="p">),</span> <span class="n">context</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unmatched close bracket&quot;</span><span class="p">)</span>

            <span class="n">stem_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">opens</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">i</span><span class="p">))</span>

            <span class="n">context_depths</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">context_depths</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">bulges</span><span class="p">:</span>
                    <span class="n">finished_bulges</span> <span class="o">+=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">context</span><span class="p">]</span>
                <span class="n">bulges</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">context</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                <span class="n">dots_end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">bulges</span> <span class="o">=</span> <span class="n">add_bulge</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="p">(</span><span class="n">dots_start</span><span class="p">,</span> <span class="n">dots_end</span><span class="p">),</span> <span class="n">context</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">dots_start</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">prev</span> <span class="o">=</span> <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
        <span class="n">dots_end</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">bulges</span> <span class="o">=</span> <span class="n">add_bulge</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="p">(</span><span class="n">dots_start</span><span class="p">,</span> <span class="n">dots_end</span><span class="p">),</span> <span class="n">context</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
        <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Unmatched bracket at the end&quot;</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    elif prev == &#39;)&#39;:</span>
<span class="sd">        bulges = add_bulge(bulges, (i+1, i+1), context, &quot;8&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">bulges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">finished_bulges</span> <span class="o">+=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">context</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unmatched open bracket&quot;</span><span class="p">)</span>

    <span class="n">stem_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">stems</span> <span class="o">=</span> <span class="n">condense_stem_pairs</span><span class="p">(</span><span class="n">stem_pairs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">finished_bulges</span><span class="p">,</span> <span class="n">stems</span></div>

<div class="viewcode-block" id="Sequence"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.Sequence">[docs]</a><span class="k">class</span> <span class="nc">Sequence</span><span class="p">(</span><span class="nb">str</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">(</span><span class="n">Sequence</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__len__</span><span class="p">()</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Sequence.is_valid"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.Sequence.is_valid">[docs]</a>    <span class="k">def</span> <span class="nf">is_valid</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wrong_chars</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="s2">&quot;AUGCaugc&amp;&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">wrong_chars</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Illegal characters are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wrong_chars</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span></div>

<div class="viewcode-block" id="Sequence.subseq_with_cutpoints"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.Sequence.subseq_with_cutpoints">[docs]</a>    <span class="k">def</span> <span class="nf">subseq_with_cutpoints</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stop</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="n">out</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
        <span class="k">if</span> <span class="n">start</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">prev_seq</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">subseq_with_cutpoints</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">start</span><span class="p">)</span>
            <span class="n">start</span><span class="o">+=</span><span class="n">prev_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
            <span class="n">stop</span><span class="o">+=</span><span class="n">prev_seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>

        <span class="n">i</span><span class="o">=</span><span class="n">start</span><span class="o">-</span><span class="mi">1</span>
        <span class="c1">#log.debug(&quot;i={}, stop={},{}, {}&quot;.format(i, stop, seq, type(seq)))</span>

        <span class="k">while</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">stop</span><span class="o">+</span><span class="n">out</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">o</span><span class="o">=</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1">#log.debug(&quot;subseq_with_cutpoints: i={}, appending {}&quot;.format(i, o))</span>
            <span class="n">out</span><span class="o">+=</span><span class="n">o</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
            <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">out</span></div>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">backbone_breaks_after</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">seq</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">while</span> <span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
            <span class="c1">#print(&quot;{}, {}: {}&quot;.format(i, len(out), seq[i+len(out)]))</span>
            <span class="k">if</span> <span class="n">seq</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="nb">len</span><span class="p">(</span><span class="n">out</span><span class="p">)]</span><span class="o">==</span><span class="s1">&#39;&amp;&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indexing with a 1-based index, ignoring cutpoints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#stack = &#39;&#39;.join(list(traceback.format_stack())[-3:-1])</span>
        <span class="c1">#if &#39;out += self[i]&#39; not in stack:</span>
            <span class="c1">#warnings.warn(&quot;The RNA sequence is now a forgi.graph.Sequence object, which uses 1-based indexing! (It was a string with 0-based indexing before)&quot;, stacklevel = 2)</span>
            <span class="c1">#log.warning(stack + &quot;__getitem__ called &quot;)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">slice</span><span class="p">):</span>
            <span class="n">out</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)):</span> <span class="c1">#http://stackoverflow.com/questions/16652482/python-iterate-slice-object#16652549</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> <span class="k">continue</span>
                <span class="n">out</span> <span class="o">+=</span> <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1">#log.debug(&quot;i is {}, out is now {}&quot;.format(i, out))</span>
            <span class="k">return</span> <span class="n">out</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">key</span><span class="o">-=</span><span class="mi">1</span> <span class="c1">#From 1-based to 0 based indexing.</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&amp;&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="c1">#seq is a string, not a sequence object</span>
            <span class="k">return</span> <span class="n">seq</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;Wrong index type&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">()</span>
    <span class="k">def</span> <span class="nf">__getslice__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">step</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">stop</span><span class="p">,</span> <span class="n">step</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph">[docs]</a><span class="k">class</span> <span class="nc">BulgeGraph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bg_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A bulge graph object.</span>

<span class="sd">        :var self.defines: The coarse grain element definitions: Keys are for example &#39;s1&#39;/ &#39;m2&#39;/ &#39;h3&#39;/ &#39;f1&#39;/ &#39;t1&#39;</span>
<span class="sd">                       Values are the positions in the sequence (1D-coordinate) of start , end, ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mst</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;untitled&quot;</span>
        <span class="c1">#: The coarse grain element definitions: Keys are for example &#39;s1&#39;/ &#39;m2&#39;/ &#39;h3&#39;/ &#39;f1&#39;/ &#39;t1&#39;</span>
        <span class="c1">#: Values are the positions in the sequence (1D-coordinate) of start , end, ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># store the coordinate basis for each stem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bases</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stem_invs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Additional infos as key-value pairs are stored here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infos</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1">#Consistency check, only if both dotbracket and sequence are present.</span>
        <span class="k">if</span> <span class="n">dotbracket_str</span> <span class="ow">and</span> <span class="n">seq</span><span class="p">:</span>
            <span class="n">db_strs</span> <span class="o">=</span> <span class="n">dotbracket_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
            <span class="n">seq_strs</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq_strs</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">db_strs</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">db_strs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">seq_strs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                                                      <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">db_strs</span><span class="p">))):</span>
                <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Sequence and dotbracket string are not consistent!&quot;</span><span class="p">)</span>



        <span class="bp">self</span><span class="o">.</span><span class="n">_seq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1">#seq is a property that creates Sequence instances automatically.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span>

        <span class="n">seq_strs</span> <span class="o">=</span> <span class="n">seq</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seqs</span><span class="o">=</span><span class="p">{}</span> <span class="c1">#A dictionary: chain_id: sequence</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chain_ids</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1">#Keep the order of chain ids.</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">seq_str</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seq_strs</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seqs</span><span class="p">[</span><span class="n">VALID_CHAINIDS</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span><span class="o">=</span><span class="n">seq_str</span> <span class="c1">#Index Error, if too many chains.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chain_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">VALID_CHAINIDS</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">+=</span> <span class="p">[</span><span class="n">resid_from_str</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VALID_CHAINIDS</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">j</span><span class="o">+</span><span class="mi">1</span><span class="p">))]</span>

        <span class="c1">#: If more than one chain is present.</span>
        <span class="c1">#: ((&amp;))</span>
        <span class="c1">#: 12 34</span>
        <span class="c1">#: A break is present after nucleotide 2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1">#: Used during construction of the BG</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backbone_will_break_after</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">dotbracket_str</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_from_dotbracket</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bg_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_bg_file</span><span class="p">(</span><span class="n">bg_file</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">seq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seq</span>

    <span class="nd">@seq</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_seq</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seq</span> <span class="o">=</span> <span class="n">Sequence</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">seq</span><span class="o">.</span><span class="n">is_valid</span><span class="p">():</span>
                <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Cannot set sequence. Illegal character in string &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_seq</span> <span class="o">=</span> <span class="n">seq</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="n">traceback</span><span class="o">.</span><span class="n">extract_stack</span><span class="p">()[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sequence set to </span><span class="si">%r</span><span class="s2"> by `</span><span class="si">%s</span><span class="s2">` on line </span><span class="si">%s</span><span class="s2"> in function </span><span class="si">%s</span><span class="s2"> of file </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_seq</span><span class="p">,</span> <span class="n">stack</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">stack</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">stack</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">stack</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

    <span class="c1"># get an internal index for a named vertex</span>
    <span class="c1"># this applies to both stems and edges</span>
<div class="viewcode-block" id="BulgeGraph.get_vertex"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new unique vertex name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;x</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_counter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">name</span></div>

<div class="viewcode-block" id="BulgeGraph.element_length"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.element_length">[docs]</a>    <span class="k">def</span> <span class="nf">element_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of residues that are contained within this element.</span>

<span class="sd">        :param key: The name of the element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">length</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_length"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_length">[docs]</a>    <span class="k">def</span> <span class="nf">stem_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the length of a particular element. If it&#39;s a stem, it&#39;s equal to</span>
<span class="sd">        the number of paired bases. If it&#39;s an interior loop, it&#39;s equal to the</span>
<span class="sd">        number of unpaired bases on the strand with less unpaired bases. If</span>
<span class="sd">        it&#39;s a multiloop, then it&#39;s the number of unpaired bases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span> <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.add_info"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.add_info">[docs]</a>    <span class="k">def</span> <span class="nf">add_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.get_single_define_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_single_define_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_single_define_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a define string for a single key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;define </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]]))</span></div>

<div class="viewcode-block" id="BulgeGraph.get_define_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_define_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_define_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the defines into a string.</span>

<span class="sd">        Format:</span>

<span class="sd">        define [name] [start_res1] [end_res1] [start_res2] [end_res2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defines_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># a method for sorting the defines</span>
        <span class="k">def</span> <span class="nf">define_sorter</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">drni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">drni</span><span class="p">)</span> <span class="c1">#.next()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">define_sorter</span><span class="p">):</span>
            <span class="n">defines_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_define_str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># defines_str += &quot;define %s %s&quot; % ( key, &quot; &quot;.join([str(d) for d in self.defines[key]]))</span>
            <span class="n">defines_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">defines_str</span></div>

<div class="viewcode-block" id="BulgeGraph.get_length_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_length_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_length_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;length &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span></div>

<div class="viewcode-block" id="BulgeGraph.get_info_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_info_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_info_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">[</span><span class="n">info</span><span class="p">]:</span>
                <span class="n">out</span><span class="o">+=</span><span class="s2">&quot;info &quot;</span><span class="o">+</span><span class="n">info</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">value</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="BulgeGraph.get_connect_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_connect_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_connect_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the connections of the bulges in the graph.</span>

<span class="sd">        Format:</span>

<span class="sd">        connect [from] [to1] [to2] [to3]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">whole_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Our graph will be defined by the stems and the bulges they connect to</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">out_str</span> <span class="o">=</span> <span class="s2">&quot;connect </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">dest</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                    <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>

                <span class="n">whole_str</span> <span class="o">+=</span> <span class="n">out_str</span>
                <span class="n">whole_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">return</span> <span class="n">whole_str</span></div>

<div class="viewcode-block" id="BulgeGraph.get_sequence_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_sequence_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_sequence_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sequence along with its keyword. I.e.</span>

<span class="sd">            seq ACGGGCC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;seq </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="BulgeGraph.get_seq_ids_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_seq_ids_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_seq_ids_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sequence id string</span>

<span class="sd">        seq_ids 1 2 2.A 17</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s2">&quot;seq_ids &quot;</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">resid_to_str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">))</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="BulgeGraph.get_name_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_name_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_name_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the name of this structure along with its keyword:</span>

<span class="sd">            name 1y26</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;name </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_bg_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_bg_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_bg_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output a string representation that can be stored and reloaded.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_name_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequence_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seq_ids_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_define_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connect_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_info_str</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="BulgeGraph.to_file"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">out_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_element_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_element_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_element_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_numbers</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a string similar to dotbracket notation that identifies what</span>
<span class="sd">        type of element is present at each location.</span>

<span class="sd">        For example the following dotbracket:</span>

<span class="sd">        ..((..))..</span>

<span class="sd">        Should yield the following element string:</span>

<span class="sd">        ffsshhsstt</span>

<span class="sd">        Indicating that it begins with a fiveprime region, continues with a</span>
<span class="sd">        stem, has a hairpin after the stem, the stem continues and it is terminated</span>
<span class="sd">        by a threeprime region.</span>

<span class="sd">        :param with_numbers: show the last digit of the element id in a second line.::</span>

<span class="sd">                                 (((.(((...))))))</span>

<span class="sd">                             Could result in::</span>

<span class="sd">                                 sssissshhhssssss</span>
<span class="sd">                                 0000111000111000</span>

<span class="sd">                             Indicating that the first stem is named &#39;s0&#39;, followed by &#39;i0&#39;,&#39;</span>
<span class="sd">                             s1&#39;, &#39;h0&#39;, the second strand of &#39;s1&#39; and the second strand of &#39;s0&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_str</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">output_nr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">resi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="n">output_str</span><span class="p">[</span><span class="n">resi</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">output_nr</span><span class="p">[</span><span class="n">resi</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">with_numbers</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_str</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_nr</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_str</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span></div>
<div class="viewcode-block" id="BulgeGraph.to_neato_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_neato_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_neato_string</span><span class="p">(</span><span class="n">bg</span><span class="p">):</span>

        <span class="c1"># The different nodes for different types of bulges</span>
        <span class="n">node_lines</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">fontsize</span><span class="o">=</span><span class="mi">20</span>
        <span class="n">out</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;graph G {&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">graph [overlap=false,splines=true];&quot;</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">node [shape=box];&quot;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># Create the nodes with a different color for each type of element</span>
            <span class="k">if</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span> <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,fillcolor=&quot;#B3E2CD&quot;,fontsize=</span><span class="si">%d</span><span class="s1">,label=</span><span class="se">\&quot;</span><span class="si">%s</span><span class="se">\\</span><span class="s1">n(</span><span class="si">%d</span><span class="s1">)</span><span class="se">\&quot;</span><span class="s1">] </span><span class="si">%s</span><span class="s1">};&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">,</span><span class="n">key2</span><span class="p">,</span> <span class="n">bg</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">key2</span><span class="p">),</span> <span class="n">key2</span><span class="p">)</span> <span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#FFF2AE&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#F4CAE4&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#FDCDAC&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">elif</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#E6F5C9&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">)</span> <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="s1">&#39;</span><span class="se">\t</span><span class="s1">{node [style=filled,shape=circle,fillcolor=&quot;#CBD5E8&quot;,fontsize=</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">fontsize</span><span class="p">)</span> <span class="p">)</span>

            <span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s1">&#39;,label=</span><span class="se">\&quot;</span><span class="si">%s</span><span class="s1"> </span><span class="se">\\</span><span class="s1">n&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key2</span><span class="p">)</span>

            <span class="c1"># figure out the size of the node and use that as a label</span>
            <span class="n">node_dims</span> <span class="o">=</span> <span class="n">bg</span><span class="o">.</span><span class="n">get_node_dimensions</span><span class="p">(</span><span class="n">key2</span><span class="p">)</span>
            <span class="n">total_bulge</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">node_dims</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">node_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">node_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">node_dims</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">node_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">node_dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1000</span><span class="p">:</span>
                <span class="n">node_dims</span> <span class="o">=</span> <span class="s2">&quot;(</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_dims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Dims of node </span><span class="si">%s</span><span class="s2"> are </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">key2</span><span class="p">,</span> <span class="n">node_dims</span><span class="p">)</span>
            <span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="n">node_dims</span><span class="p">)</span>

            <span class="c1"># make bigger interior loops visually bigger</span>
            <span class="n">width</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">1.5</span> <span class="o">*</span> <span class="n">total_bulge</span> <span class="o">/</span> <span class="mf">10.0</span><span class="p">)</span>
            <span class="n">height</span> <span class="o">=</span> <span class="n">width</span>

            <span class="k">if</span> <span class="n">key2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">,width=</span><span class="si">%f</span><span class="s2">,heigh=</span><span class="si">%f</span><span class="s2">] </span><span class="si">%s</span><span class="s2">};&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">,</span> <span class="n">key2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">out</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\&quot;</span><span class="s2">] </span><span class="si">%s</span><span class="s2">};&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key2</span><span class="p">)</span>


        <span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key1</span><span class="p">]:</span>
                    <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>  <span class="s2">&quot;</span><span class="se">\t</span><span class="si">%s</span><span class="s2"> -- </span><span class="si">%s</span><span class="s2">;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">)</span> <span class="p">)</span>

        <span class="c1">#for key1 in bg.longrange.keys():</span>
    <span class="c1">#        for key2 in bg.longrange[key1]:</span>
<span class="c1">#                out.append( &quot;\t{%s -- %s [style=dashed]};&quot; % (key1, key2))</span>

        <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;}&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">out</span><span class="p">)</span></div>



<div class="viewcode-block" id="BulgeGraph.define_range_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.define_range_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">define_range_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ranges of the nucleotides in the define.</span>

<span class="sd">        In other words, if a define contains the following: [1,2,7,8]</span>
<span class="sd">        The ranges will be [1,2] and [7,8].</span>

<span class="sd">        :param adjacent: Use the nucleotides in the neighboring element which</span>
<span class="sd">                         connect to this element as the range starts and ends.</span>
<span class="sd">        :return: A list of two-element lists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
            <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">define</span><span class="p">:</span>
            <span class="k">yield</span> <span class="p">[</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">define</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">define</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">[</span> <span class="n">define</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">define</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">]</span></div>


<div class="viewcode-block" id="BulgeGraph.define_a"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.define_a">[docs]</a>    <span class="k">def</span> <span class="nf">define_a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a define including the adjacent nucleotides.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span><span class="p">:</span>
            <span class="n">conns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">conns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">conns</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">,</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="p">,</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span> <span class="o">==</span> <span class="p">[]:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero_length_element_adj_position</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
            <span class="n">new_def</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">define</span><span class="p">),</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">new_def</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
                    <span class="n">new_def</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_def</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">new_def</span></div>

<div class="viewcode-block" id="BulgeGraph.define_residue_num_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.define_residue_num_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">define_residue_num_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the residue numbers that belong to this node.</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_range_iterator</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">adjacent</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seq_ids</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">i</span></div>

<div class="viewcode-block" id="BulgeGraph.iterate_over_seqid_range"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.iterate_over_seqid_range">[docs]</a>    <span class="k">def</span> <span class="nf">iterate_over_seqid_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_id</span><span class="p">,</span> <span class="n">end_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the seq_ids between the start_id and end_id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">start_id</span><span class="p">)</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">end_id</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>

<div class="viewcode-block" id="BulgeGraph.seq_id_to_pos"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.seq_id_to_pos">[docs]</a>    <span class="k">def</span> <span class="nf">seq_id_to_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a pdb seq_id to a 1-based nucleotide position</span>

<span class="sd">        :param seq_id: An instance of RESID</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_id</span><span class="p">,</span> <span class="n">RESID</span><span class="p">)</span>
        <span class="c1">#if isinstance(seq_id, int):</span>
        <span class="c1">#    seq_id=(&quot; &quot;, seq_id, &quot; &quot;)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;seq_id is </span><span class="si">{}</span><span class="s2">, self.seq_ids is </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">seq_id</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">))</span>
            <span class="k">raise</span></div>

    <span class="k">def</span> <span class="nf">_create_bulge_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stems</span><span class="p">,</span> <span class="n">bulges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find out which stems connect to which bulges</span>

<span class="sd">        Stems and bulges which share a nucleotide are considered connected.</span>

<span class="sd">        :param stems: A list of tuples of tuples of the form [((s1, e1), (s2, e2))]</span>
<span class="sd">                      where s1 and e1 are the nucleotides at one end of the stem</span>
<span class="sd">                      and s2 and e2 are the nucleotides at the other.</span>

<span class="sd">        :param bulges: A list of tuples of the form [(s, e)] where s and e are the</span>
<span class="sd">                       numbers of the nucleotides at the start and end of the bulge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">)):</span>
            <span class="n">stem</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulges</span><span class="p">)):</span>
                <span class="n">bulge</span> <span class="o">=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">any_difference_of_one</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;y</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;b</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;b</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;y</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_create_stem_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stems</span><span class="p">,</span> <span class="n">bulge_counter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine which stems are connected to each other. A stem can be connected to</span>
<span class="sd">        another stem when there is an interior loop with an unpaired nucleotide on</span>
<span class="sd">        one side. In this case, a bulge will be created on the other side, but it</span>
<span class="sd">        will only consist of the two paired bases around where the unpaired base</span>
<span class="sd">        would be if it existed.</span>

<span class="sd">        The defines for these bulges will be printed as well as the connection strings</span>
<span class="sd">        for the stems they are connected to.</span>

<span class="sd">        :param stems: A list of tuples of tuples of the form [((s1, e1), (s2, e2))]</span>
<span class="sd">                      where s1 and e1 are the nucleotides at one end of the stem</span>
<span class="sd">                      and s2 and e2 are the nucleotides at the other.</span>
<span class="sd">        :param bulge_counter: The number of bulges that have been encountered so far.</span>

<span class="sd">        :returns: None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print &quot;stems:&quot;, stems</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">)),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k1</span><span class="p">][</span><span class="n">l1</span><span class="p">]</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k2</span><span class="p">][</span><span class="n">l2</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">k1</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">l1</span><span class="p">]</span><span class="o">==</span><span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">l1</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">k2</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">stems</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="n">l2</span><span class="p">]</span><span class="o">==</span><span class="n">stems</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="n">l2</span><span class="p">]:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s1</span> <span class="o">-</span> <span class="n">s2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">bn</span> <span class="o">=</span> <span class="s1">&#39;b</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bulge_counter</span><span class="p">)</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding bulge </span><span class="si">%s</span><span class="s2"> between </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">. (</span><span class="si">%s</span><span class="s2"> is next to </span><span class="si">%s</span><span class="s2"> ) k1 </span><span class="si">%s</span><span class="s2">, k2 </span><span class="si">%s</span><span class="s2">, l1 </span><span class="si">%s</span><span class="s2">, l2 </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bn</span><span class="p">,</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">stems</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">,</span> <span class="n">l1</span><span class="p">,</span> <span class="n">l2</span><span class="p">)</span>
                    <span class="c1"># self.defines[bn] = [min(s1, s2)+1, max(s1, s2)+1]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;y</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bn</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;y</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;y</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bn</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;y</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

                    <span class="n">bulge_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span> <span class="c1">#0-nt Hairpins</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s2</span> <span class="o">-</span> <span class="n">e1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bn</span> <span class="o">=</span> <span class="s1">&#39;b</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bulge_counter</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bn</span><span class="p">)</span>

                <span class="n">bulge_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span>

<div class="viewcode-block" id="BulgeGraph.remove_vertex"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.remove_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete a node after merging it with another</span>

<span class="sd">        :param v: The name of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># delete all edges to this node</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># delete all edges from this node</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_reduce_defines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make defines like this:</span>

<span class="sd">        define x0 2 124 124 3 4 125 127 5 5</span>

<span class="sd">        Into this:</span>

<span class="sd">        define x0 2 3 5 124 127</span>

<span class="sd">        That is, consolidate contiguous bulge region defines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">new_j</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">while</span> <span class="n">new_j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>

                    <span class="n">j</span> <span class="o">=</span> <span class="n">new_j</span>
                    <span class="n">new_j</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span>

                    <span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>

                    <span class="c1"># remove bulges of length 0</span>
                    <span class="k">if</span> <span class="n">f1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

                        <span class="n">new_j</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">continue</span>

                    <span class="c1"># merge contiguous bulge regions</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span> <span class="mi">2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                            <span class="c1"># we can have stems with defines like: [1,2,3,4]</span>
                            <span class="c1"># which would imply a non-existant loop at its end</span>
                            <span class="k">continue</span>

                        <span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">k</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>

                        <span class="k">if</span> <span class="n">t2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">f1</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">f2</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="k">if</span> <span class="n">t2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">f1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">t1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">f2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>

                        <span class="n">new_j</span> <span class="o">=</span> <span class="mi">0</span>

                        <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_merge_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is done when two of the outgoing strands of a stem</span>
<span class="sd">        go to different bulges</span>
<span class="sd">        It is assumed that the two ends are on the same sides because</span>
<span class="sd">        at least one vertex has a weight of 2, implying that it accounts</span>
<span class="sd">        for all of the edges going out of one side of the stem</span>

<span class="sd">        :param vertices: A list of vertex names to combine into one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># assert(len(vertices) == 2)</span>

        <span class="n">connections</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>

            <span class="c1"># what are we gonna merge?</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">connections</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="c1"># Add the definition of this vertex to the new vertex</span>
            <span class="c1"># self.merge_defs[new_vertex] = self.merge_defs.get(new_vertex, []) + [v]</span>

            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># remove the old vertex, since it&#39;s been replaced by new_vertex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_defines</span><span class="p">()</span>

        <span class="c1"># self.weights[new_vertex] = 2</span>
        <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">connection</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_vertex</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_vertex</span>

<div class="viewcode-block" id="BulgeGraph.shortest_bg_loop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.shortest_bg_loop">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_bg_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a shortest loop containing this node. The vertex should</span>
<span class="sd">        be a multiloop.</span>

<span class="sd">        :param vertex: The name of the vertex to find the loop.</span>
<span class="sd">        :return: A list containing the elements in the shortest cycle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Starting shortest BG loop for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;nx graph  </span><span class="si">%r</span><span class="s2"> with edges </span><span class="si">%r</span><span class="s2"> &quot;</span><span class="p">,</span> <span class="n">G</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">adj</span><span class="p">)</span>

        <span class="c1"># use the nucleotide in the middle of this element as the starting point</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">)))</span>
        <span class="n">mid_res</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;mid_residue </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">mid_res</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># no-residue multiloop</span>
            <span class="c1"># find the neighbor which isn&#39;t part of the multiloop</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">mid_res</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># break the chain so that we don&#39;t get cycles within a stem</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">mid_res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mid_res</span><span class="p">)</span>
                        <span class="k">break</span>

        <span class="kn">import</span> <span class="nn">forgi.utilities.graph</span> <span class="k">as</span> <span class="nn">fug</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">fug</span><span class="o">.</span><span class="n">shortest_cycle</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">mid_res</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Shortest cycle is </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span></div>

    <span class="k">def</span> <span class="nf">_chain_start_end</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
      <span class="k">if</span> <span class="n">pos</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">pos</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">:</span>
          <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
          <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Pos </span><span class="si">{}</span><span class="s2"> is not at the end of a chain.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">))</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
          <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span>
<div class="viewcode-block" id="BulgeGraph.get_next_ml_segment"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_next_ml_segment">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">get_next_ml_segment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ml_segment</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the adjacent multiloop-segment (or 3&#39; loop) next to the 3&#39; side of ml_segment.</span>

<span class="sd">        If there is no other single stranded RNA after the stem, the backbone must end there.</span>
<span class="sd">        In that case return None.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;get_next_ml_segment called for </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ml_segment</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">ml_segment</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ml_segment</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;mf&quot;</span><span class="p">:</span>
                <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">ml_segment</span><span class="p">)[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a multiloop&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ml_segment</span><span class="p">))</span>

            <span class="c1"># The stem following the ml-segment</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="n">ml_segment</span><span class="p">:</span>
                <span class="c1"># The Cg consists of only a single f-element.</span>
                <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="n">side_stem</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">ml_segment</span><span class="p">)</span>
            <span class="c1"># Get the stem-side where we expect to find the next ML-segment</span>
            <span class="k">if</span> <span class="n">side_stem</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">side_stem</span> <span class="o">=</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="n">side_stem</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">side_stem</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">side_stem</span> <span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">side_stem</span> <span class="o">=</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="n">side_stem</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">side_stem</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;flanking_nuc_at_stem_side called for </span><span class="si">%s</span><span class="s2">, side </span><span class="si">%s</span><span class="s2"> with defines </span><span class="si">%s</span><span class="s2">.&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">side_stem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="n">ml_nuc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nuc_at_stem_side</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">side_stem</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;ml_nucleotide is </span><span class="si">%s</span><span class="s2"> (sequence length is </span><span class="si">%s</span><span class="s2">).&quot;</span><span class="p">,</span> <span class="n">ml_nuc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">)</span>
        <span class="c1"># End of the backbone</span>
        <span class="k">if</span> <span class="n">ml_nuc</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="ow">or</span> <span class="n">ml_nuc</span><span class="o">-</span><span class="mi">1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">elem</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">ml_nuc</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;side now </span><span class="si">%s</span><span class="s2">, ml_nuc </span><span class="si">%s</span><span class="s2">, ml </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">side_stem</span><span class="p">,</span> <span class="n">ml_nuc</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span><span class="p">:</span>
            <span class="c1">#0-length multiloop</span>
            <span class="n">elems</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span><span class="o">&amp;</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elems</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_length</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">elem</span>
            <span class="k">assert</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="s2">&quot;mft&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>
            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> is not a multiloop node&quot;</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="n">elem</span></div>

<div class="viewcode-block" id="BulgeGraph.shortest_mlonly_multiloop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.shortest_mlonly_multiloop">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_mlonly_multiloop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ml_segment</span><span class="p">):</span>
        <span class="n">loops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_mlonly_multiloops</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">loops</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ml_segment</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">loop</span></div>

<div class="viewcode-block" id="BulgeGraph.flanking_nuc_at_stem_side"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.flanking_nuc_at_stem_side">[docs]</a>    <span class="k">def</span> <span class="nf">flanking_nuc_at_stem_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the nucleotide number that is next to the stem at the given stem side.</span>

<span class="sd">        :param side: 0, 1, 2 or 3, as returned by self.get_sides_plus</span>
<span class="sd">        :returns: The nucleotide position. If the stem has no neighbor at that side,</span>
<span class="sd">                  0 or self.seq_length+1 is returned instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> is not a stem&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="n">stem_nuc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">side</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">side</span> <span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stem_nuc</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">stem_nuc</span> <span class="o">+</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="BulgeGraph.all_connections"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.all_connections">[docs]</a>    <span class="k">def</span> <span class="nf">all_connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the connected elements in order along the backbone.</span>

<span class="sd">        The difference to self.connections is that the returned list</span>
<span class="sd">        always contains as many elements, as the define of elem has numbers.</span>
<span class="sd">        If there is no connected element at this side,the returned list contains None.</span>
<span class="sd">        If elem is a stem connected to a hairpin or interior loop,</span>
<span class="sd">        this loop will be contained twice in the resulting output list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="c1"># To correctly account for 0-length elements, we have to treat stems seperately.</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;s&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">nt</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
                <span class="n">neighbor</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">neighbor</span> <span class="o">==</span> <span class="n">elem</span><span class="p">:</span>
                    <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="p">[</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span> <span class="p">]</span>
            <span class="k">for</span> <span class="n">neighbor</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">elem</span><span class="p">]:</span>
                <span class="k">for</span> <span class="n">side</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">x</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="n">side</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">neighbor</span><span class="p">)):</span>
                        <span class="n">connections</span><span class="p">[</span><span class="n">side</span><span class="p">]</span><span class="o">=</span><span class="n">neighbor</span>
        <span class="k">return</span> <span class="n">connections</span></div>

<div class="viewcode-block" id="BulgeGraph.nucleotides_to_elements"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.nucleotides_to_elements">[docs]</a>    <span class="k">def</span> <span class="nf">nucleotides_to_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nucleotides</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a list of nucleotides (nucleotide numbers) to element names.</span>

<span class="sd">        Remove redundant entries and return a set.</span>

<span class="sd">        ..note::</span>
<span class="sd">            Use `self.get_node_from_residue_num` if you have only a single nucleotide number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nucleotides</span><span class="p">])</span></div>



<div class="viewcode-block" id="BulgeGraph.elements_to_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.elements_to_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">elements_to_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a list of element names to a list of nucleotide numbers.</span>

<span class="sd">        Remove redundant entries.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nucs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">def_range</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_range_iterator</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">adjacent</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">nuc</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">def_range</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">def_range</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">nucs</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nuc</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">nucs</span><span class="p">)</span></div>
<div class="viewcode-block" id="BulgeGraph.find_bulge_loop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.find_bulge_loop">[docs]</a>    <span class="k">def</span> <span class="nf">find_bulge_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a set of nodes that form a loop containing the</span>
<span class="sd">        given vertex and being no greater than max_length nodes long.</span>

<span class="sd">        :param vertex: The vertex to start the search from.</span>
<span class="sd">        :param max_length: Only fond loops that contain no more then this many elements</span>
<span class="sd">        :returns: A list of the nodes in the loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">vertex</span><span class="p">]]</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="n">in_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertex</span><span class="p">]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_visit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

            <span class="n">in_path</span> <span class="o">=</span> <span class="n">in_path</span><span class="p">[:</span><span class="n">depth</span><span class="p">]</span>
            <span class="n">in_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">vertex</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_path</span><span class="p">[:</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">in_path</span><span class="p">[:</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">to_visit</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="BulgeGraph.add_node"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">define</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>
    <span class="k">def</span> <span class="nf">_remove_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a node and all its (in- and out-) edges.</span>

<span class="sd">        .. warning::</span>

<span class="sd">            This does NOT update the defines/ cponnections of other nodes, and</span>
<span class="sd">            may result in the graph falling apart into several connected components.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="o">*</span><span class="n">edge</span><span class="p">)</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

<div class="viewcode-block" id="BulgeGraph.dissolve_length_one_stems"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.dissolve_length_one_stems">[docs]</a>    <span class="k">def</span> <span class="nf">dissolve_length_one_stems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># dissolve all stems which have a length of one</span>
        <span class="n">stems_to_dissolve</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span> <span class="p">]</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Dissolving stem </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stems_to_dissolve</span><span class="p">)</span>
        <span class="n">bps_to_dissolve</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stems_to_dissolve</span><span class="p">:</span>
            <span class="n">bps_to_dissolve</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">s</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_base_pairs</span><span class="p">(</span><span class="n">bps_to_dissolve</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">stems_to_dissolve</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">()))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;All stems of the structure had length 1 and were dissolved!&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.remove_base_pairs"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.remove_base_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">remove_base_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all of the base pairs which are in pair_list.</span>

<span class="sd">        :param to_remove: A list of tuples containing the names of the base pairs.</span>
<span class="sd">        :return: nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backbone_will_break_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_tuples</span><span class="p">()</span>

        <span class="n">to_remove</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">to_remove</span><span class="p">)</span>

        <span class="n">nt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pt</span><span class="p">:</span>
            <span class="n">to_add</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="n">to_add</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="n">nt</span> <span class="o">+=</span> <span class="p">[</span><span class="n">to_add</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># self.edges = dict()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_collapse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If any vertices form a loop, then they are either a bulge region or</span>
<span class="sd">        a fork region. The bulge (interior loop) regions will be condensed</span>
<span class="sd">        into one node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_vertex</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">while</span> <span class="n">new_vertex</span><span class="p">:</span>
            <span class="n">new_vertex</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">bulges</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">b1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">b2</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">b1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>

                    <span class="n">all_connections</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b2</span><span class="p">)[</span><span class="mi">0</span><span class="p">])),</span>
                                       <span class="nb">sorted</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))]</span>

                    <span class="k">if</span> <span class="n">all_connections</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]:</span>
                        <span class="c1"># interior loop</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Collapsing </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_vertices</span><span class="p">([</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">])</span>
                        <span class="n">new_vertex</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">break</span>


<div class="viewcode-block" id="BulgeGraph.relabel_node"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.relabel_node">[docs]</a>    <span class="k">def</span> <span class="nf">relabel_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the name of a node.</span>

<span class="sd">        param old_name: The previous name of the node</span>
<span class="sd">        param new_name: The new name of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#log.debug(&quot;Relabelling node {} to {}&quot;.format(old_name, new_name))</span>
        <span class="c1"># replace the define name</span>
        <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">define</span>

        <span class="c1"># replace the index into the edges array</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>

        <span class="c1">#replace the name of any edge that pointed to old_name</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">old_name</span><span class="p">:</span>
                    <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_edges</span></div>

<div class="viewcode-block" id="BulgeGraph.compare_stems"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.compare_stems">[docs]</a>    <span class="k">def</span> <span class="nf">compare_stems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that can be passed in as the key to a sort.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="BulgeGraph.compare_bulges"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.compare_bulges">[docs]</a>    <span class="k">def</span> <span class="nf">compare_bulges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">flank_nucs</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that can be passed in as the key to a sort.</span>

<span class="sd">        Compares based on the nucleotide number</span>
<span class="sd">        (using define_a to allow for sorting 0-length MLs)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">b</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.compare_hairpins"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.compare_hairpins">[docs]</a>    <span class="k">def</span> <span class="nf">compare_hairpins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the labels of the nodes to be more indicative of their nature.</span>

<span class="sd">        s: stem</span>
<span class="sd">        h: hairpin</span>
<span class="sd">        i: interior loop</span>
<span class="sd">        m: multiloop</span>
<span class="sd">        f: five-prime unpaired</span>
<span class="sd">        t: three-prime unpaired</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hairpins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">interior_loops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">multiloops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fiveprimes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">threeprimes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span> <span class="ow">or</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">stems</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">hairpins</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">multiloops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fiveprimes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">:</span>
                <span class="n">threeprimes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">):</span>
                <span class="n">hairpins</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;i&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">):</span>
                <span class="n">multiloops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">interior_loops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

        <span class="n">stems</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compare_stems</span><span class="p">)</span>
        <span class="n">hairpins</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compare_hairpins</span><span class="p">)</span>
        <span class="n">multiloops</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compare_bulges</span><span class="p">)</span>
        <span class="n">interior_loops</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compare_stems</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">fiveprimes</span><span class="p">:</span>
            <span class="n">d</span><span class="p">,</span> <span class="o">=</span> <span class="n">fiveprimes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;f0&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">threeprimes</span><span class="p">:</span>
            <span class="n">d</span><span class="p">,</span> <span class="o">=</span> <span class="n">threeprimes</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;t0&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stems</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;s</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">interior_loops</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;i</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">multiloops</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;m</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hairpins</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;h</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span>

<div class="viewcode-block" id="BulgeGraph.has_connection"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.has_connection">[docs]</a>    <span class="k">def</span> <span class="nf">has_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is there an edge between these two nodes &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">v2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># two multiloops can be connected at the end of a stem</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">v2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
                    <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">s1e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">s2b</span><span class="p">,</span> <span class="n">s2e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">s1b</span> <span class="o">==</span> <span class="n">s2b</span><span class="p">:</span>
                        <span class="k">return</span> <span class="kc">True</span>

            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BulgeGraph.connection_type"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.connection_type">[docs]</a>    <span class="k">def</span> <span class="nf">connection_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify the way that two stems are connected according to the type</span>
<span class="sd">        of bulge that separates them.</span>

<span class="sd">        Potential angle types for single stranded segments, and the ends of</span>
<span class="sd">        the stems they connect:</span>

<span class="sd">        =   = ======  ===========</span>
<span class="sd">        1   2 (1, 1)  #pseudoknot</span>
<span class="sd">        1   0 (1, 0)</span>
<span class="sd">        3   2 (0, 1)</span>
<span class="sd">        3   0 (0, 0)</span>
<span class="sd">        =   = ======  ===========</span>

<span class="sd">        :param define: The name of the bulge separating the two stems</span>
<span class="sd">        :param connections: The two stems and their separation</span>

<span class="sd">        :returns: INT connection type</span>

<span class="sd">                  =   ======================================================================</span>
<span class="sd">                  +   positive values mean forward (from the connected stem starting at the</span>
<span class="sd">                      lower nucleotide number to the one starting at the higher nuc. number)</span>
<span class="sd">                  -   negative values mean backwards.</span>
<span class="sd">                  1   interior loop</span>
<span class="sd">                  2   first multi-loop segment of normal multiloops and most pseudoknots</span>
<span class="sd">                  3   middle segment of a normal multiloop</span>
<span class="sd">                  4   last segment of normal multiloops and most pseudoknots</span>
<span class="sd">                  5   middle segments of pseudoknots</span>
<span class="sd">                  =   ======================================================================</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># interior loop, we just have to check if</span>
            <span class="c1"># connections[0] &lt; connections[1]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">b1c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">define</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s2c</span><span class="p">,</span> <span class="n">b2c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">define</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">2</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">3</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">4</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">4</span>

            <span class="c1"># the next two refer to pseudoknots</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s2">&quot;Weird angle type: (s1c, s2c) = (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;connection_type called on non-interior loop/multiloop&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.connection_ends"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.connection_ends">[docs]</a>    <span class="k">def</span> <span class="nf">connection_ends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find out which ends of the stems are connected by a particular angle</span>
<span class="sd">        type.</span>

<span class="sd">        :param connection_type: The angle type, as determined by which corners</span>
<span class="sd">                                of a stem are connected</span>
<span class="sd">        :return: (s1e, s2b) 0 means the side of the stem with the lowest nucleotide, 1 the other side</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ends</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s1">&#39;Unknown connection type: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">connection_type</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">connection_type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ends</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ends</span></div>

    <span class="c1"># This function seems to be unused. Consider deprecation...</span>
<div class="viewcode-block" id="BulgeGraph.get_multiloop_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_multiloop_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">get_multiloop_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiloop_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of nucleotides which make up a particular</span>
<span class="sd">        multiloop.</span>

<span class="sd">        :param multiloop_loop: The elements which make up this multiloop</span>
<span class="sd">        :return: A list of nucleotides</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">multiloop_loop</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">]</span>
        <span class="n">multis</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">multiloop_loop</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">]</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
            <span class="n">relevant_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">multiloop_loop</span><span class="p">]</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">relevant_edges</span><span class="p">]</span>
            <span class="n">sides</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="c1"># the whole stem is part of this multiloop</span>
            <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">or</span> <span class="n">sides</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">residues</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">residues</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">multis</span><span class="p">:</span>
            <span class="n">residues</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">residues</span></div>

    <span class="c1"># This function seems to be unused. Consider deprecation...</span>
<div class="viewcode-block" id="BulgeGraph.find_external_loops"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.find_external_loops">[docs]</a>    <span class="k">def</span> <span class="nf">find_external_loops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return all of the elements which are part of</span>
<span class="sd">        an external loop.</span>

<span class="sd">        :return: A list containing the external loops in this molecule</span>
<span class="sd">                 (i.e. [&#39;f0, m3, m5, t0&#39;])</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ext_loop</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floop_iterator</span><span class="p">(),</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">tloop_iterator</span><span class="p">(),</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">()):</span>
            <span class="n">loop_nts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_bg_loop</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loop_nts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ext_loop</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ext_loop</span></div>

<div class="viewcode-block" id="BulgeGraph.find_mlonly_multiloops"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.find_mlonly_multiloops">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">find_mlonly_multiloops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
        <span class="n">ml_graph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">floop_iterator</span><span class="p">(),</span><span class="bp">self</span><span class="o">.</span><span class="n">tloop_iterator</span><span class="p">()):</span>
            <span class="n">next_ml</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_ml_segment</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">next_ml</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">ml_graph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">next_ml</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ml_graph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">loops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">ml_graph</span><span class="p">):</span>
            <span class="c1">#Order along the cycle, in arbitrary direction.</span>

            <span class="c1">#We need to start at a node with only 1 connection, if present</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">comp</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ml_graph</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">x</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">st_node</span><span class="o">=</span><span class="n">x</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">st_node</span><span class="o">=</span><span class="n">x</span> <span class="c1">#Just take any node</span>
            <span class="c1">#Sort nodes along the cycle</span>
            <span class="n">loop</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dfs_preorder_nodes</span><span class="p">(</span><span class="n">ml_graph</span><span class="o">.</span><span class="n">subgraph</span><span class="p">(</span><span class="n">comp</span><span class="p">),</span> <span class="n">st_node</span><span class="p">))</span>
            <span class="c1">#See if we need to reverse the order</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">l</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
                <span class="n">next_l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_next_ml_segment</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="o">&lt;</span><span class="nb">len</span><span class="p">(</span><span class="n">loop</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">loop</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="n">next_l</span><span class="p">:</span>
                        <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">loop</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">next_l</span><span class="p">:</span>
                        <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">loop</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
            <span class="c1">#Find first node</span>
            <span class="n">first</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
            <span class="n">first_i</span> <span class="o">=</span> <span class="n">loop</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">first</span><span class="p">)</span>
            <span class="n">loop</span><span class="o">=</span><span class="n">loop</span><span class="p">[</span><span class="n">first_i</span><span class="p">:]</span><span class="o">+</span><span class="n">loop</span><span class="p">[:</span><span class="n">first_i</span><span class="p">]</span>
            <span class="n">loops</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">loop</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">loops</span></div>


<div class="viewcode-block" id="BulgeGraph.describe_multiloop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.describe_multiloop">[docs]</a>    <span class="k">def</span> <span class="nf">describe_multiloop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiloop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param multiloop: An iterable of nodes (only &quot;m&quot;, &quot;t&quot; and &quot;f&quot; elements)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">descriptors</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">all_stems</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="n">angle_types</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">Counter</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">multiloop</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;ft&quot;</span><span class="p">:</span>
                <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;open&quot;</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">elif</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span><span class="s2">&quot;m&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Non multiloop element &#39;</span><span class="si">{}</span><span class="s2">&#39; encountered in describe_multiloop.&quot;</span><span class="o">.</span><span class="n">foemat</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">conn</span><span class="p">))</span>
            <span class="n">angle_types</span><span class="p">[</span><span class="n">ctype</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">if</span> <span class="n">ctype</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;pseudoknot&quot;</span><span class="p">)</span>
            <span class="n">all_stems</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">elem</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_stems</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span> <span class="c1">#Odd number of occurrences for 2 stems.</span>
            <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;open&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;open&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">descriptors</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">v</span><span class="o">!=</span><span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_stems</span><span class="o">.</span><span class="n">values</span><span class="p">()):</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">all_stems</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">multiloop</span><span class="p">)</span>
                <span class="nb">print</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">())</span>
                <span class="nb">print</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_element_string</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">assert</span> <span class="nb">sum</span><span class="p">(</span><span class="n">v</span> <span class="o">%</span> <span class="mi">2</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">all_stems</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="o">==</span><span class="mi">0</span>
        <span class="k">if</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="s2">&quot;pseudoknot&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">descriptors</span><span class="p">:</span>
            <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;regular_multiloop&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span> <span class="ow">or</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;pseudoknot&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="s2">&quot;open&quot;</span> <span class="ow">in</span> <span class="n">descriptors</span> <span class="ow">and</span> <span class="p">(</span><span class="n">angle_types</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="ow">or</span> <span class="n">angle_types</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
            <span class="n">descriptors</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s2">&quot;pseudoknot&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">descriptors</span></div>

<div class="viewcode-block" id="BulgeGraph.seq_ids_from_seq"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.seq_ids_from_seq">[docs]</a>    <span class="k">def</span> <span class="nf">seq_ids_from_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sequence ids of the string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># when provided with just a sequence, we presume that the</span>
        <span class="c1"># residue ids are numbered from 1-up</span>
        <span class="n">chainnr</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">resid_from_str</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">VALID_CHAINIDS</span><span class="p">[</span><span class="n">chainnr</span><span class="p">],</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)))</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
                <span class="n">chainnr</span><span class="o">+=</span><span class="mi">1</span></div>


<div class="viewcode-block" id="BulgeGraph.remove_degenerate_nodes"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.remove_degenerate_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">remove_degenerate_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For now just remove all hairpins that have no length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">to_remove</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.from_stems_and_bulges"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_stems_and_bulges">[docs]</a>    <span class="k">def</span> <span class="nf">from_stems_and_bulges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stems</span><span class="p">,</span> <span class="n">bulges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the graph from the list of stems and bulges.</span>

<span class="sd">        :param stems: A list of tuples of two two-tuples, each containing the start</span>
<span class="sd">                      and end nucleotides of each strand of the stem.</span>
<span class="sd">        :param bulges: A list of tuples containing the starts and ends of the</span>
<span class="sd">                       of the bulge regions.</span>
<span class="sd">        :return: Nothing, just make the bulgegraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">)):</span>
            <span class="c1"># one is added to each coordinate to make up for the fact that residues are 1-based</span>
            <span class="n">ss1</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ss2</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">se1</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">se2</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;stem define not sorted: </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">ss1</span><span class="p">,</span> <span class="n">ss2</span><span class="p">,</span> <span class="n">se1</span><span class="p">,</span> <span class="n">se2</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;self.defines </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="s1">&#39;y</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">ss1</span><span class="p">,</span> <span class="n">se1</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ss1</span><span class="p">,</span> <span class="n">se1</span><span class="p">),</span>
                                         <span class="nb">min</span><span class="p">(</span><span class="n">ss2</span><span class="p">,</span> <span class="n">se2</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ss2</span><span class="p">,</span> <span class="n">se2</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="s1">&#39;y</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulges</span><span class="p">)):</span>
            <span class="n">bulge</span> <span class="o">=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="s1">&#39;b</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="s1">&#39;b</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>


        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;from_stems_and_bulges: </span><span class="si">%s</span><span class="s2">; </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_bulge_graph</span><span class="p">(</span><span class="n">stems</span><span class="p">,</span> <span class="n">bulges</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;after _create_bulge_graph: DEFINES:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">;</span><span class="se">\n</span><span class="s2"> EDGES:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">),</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_create_stem_graph</span><span class="p">(</span><span class="n">stems</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bulges</span><span class="p">))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;after _create_stem_graph: DEFINES </span><span class="se">\n</span><span class="si">%s</span><span class="s2">;</span><span class="se">\n</span><span class="s2">EDGES </span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">),</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collapse</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;after _collapse: DEFINES:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">;</span><span class="se">\n</span><span class="s2"> EDGES:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">),</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sort_defines</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;after _sort_defines: DEFINES:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">;</span><span class="se">\n</span><span class="s2"> EDGES:</span><span class="se">\n</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">),</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_relabel_nodes</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;after _relabel_nodes: DEFINES:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">;</span><span class="se">\n</span><span class="s2"> EDGES:</span><span class="se">\n</span><span class="s2"> </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">),</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_degenerate_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_split_at_cofold_cutpoint</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_insert_cutpoints_into_seq</span><span class="p">()</span></div>

<div class="viewcode-block" id="BulgeGraph.from_dotbracket"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_dotbracket">[docs]</a>    <span class="k">def</span> <span class="nf">from_dotbracket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dotbracket_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clear the BulgeGraph structure and repopulate it from a dotbracket representation.</span>
<span class="sd">        Note that the sequence information is lost.</span>

<span class="sd">        ie: ..((..))..</span>

<span class="sd">        :param dotbracket_str: A string containing the dotbracket representation</span>
<span class="sd">                               of the structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_from_dotbracket</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_from_dotbracket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dotbracket_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        See self.from_dotbracket.</span>
<span class="sd">        This private function does not clear the BulgeGraph before populating it</span>
<span class="sd">        from the dotbracket string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dotbracket_str</span> <span class="o">=</span> <span class="n">dotbracket_str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span><span class="o">-</span><span class="n">dotbracket_str</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="s1">&#39;&amp;&#39;</span> <span class="ow">in</span> <span class="n">dotbracket_str</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">db</span> <span class="ow">in</span> <span class="n">dotbracket_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">):</span>
                <span class="n">l</span><span class="o">+=</span><span class="nb">len</span><span class="p">(</span><span class="n">db</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_backbone_will_break_after</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_backbone_will_break_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backbone_will_break_after</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">pt</span> <span class="o">=</span> <span class="n">fus</span><span class="o">.</span><span class="n">dotbracket_to_pairtable</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="n">fus</span><span class="o">.</span><span class="n">pairtable_to_tuples</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dissolve_length_one_stems</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dissolve_length_one_stems</span><span class="p">()</span>

<div class="viewcode-block" id="BulgeGraph.to_pair_table"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_pair_table">[docs]</a>    <span class="k">def</span> <span class="nf">to_pair_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pair table from the list of elements.</span>

<span class="sd">        The first element in the returned list indicates the number of</span>
<span class="sd">        nucleotides in the structure.</span>

<span class="sd">        i.e. [5,5,4,0,2,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pair_tuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_tuples</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fus</span><span class="o">.</span><span class="n">tuples_to_pairtable</span><span class="p">(</span><span class="n">pair_tuples</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_pair_tuples"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_pair_tuples">[docs]</a>    <span class="k">def</span> <span class="nf">to_pair_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list of tuples corresponding to all of the base pairs in the</span>
<span class="sd">        structure. Unpaired bases will be shown as being paired with a</span>
<span class="sd">        nucleotide numbered 0.</span>

<span class="sd">        i.e. [(1,5),(2,4),(3,0),(4,2),(5,1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># iterate over each element</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="c1"># iterate over each nucleotide in each element</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">table</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">table</span></div>

<div class="viewcode-block" id="BulgeGraph.to_bpseq_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_bpseq_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_bpseq_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bpseq string from this structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="BulgeGraph.bpseq_to_tuples_and_seq"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.bpseq_to_tuples_and_seq">[docs]</a>    <span class="k">def</span> <span class="nf">bpseq_to_tuples_and_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bpseq_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a bpseq string to a list of pair tuples and a sequence</span>
<span class="sd">        dictionary. The return value is a tuple of the list of pair tuples</span>
<span class="sd">        and a sequence string.</span>

<span class="sd">        :param bpseq_str: The bpseq string</span>
<span class="sd">        :return: ([(1,5),(2,4),(3,0),(4,2),(5,1)], &#39;ACCAA&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">bpseq_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">pairing_partner</span><span class="o">=</span><span class="p">{}</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">pairing_partner</span> <span class="ow">and</span> <span class="n">t1</span><span class="o">!=</span><span class="n">pairing_partner</span><span class="p">[</span><span class="n">t2</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Faulty bpseq string. </span><span class="si">{}</span><span class="s2"> pairs with </span><span class="si">{}</span><span class="s2">, &quot;</span>
                                 <span class="s2">&quot;but </span><span class="si">{}</span><span class="s2"> pairs with </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">t2</span><span class="p">,</span> <span class="n">pairing_partner</span><span class="p">[</span><span class="n">t2</span><span class="p">],</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">t1</span> <span class="ow">in</span> <span class="n">pairing_partner</span> <span class="ow">and</span> <span class="n">t2</span><span class="o">!=</span><span class="n">pairing_partner</span><span class="p">[</span><span class="n">t1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Faulty bpseq string. </span><span class="si">{}</span><span class="s2"> pairs with </span><span class="si">{}</span><span class="s2">, &quot;</span>
                                 <span class="s2">&quot;but </span><span class="si">{}</span><span class="s2"> pairs with </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pairing_partner</span><span class="p">[</span><span class="n">t1</span><span class="p">],</span> <span class="n">t1</span><span class="p">,</span>  <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">))</span>

            <span class="n">pairing_partner</span><span class="p">[</span><span class="n">t1</span><span class="p">]</span><span class="o">=</span><span class="n">t2</span>
            <span class="k">if</span> <span class="n">t2</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">pairing_partner</span><span class="p">[</span><span class="n">t2</span><span class="p">]</span><span class="o">=</span><span class="n">t1</span>
            <span class="n">tuples</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)]</span>
            <span class="n">seq</span> <span class="o">+=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>

        <span class="n">seq</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.from_bpseq_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_bpseq_str">[docs]</a>    <span class="k">def</span> <span class="nf">from_bpseq_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bpseq_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">breakpoints</span><span class="o">=</span><span class="p">[]):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the graph from a string listing the base pairs.</span>

<span class="sd">        The string should be formatted like so:</span>

<span class="sd">            1 G 115</span>
<span class="sd">            2 A 0</span>
<span class="sd">            3 A 0</span>
<span class="sd">            4 U 0</span>
<span class="sd">            5 U 112</span>
<span class="sd">            6 G 111</span>

<span class="sd">        :param bpseq_str: The string, containing newline characters.</span>
<span class="sd">        :return: Nothing, but fill out this structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">bpseq_str</span><span class="p">)</span>
        <span class="c1">#: This stores backbone breaks before they have been implemented!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_backbone_will_break_after</span> <span class="o">=</span> <span class="n">breakpoints</span>
        <span class="n">tuples</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpseq_to_tuples_and_seq</span><span class="p">(</span><span class="n">bpseq_str</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>

        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;From bpseq_str: Secondary structure: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">dissolve_length_one_stems</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dissolve_length_one_stems</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids_from_seq</span><span class="p">()</span></div>


<div class="viewcode-block" id="BulgeGraph.from_tuples"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_tuples">[docs]</a>    <span class="k">def</span> <span class="nf">from_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tuples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bulge_graph from a list of pair tuples. Unpaired</span>
<span class="sd">        nucleotides have a pairing partner of 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bulges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">tuples</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="c1">#We move along the backbone</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>
        <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>

        <span class="n">prev_from</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="n">prev_to</span> <span class="o">=</span> <span class="n">t2</span>

        <span class="n">start_from</span> <span class="o">=</span> <span class="n">prev_from</span>
        <span class="n">start_to</span> <span class="o">=</span> <span class="n">prev_to</span>
        <span class="n">last_paired</span> <span class="o">=</span> <span class="n">prev_from</span>

        <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">tuples</span><span class="p">:</span>
            <span class="p">(</span><span class="n">from_bp</span><span class="p">,</span> <span class="n">to_bp</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">to_bp</span> <span class="o">-</span> <span class="n">prev_to</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">prev_to</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">#adjacent basepairs on 3&#39; strand</span>
                <span class="c1"># stem</span>
                <span class="k">if</span> <span class="p">(((</span><span class="n">prev_to</span> <span class="o">-</span> <span class="n">prev_from</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">to_bp</span> <span class="o">-</span> <span class="n">from_bp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
                         <span class="p">(</span><span class="n">prev_to</span> <span class="o">-</span> <span class="n">prev_from</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">to_bp</span> <span class="o">-</span> <span class="n">from_bp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="n">to_bp</span> <span class="o">-</span> <span class="n">prev_to</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="p">(</span><span class="n">from_bp</span> <span class="o">-</span> <span class="n">prev_from</span><span class="p">)):</span>
                    <span class="p">(</span><span class="n">prev_from</span><span class="p">,</span> <span class="n">prev_to</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">from_bp</span><span class="p">,</span> <span class="n">to_bp</span><span class="p">)</span>
                    <span class="n">last_paired</span> <span class="o">=</span> <span class="n">from_bp</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">to_bp</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">prev_to</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># bulge</span>
                <span class="p">(</span><span class="n">prev_from</span><span class="p">,</span> <span class="n">prev_to</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">from_bp</span><span class="p">,</span> <span class="n">to_bp</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">prev_to</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_stem</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">start_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])),</span>
                                             <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">prev_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))]))</span>
                    <span class="k">if</span> <span class="n">new_stem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
                        <span class="n">stems</span> <span class="o">+=</span> <span class="p">[</span><span class="n">new_stem</span><span class="p">]</span>

                    <span class="n">last_paired</span> <span class="o">=</span> <span class="n">from_bp</span>
                    <span class="n">start_from</span> <span class="o">=</span> <span class="n">from_bp</span>
                    <span class="n">start_to</span> <span class="o">=</span> <span class="n">to_bp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_bulge</span> <span class="o">=</span> <span class="p">((</span><span class="n">last_paired</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">bulges</span> <span class="o">+=</span> <span class="p">[</span><span class="n">new_bulge</span><span class="p">]</span>

                    <span class="n">start_from</span> <span class="o">=</span> <span class="n">from_bp</span>
                    <span class="n">start_to</span> <span class="o">=</span> <span class="n">to_bp</span>

            <span class="n">prev_from</span> <span class="o">=</span> <span class="n">from_bp</span>
            <span class="n">prev_to</span> <span class="o">=</span> <span class="n">to_bp</span>

        <span class="c1"># Take care of the last element</span>
        <span class="k">if</span> <span class="n">prev_to</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_stem</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">start_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])),</span>
                                     <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">prev_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))]))</span>
            <span class="k">if</span> <span class="n">new_stem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
                <span class="n">stems</span> <span class="o">+=</span> <span class="p">[</span><span class="n">new_stem</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">prev_to</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_bulge</span> <span class="o">=</span> <span class="p">((</span><span class="n">last_paired</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">bulges</span> <span class="o">+=</span> <span class="p">[</span><span class="n">new_bulge</span><span class="p">]</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;from_tuples: stems </span><span class="si">%s</span><span class="s2">, bulges </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stems</span><span class="p">,</span> <span class="n">bulges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_stems_and_bulges</span><span class="p">(</span><span class="n">stems</span><span class="p">,</span> <span class="n">bulges</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_sort_defines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the defines of interior loops and stems so that the 5&#39; region</span>
<span class="sd">        is always first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">new_d</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_d</span>

    <span class="k">def</span> <span class="nf">_next_available_element_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param element_type: A single letter (&quot;t&quot;, &quot;f&quot;, &quot;s&quot;...)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">name</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">element_type</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span>
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>

    <span class="k">def</span> <span class="nf">_remove_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_element</span><span class="p">,</span> <span class="n">to_element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_element</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">to_element</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_element</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">from_element</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_add_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_element</span><span class="p">,</span> <span class="n">to_element</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">from_element</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">to_element</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">to_element</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">from_element</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_split_interior_loop_at_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splitpoint</span><span class="p">,</span> <span class="n">strand</span><span class="p">,</span> <span class="n">other_strand</span><span class="p">,</span> <span class="n">stems</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by self._split_at_cofold_cutpoints</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nextML</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
        <span class="n">nextA</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
        <span class="n">nextB</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">other_strand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">other_strand</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">nextML</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">nextML</span><span class="p">]</span> <span class="o">=</span> <span class="n">other_strand</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge</span><span class="p">(</span><span class="n">nextML</span><span class="p">,</span> <span class="n">stems</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge</span><span class="p">(</span><span class="n">nextML</span><span class="p">,</span> <span class="n">stems</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">splitpoint</span> <span class="o">&gt;=</span> <span class="n">strand</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">nextA</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">strand</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">splitpoint</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge</span><span class="p">(</span><span class="n">nextA</span><span class="p">,</span><span class="n">stems</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">splitpoint</span> <span class="o">&lt;</span> <span class="n">strand</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">nextB</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">splitpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">strand</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge</span><span class="p">(</span><span class="n">nextB</span><span class="p">,</span> <span class="n">stems</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>


    <span class="k">def</span> <span class="nf">_split_interior_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splitpoint</span><span class="p">,</span> <span class="n">element_left</span><span class="p">,</span> <span class="n">element_right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span><span class="p">:</span>
            <span class="n">iloop</span> <span class="o">=</span> <span class="n">element_left</span>
        <span class="k">elif</span> <span class="n">element_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span><span class="p">:</span>
            <span class="n">iloop</span><span class="o">=</span><span class="n">element_right</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">iloop</span><span class="p">)</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">forward_strand</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
        <span class="n">back_strand</span> <span class="o">=</span> <span class="p">[</span> <span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="p">]</span>
        <span class="k">if</span> <span class="n">forward_strand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">splitpoint</span> <span class="o">&lt;=</span> <span class="n">forward_strand</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1">#Split forward strand, relabel backwards strand to multiloop.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_split_interior_loop_at_side</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">,</span> <span class="n">forward_strand</span><span class="p">,</span> <span class="n">back_strand</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">back_strand</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span><span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">splitpoint</span> <span class="o">&lt;=</span> <span class="n">back_strand</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_split_interior_loop_at_side</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">,</span> <span class="n">back_strand</span><span class="p">,</span> <span class="n">forward_strand</span><span class="p">,</span> <span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">iloop</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">_zero_length_element_adj_position</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">):</span> <span class="c1">#TODO speed-up by caching</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the define with adjacent nucleotides for a zero-length element.</span>

<span class="sd">        Hereby we define that in cases of ambiuigity, the alphabetically first</span>
<span class="sd">        zero-length element comes at the lowest nucleotide position etc.</span>

<span class="sd">        :param elem: An element, e.g. &quot;m0&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span><span class="o">!=</span><span class="p">[]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> does not have zero length&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem</span><span class="p">))</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span> <span class="c1">#Hairpin</span>
            <span class="n">stem</span><span class="p">,</span> <span class="o">=</span> <span class="n">edges</span>
            <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">==</span><span class="n">define</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">define</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">define</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s2">&quot;Very strange zero-length hairpin </span><span class="si">{}</span><span class="s2"> &quot;</span>
                                          <span class="s2">&quot;(not?) connected to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">stem</span><span class="p">))</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span> <span class="o">=</span> <span class="n">edges</span>
            <span class="c1">#See if this is the only element connecting the two stems.</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">stem1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">stem2</span><span class="p">]</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Stems </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">, connected by </span><span class="si">%s</span><span class="s2"> have the following common edges: </span><span class="si">%s</span><span class="s2"> with defines </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                      <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">connections</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">x</span><span class="p">],</span> <span class="n">connections</span><span class="p">)))</span>
            <span class="n">zero_length_connections</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">conn</span><span class="p">]</span><span class="o">==</span><span class="p">[]:</span>
                    <span class="n">zero_length_connections</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
            <span class="k">assert</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">zero_length_connections</span>
            <span class="c1">#We DEFINE the 0-length connections to be sorted alphabetically by position</span>
            <span class="n">zero_length_connections</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">zero_length_coordinates</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">repeat</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
                <span class="c1">#log.debug(&quot;Is there a zero-length element between defines[%s][%d]==%d, and defines[%s][%d]==%d?&quot;,</span>
                <span class="c1">#          stem1, k, self.defines[stem1][k],</span>
                <span class="c1">#          stem2, l, self.defines[stem2][l] )</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">k</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem2</span><span class="p">][</span><span class="n">l</span><span class="p">])</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">k</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem2</span><span class="p">][</span><span class="n">l</span><span class="p">]]</span>
                    <span class="n">d</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Zero-length element found: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
                        <span class="n">zero_length_coordinates</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">d</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;But backbone-break encountered!&quot;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">zero_length_connections</span><span class="p">)</span><span class="o">!=</span><span class="nb">len</span><span class="p">(</span><span class="n">zero_length_coordinates</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">)</span>
                <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s2">&quot;Expecting stems </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2"> to have </span><span class="si">{}</span><span class="s2"> zero-length &quot;</span>
                                          <span class="s2">&quot;connections at nucleotide positions </span><span class="si">{}</span><span class="s2">, however, &quot;</span>
                                          <span class="s2">&quot;found </span><span class="si">{}</span><span class="s2"> elements: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span>
                                                            <span class="nb">len</span><span class="p">(</span><span class="n">zero_length_coordinates</span><span class="p">),</span>
                                                            <span class="n">zero_length_coordinates</span><span class="p">,</span>
                                                            <span class="nb">len</span><span class="p">(</span><span class="n">zero_length_connections</span><span class="p">),</span>
                                                            <span class="n">zero_length_connections</span><span class="p">))</span>
            <span class="n">zero_length_coordinates</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">zero_length_coordinates</span><span class="p">)</span>
            <span class="n">zero_length_coordinates</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">zero_length_connections</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">zero_length_coordinates</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s2">&quot;Very strange zero length bulge </span><span class="si">{}</span><span class="s2"> with more than 2 adjacent &quot;</span>
                                      <span class="s2">&quot;elements: </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">edges</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">_split_between_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splitpoint</span><span class="p">,</span> <span class="n">element_left</span><span class="p">,</span> <span class="n">element_right</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;mh&quot;</span><span class="p">:</span>
            <span class="n">next3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">element_left</span><span class="p">,</span> <span class="n">next3</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;h&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_remove_edge</span><span class="p">(</span><span class="n">next3</span><span class="p">,</span> <span class="n">element_right</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">element_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;mh&quot;</span><span class="p">:</span>
            <span class="n">next5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">element_right</span><span class="p">,</span> <span class="n">next5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">element_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;h&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_remove_edge</span><span class="p">(</span><span class="n">next5</span><span class="p">,</span> <span class="n">element_left</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span> <span class="ow">and</span> <span class="n">element_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span>
            <span class="c1">#Zero-length i or m element!</span>
            <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">element_left</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">element_right</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Cannot split at cofold cutpoint. Missing connection between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">element_left</span><span class="p">,</span> <span class="n">element_right</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">connection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span><span class="p">:</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connection</span><span class="p">]:</span>
                        <span class="n">ad_define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero_length_element_adj_position</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">ad_define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="n">splitpoint</span><span class="p">:</span>
                            <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Cannot split at cofold cutpoint. No suitable connection between </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">element_left</span><span class="p">,</span> <span class="n">element_right</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">connection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span><span class="p">:</span>
                <span class="c1">#Just remove it without replacement</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="n">connection</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span>
                <span class="c1">#Replace i by ml (this is then located on the other strand than the splitpoint)</span>
                <span class="n">nextML</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
                <span class="k">assert</span> <span class="n">nextML</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">connection</span><span class="p">,</span> <span class="n">nextML</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_split_inside_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splitpoint</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;hm&quot;</span><span class="p">:</span>
            <span class="n">from_</span><span class="p">,</span> <span class="n">to_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">]</span>
            <span class="n">stem_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">from_</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">stem_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">to_</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

            <span class="n">next3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">)</span>
            <span class="n">next5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">next3</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">from_</span><span class="p">,</span> <span class="n">splitpoint</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">next5</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="n">splitpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">to_</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge</span><span class="p">(</span><span class="n">stem_left</span><span class="p">,</span> <span class="n">next3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_add_edge</span><span class="p">(</span><span class="n">next5</span><span class="p">,</span> <span class="n">stem_right</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_split_inside_stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">splitpoint</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="k">assert</span> <span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span>
        <span class="k">if</span> <span class="n">splitpoint</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1">#Nothing needs to be done. 2 strands split at end</span>
            <span class="k">return</span>
        <span class="k">elif</span> <span class="n">splitpoint</span><span class="o">&lt;</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="c1"># Splitpoint in forward strand:</span>
            <span class="n">define1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">splitpoint</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span>
            <span class="n">define2</span> <span class="o">=</span> <span class="p">[</span> <span class="n">splitpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">splitpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Splitpoint in backwards strand:</span>
            <span class="n">define1</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">splitpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">splitpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span>
            <span class="n">define2</span> <span class="o">=</span> <span class="p">[</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">element</span><span class="p">][</span><span class="mi">2</span><span class="p">],</span> <span class="n">splitpoint</span><span class="p">]</span>
        <span class="n">edges1</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">edges2</span><span class="o">=</span><span class="p">[]</span>


        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">element</span><span class="p">]:</span>
            <span class="k">if</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span><span class="o">==</span><span class="n">define1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span><span class="o">==</span><span class="n">define1</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
                <span class="n">edges1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span><span class="o">==</span><span class="n">define2</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span><span class="o">==</span><span class="n">define2</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">edges2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edge </span><span class="si">{}</span><span class="s2">, with flanking nts </span><span class="si">{}</span><span class="s2">, define1 </span><span class="si">{}</span><span class="s2">, define2 </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">edge</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">edge</span><span class="p">),</span> <span class="n">define1</span><span class="p">,</span> <span class="n">define2</span><span class="p">))</span>
                <span class="k">assert</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">element</span><span class="p">)</span>
        <span class="n">nextS1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">nextS1</span><span class="p">]</span><span class="o">=</span><span class="n">define1</span>
        <span class="n">nextM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">nextM</span><span class="p">]</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">nextS2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_next_available_element_name</span><span class="p">(</span><span class="s2">&quot;s&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">nextS2</span><span class="p">]</span><span class="o">=</span><span class="n">define2</span>

        <span class="k">for</span> <span class="n">e1</span> <span class="ow">in</span> <span class="n">edges1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextS1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">edges2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e2</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">nextS2</span><span class="p">)</span>
        <span class="n">edges1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextM</span><span class="p">)</span>
        <span class="n">edges2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nextM</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">nextS1</span><span class="p">]</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">edges1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">nextS2</span><span class="p">]</span><span class="o">=</span><span class="nb">set</span><span class="p">(</span><span class="n">edges2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">nextM</span><span class="p">]</span><span class="o">=</span><span class="nb">set</span><span class="p">([</span><span class="n">nextS1</span><span class="p">,</span> <span class="n">nextS2</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_is_connected</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">start_node</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">known_nodes</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="n">start_node</span><span class="p">])</span>
        <span class="n">pending</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">start_node</span><span class="p">])</span>
        <span class="k">while</span> <span class="n">pending</span><span class="p">:</span>
            <span class="n">next_node</span> <span class="o">=</span> <span class="n">pending</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">next_node</span> <span class="ow">in</span> <span class="n">known_nodes</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">pending</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">next_node</span><span class="p">])</span>
            <span class="n">known_nodes</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">next_node</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Testing connectivity: connected component =?= all nodes:</span><span class="se">\n</span><span class="si">{}</span><span class="s2"> =?= </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">known_nodes</span><span class="p">)),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">())))))</span>
        <span class="k">return</span> <span class="n">known_nodes</span> <span class="o">==</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">_split_at_cofold_cutpoint</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Multiple sequences should not be connected along the backbone.</span>

<span class="sd">        We have constructed the bulge graph, as if they were connected along the backbone, so</span>
<span class="sd">        now we have to split it.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;_split_at_cofold_cutpoint: future breakpoints are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_backbone_will_break_after</span><span class="p">))</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span> <span class="o">==</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">splitpoint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_backbone_will_break_after</span><span class="p">:</span>
            <span class="n">element_left</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">)</span>
            <span class="n">element_right</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">splitpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;ft&quot;</span> <span class="ow">or</span> <span class="n">element_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;ft&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;t&quot;</span> <span class="ow">and</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;t&quot;</span><span class="p">:</span>
                    <span class="k">continue</span> <span class="c1"># Splitpoint already implemented</span>
                <span class="k">elif</span> <span class="n">element_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;f&quot;</span> <span class="ow">and</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;f&quot;</span><span class="p">:</span>
                    <span class="k">continue</span> <span class="c1"># Splitpoint already implemented</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#No cofold structure. First sequence is disconnected from rest</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Cannot create BulgeGraph. Found two sequences not &quot;</span>
                            <span class="s2">&quot;connected by any base-pair.&quot;</span><span class="p">)</span>
                    <span class="k">with</span> <span class="n">log_to_exception</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Trying to split between </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">element_left</span><span class="p">,</span> <span class="n">element_right</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="n">e</span>
                <span class="k">return</span>
            <span class="k">elif</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span> <span class="ow">or</span> <span class="n">element_right</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_split_interior_loop</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">,</span> <span class="n">element_left</span><span class="p">,</span> <span class="n">element_right</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">element_left</span> <span class="o">!=</span> <span class="n">element_right</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_split_between_elements</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">,</span> <span class="n">element_left</span><span class="p">,</span> <span class="n">element_right</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">element_left</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_split_inside_stem</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">,</span> <span class="n">element_left</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_split_inside_loop</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">,</span> <span class="n">element_left</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">splitpoint</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;After splitting (with adjacent):&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="kc">True</span><span class="p">)))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_connected</span><span class="p">():</span>
            <span class="k">raise</span> <span class="n">GraphConstructionError</span><span class="p">(</span><span class="s2">&quot;Cannot create BulgeGraph. Found two sequences not connected by any &quot;</span>
                             <span class="s2">&quot; base-pair.&quot;</span><span class="p">)</span>
<div class="viewcode-block" id="BulgeGraph.to_dotbracket_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_dotbracket_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_dotbracket_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the BulgeGraph representation to a dot-bracket string</span>
<span class="sd">        and return it.</span>

<span class="sd">        :return: A dot-bracket representation of this BulgeGraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_table</span><span class="p">()</span>
        <span class="n">db_string</span> <span class="o">=</span> <span class="n">fus</span><span class="o">.</span><span class="n">pairtable_to_dotbracket</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">breakpoint</span> <span class="ow">in</span> <span class="nb">reversed</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">)):</span>
            <span class="n">db_string</span> <span class="o">=</span> <span class="n">db_string</span><span class="p">[:</span><span class="n">breakpoint</span><span class="p">]</span><span class="o">+</span><span class="s2">&quot;&amp;&quot;</span><span class="o">+</span><span class="n">db_string</span><span class="p">[</span><span class="n">breakpoint</span><span class="p">:]</span>
        <span class="k">return</span> <span class="n">db_string</span></div>

<div class="viewcode-block" id="BulgeGraph.log"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.log">[docs]</a>    <span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">DEBUG</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">log_at_caller</span><span class="p">(</span><span class="n">log</span><span class="p">):</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">())</span>
            <span class="n">es</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_element_string</span><span class="p">(</span><span class="n">with_numbers</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">es</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">es</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="s2">&quot;DEFINES: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="s2">&quot;EDGES: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">pformat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.to_fasta_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_fasta_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_fasta_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output the BulgeGraph representation as a fast string of the</span>
<span class="sd">        format::</span>

<span class="sd">            &gt;id</span>
<span class="sd">            AACCCAA</span>
<span class="sd">            ((...))</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">output_string</span> <span class="o">+=</span> <span class="s2">&quot;&gt;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">output_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">output_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">output_string</span></div>

<div class="viewcode-block" id="BulgeGraph.from_bg_file"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_bg_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_bg_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bg_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load from a file containing a text-based representation</span>
<span class="sd">        of this BulgeGraph.</span>

<span class="sd">        :param bg_file: The filename.</span>
<span class="sd">        :return: No return value since the current structure is the one</span>
<span class="sd">                 being loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">bg_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">bg_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_bg_string</span><span class="p">(</span><span class="n">bg_string</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.from_bg_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.from_bg_string">[docs]</a>    <span class="k">def</span> <span class="nf">from_bg_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bg_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate this BulgeGraph from the string created by the method</span>
<span class="sd">        to_bg_string.</span>

<span class="sd">        :param bg_str: The string representation of this BugleGraph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">bg_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># blank line</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;define&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;connect&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;seq&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;from_bg_string: seq </span><span class="si">{}</span><span class="s2">, breakpoints </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">backbone_breaks_after</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;seq_ids&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">resid_from_str</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">chain_ids</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">res</span><span class="o">.</span><span class="n">chain</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain_ids</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">chain_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res</span><span class="o">.</span><span class="n">chain</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;SeqIds set to </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;info&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
        <span class="c1"># The breakpoints are only persisted at the seq and seq_id level.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;One of seq_ids or seq is mandatory.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">:</span>
            <span class="n">old_chain</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">resid</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">old_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">resid</span><span class="o">.</span><span class="n">chain</span><span class="o">!=</span><span class="n">old_chain</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">old_chain</span> <span class="o">=</span> <span class="n">resid</span><span class="o">.</span><span class="n">chain</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids_from_seq</span><span class="p">()</span></div>

<div class="viewcode-block" id="BulgeGraph.sorted_stem_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.sorted_stem_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_stem_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over a list of the stems sorted by the lowest numbered</span>
<span class="sd">        nucleotide in each stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">]</span>
        <span class="n">stems</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">s</span></div>

<div class="viewcode-block" id="BulgeGraph.sorted_element_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.sorted_element_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_element_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over a list of the coarse grained elements sorted by the lowest numbered</span>
<span class="sd">        nucleotide in each stem. Multiloops with no nucleotide coordinates come last.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="p">]</span>
        <span class="n">elements</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">else</span> <span class="mi">10000</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">e</span></div>

<div class="viewcode-block" id="BulgeGraph.is_single_stranded"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.is_single_stranded">[docs]</a>    <span class="k">def</span> <span class="nf">is_single_stranded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does this node represent a single-stranded region?</span>

<span class="sd">        Single stranded regions are five-prime and three-prime unpaired</span>
<span class="sd">        regions, multiloops, and hairpins</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Interior loops are never considered single stranded by this function.</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        :return: True if yes, False if no</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BulgeGraph.get_node_dimensions"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_node_dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimensions of a node.</span>

<span class="sd">        If the node is a stem, then the dimensions will be l where l is</span>
<span class="sd">        the length of the stem.</span>

<span class="sd">        Otherwise, see get_bulge_dimensions(node)</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        :return: A pair containing its dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            return (self.defines[node][1] - self.defines[node][0] + 1,</span>
<span class="sd">                    self.defines[node][1] - self.defines[node][0] + 1)</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.adjacent_stem_pairs_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.adjacent_stem_pairs_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">adjacent_stem_pairs_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all pairs of stems which are separated by some element.</span>

<span class="sd">        This will always yield triples of the form (s1, e1, s2) where s1 and</span>
<span class="sd">        s2 are the stem identifiers and e1 denotes the element that separates</span>
<span class="sd">        them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_bp_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_bp_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">stem_bp_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all the base pairs in the stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>
        <span class="n">stem_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stem_length</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.get_connected_residues"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_connected_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_connected_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">bulge</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nucleotides which are connected by the element separating</span>
<span class="sd">        s1 and s2. They should be adjacent stems.</span>

<span class="sd">        :param s1, s2: 2 adjacent stems</span>
<span class="sd">        :param bulge: Optional: The bulge seperating the two stems.</span>
<span class="sd">                      If s1 and s2 are connected by more than one element,</span>
<span class="sd">                      this has to be given, or a ValueError will be raised.</span>
<span class="sd">                      (useful for pseudoknots)</span>

<span class="sd">        The connected nucleotides are those which are spanned by a single</span>
<span class="sd">        interior loop or multiloop. In the case of an interior loop, this</span>
<span class="sd">        function will return a list of two tuples and in the case of multiloops</span>
<span class="sd">        if it will be a list of one tuple.</span>

<span class="sd">        If the two stems are not separated by a single element, then return</span>
<span class="sd">        an empty list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span>

        <span class="c1"># find out which edges they share</span>
        <span class="n">common_edges</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># not connected</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">bulge</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many connections between the stems. &quot;</span>
                            <span class="s2">&quot;Please provide the connectiong bulge you are interested in.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge</span> <span class="ow">and</span> <span class="n">bulge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">  does not connecty the stems </span><span class="si">{}</span><span class="s2"> and </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>

        <span class="c1"># the element linking the two stems</span>
        <span class="k">if</span> <span class="n">bulge</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">bulge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># find out the sides of the stems that face the bulge</span>
        <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">s1e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
        <span class="p">(</span><span class="n">s2b</span><span class="p">,</span> <span class="n">s2e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>

        <span class="c1"># get the nucleotides on the side facing the stem</span>
        <span class="n">s1_nucleotides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s1b</span><span class="p">)</span>
        <span class="n">s2_nucleotides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s2b</span><span class="p">)</span>

        <span class="c1"># find out the distances between all the nucleotides flanking</span>
        <span class="c1"># the bulge</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">s1_nucleotides</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">s2_nucleotides</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">+=</span> <span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n2</span> <span class="o">-</span> <span class="n">n1</span><span class="p">),</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)]</span>
        <span class="n">dists</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># return the ones which are closest to each other first</span>
        <span class="k">if</span> <span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]),</span> <span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span></div>

<div class="viewcode-block" id="BulgeGraph.get_link_direction"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_link_direction">[docs]</a>    <span class="k">def</span> <span class="nf">get_link_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the direction in which stem1 and stem2 are linked (by the bulge)</span>

<span class="sd">        :returns: 1 if the bulge connects stem1 with stem2 in forward direction (5&#39; to 3&#39;)</span>
<span class="sd">                  -1 otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connected_residues</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linked</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">linked</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="BulgeGraph.get_side_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_side_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">get_side_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nucleotide numbers on the given side of</span>
<span class="sd">        them stem. Side 0 corresponds to the 5&#39; end of the</span>
<span class="sd">        stem whereas as side 1 corresponds to the 3&#39; side</span>
<span class="sd">        of the stem.</span>

<span class="sd">        :param stem: The name of the stem</span>
<span class="sd">        :param side: Either 0 or 1, indicating the 5&#39; or 3&#39; end of the stem</span>
<span class="sd">        :return: A tuple of the nucleotide numbers on the given side of</span>
<span class="sd">                 the stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Invalid side (</span><span class="si">%d</span><span class="s2">) for the stem (</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">side</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.get_stem_edge"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_stem_edge">[docs]</a>    <span class="k">def</span> <span class="nf">get_stem_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the side of the stem that position is on.</span>
<span class="sd">        Side 0 corresponds to the 5&#39; pairing residues in the</span>
<span class="sd">        stem whereas as side 1 corresponds to the 3&#39; pairing</span>
<span class="sd">        residues in the stem.</span>
<span class="sd">        :param stem: The name of the stem</span>
<span class="sd">        :param pos: A position in the stem</span>
<span class="sd">        :return: 0 if pos on 5&#39; edge of stem</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fp_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tp_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">fp_edge</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">fp_side</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tp_side</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tp_edge</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">tp_side</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fp_side</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">fp_edge</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">tp_edge</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position (</span><span class="si">%d</span><span class="s2">) not in stem (</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">stem</span><span class="p">))</span></div>

    <span class="c1"># Seems to be unused. Consider deprecation</span>
<div class="viewcode-block" id="BulgeGraph.get_any_sides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_any_sides">[docs]</a>    <span class="k">def</span> <span class="nf">get_any_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the side of e1 that e2 is on. The only difference from the get_sides</span>
<span class="sd">        method is the fact that e1 does not have to be a stem.</span>

<span class="sd">        0 indicates that e2 is on the side with lower numbered</span>
<span class="sd">        nucleotides and 1 indicates that e2 is on the side with</span>
<span class="sd">        greater nucleotide numbers.</span>

<span class="sd">        :param e1: The name of the first element.</span>
<span class="sd">        :param e2: The name of the second element.</span>
<span class="sd">        :return: A tuple indicating the side of e1 adjacent to e2 and the side of e2</span>
<span class="sd">                 adjacent to e1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">e1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.get_sides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_sides">[docs]</a>    <span class="k">def</span> <span class="nf">get_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the side of s1 that is next to b.</span>

<span class="sd">        s1e -&gt; s1b -&gt; b</span>

<span class="sd">        :param s1: The stem.</span>
<span class="sd">        :param b: The bulge.</span>
<span class="sd">        :return: A tuple indicating which side is the one next to the bulge</span>
<span class="sd">                 and which is away from the bulge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="c1"># Special case if the bulge is a length 0 multiloop</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero_length_element_adj_position</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">s1d</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">s1d</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="o">==</span><span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s2">&quot;Faulty bulge </span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2"> connected to </span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s1d</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.get_sides_plus"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_sides_plus">[docs]</a>    <span class="k">def</span> <span class="nf">get_sides_plus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the side of s1 that is next to b.</span>

<span class="sd">        s1e -&gt; s1b -&gt; b</span>

<span class="sd">        :param s1: The stem.</span>
<span class="sd">        :param b: The bulge.</span>
<span class="sd">        :return: A tuple indicating the corner of the stem that connects</span>
<span class="sd">                 to the bulge as well as the corner of the bulge that connects</span>
<span class="sd">                 to the stem.</span>
<span class="sd">                 These sides are equivalent to the indices of the define.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">b</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s1</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;get_sides_plus expects stem to be connected to bulge!&quot;</span><span class="p">)</span>

        <span class="n">s1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zero_length_element_adj_position</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
            <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+=</span><span class="mi">1</span>
            <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-=</span><span class="mi">1</span>

        <span class="c1"># before the stem on the 5&#39; strand</span>
        <span class="k">if</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># after the stem on the 5&#39; strand</span>
        <span class="k">elif</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># before the stem on the 3&#39; strand</span>
        <span class="k">elif</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># after the stem on the 3&#39; strand</span>
        <span class="k">elif</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s2">&quot;Faulty bulge </span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2"> connected to </span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s1d</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_resn_to_stem_vres_side"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_resn_to_stem_vres_side">[docs]</a>    <span class="k">def</span> <span class="nf">stem_resn_to_stem_vres_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">res</span><span class="o">&lt;=</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">res</span><span class="o">&gt;=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">res</span><span class="o">-</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">side</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">res</span><span class="o">&lt;=</span><span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="k">assert</span> <span class="n">res</span><span class="o">&gt;=</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">res</span>
            <span class="n">side</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Residue </span><span class="si">{}</span><span class="s2"> not in stem </span><span class="si">{}</span><span class="s2"> with define </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pos</span><span class="p">,</span> <span class="n">side</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_side_vres_to_resn"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_side_vres_to_resn">[docs]</a>    <span class="k">def</span> <span class="nf">stem_side_vres_to_resn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">vres</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the residue number given the stem name, the strand (side) it&#39;s on</span>
<span class="sd">        and the virtual residue number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vres</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">vres</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">stem_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the stems in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.hloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.hloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">hloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the hairpin in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.mloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.mloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">mloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the multiloops in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.iloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.iloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">iloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the interior loops in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.floop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.floop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">floop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the name of the 5&#39; prime unpaired region if it is</span>
<span class="sd">        present in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.tloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.tloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">tloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the name of the 3&#39; prime unpaired region if it is</span>
<span class="sd">        present in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>
<div class="viewcode-block" id="BulgeGraph.pairing_partner"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.pairing_partner">[docs]</a>    <span class="k">def</span> <span class="nf">pairing_partner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nucleotide_number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the base pairing partner of the nucleotide at position</span>
<span class="sd">        nucleotide_number. If this nucleotide is unpaired, return None.</span>

<span class="sd">        :param nucleotide_number: The position of the query nucleotide in the</span>
<span class="sd">                                  sequence.</span>
<span class="sd">        :return: The number of the nucleotide base paired with the one at</span>
<span class="sd">                 position nucleotide_number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">r1</span> <span class="o">==</span> <span class="n">nucleotide_number</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">r2</span>
                <span class="k">elif</span> <span class="n">r2</span> <span class="o">==</span> <span class="n">nucleotide_number</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">r1</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.connections"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.connections">[docs]</a>    <span class="k">def</span> <span class="nf">connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the edges that connect to a bulge in a list form,</span>
<span class="sd">        sorted by lowest res number of the connection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># special case for stems at the beginning since there is no</span>
                <span class="c1"># adjacent nucleotide 0</span>
                <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">x</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">connections</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">bulge</span><span class="p">])</span>
        <span class="n">connections</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">connections</span></div>

<div class="viewcode-block" id="BulgeGraph.get_define_seq_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_define_seq_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_define_seq_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a list containing the sequences for the given define.</span>

<span class="sd">        :param d: The element name for which to get the sequences</span>
<span class="sd">        :param adjacent: Boolean. Include adjacent nucleotides (for single stranded RNA only)</span>
<span class="sd">        :return: A list containing the sequence(s) corresponding to the defines</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
            <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">]</span>
        <span class="n">seqs</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">define</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span> <span class="c1">#seq is 1-based!</span>
            <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">adjacent</span><span class="p">:</span>
                <span class="n">def_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">def_a</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">seqs</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="s2">&quot;&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">seqs</span></div>

<div class="viewcode-block" id="BulgeGraph.get_stem_direction"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_stem_direction">[docs]</a>    <span class="k">def</span> <span class="nf">get_stem_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return 0 if the lowest numbered residue in s1</span>
<span class="sd">        is lower than the lowest numbered residue in s2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;get_stem_direction is deprecated and will be removed in the future!&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="BulgeGraph.get_multiloop_side"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_multiloop_side">[docs]</a>    <span class="k">def</span> <span class="nf">get_multiloop_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find out which strand a multiloop is on. An example of a situation in</span>
<span class="sd">        which the loop can be on both sides can be seen in the three-stemmed</span>
<span class="sd">        structure below:</span>

<span class="sd">            (.().().)</span>

<span class="sd">        In this case, the first multiloop section comes off of the 5&#39; strand of</span>
<span class="sd">        the first stem (the prior stem is always the one with a lower numbered</span>
<span class="sd">        first residue). The second multiloop section comess of the 3&#39; strand of</span>
<span class="sd">        the second stem and the third loop comes off the 3&#39; strand of the third</span>
<span class="sd">        stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

    <span class="c1"># This function seems to be unused here. This code is possible duplicated somewhere.</span>
    <span class="c1"># Requires cleanup.</span>
<div class="viewcode-block" id="BulgeGraph.get_strand"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_strand">[docs]</a>    <span class="k">def</span> <span class="nf">get_strand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiloop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the strand on which this multiloop is located.</span>

<span class="sd">        :param multiloop: The name of the multiloop</span>
<span class="sd">        :return: 0 for being on the lower numbered strand and 1 for</span>
<span class="sd">                 being on the higher numbered strand.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">multiloop</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">multiloop</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="BulgeGraph.get_bulge_dimensions"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_bulge_dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">get_bulge_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimensions of the bulge.</span>

<span class="sd">        If it is single stranded it will be (x, -1) for h,t,f or (x, 1000) for m.</span>
<span class="sd">        Otherwise it will be (x, y).</span>

<span class="sd">        :param bulge: The name of the bulge.</span>
<span class="sd">        :return: A pair containing its dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">bulge</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># if this interior loop only has one unpaired region</span>
            <span class="c1"># then we have to find out if it&#39;s on the 5&#39; strand or</span>
            <span class="c1"># the 3&#39; strand</span>
            <span class="c1"># Example:</span>
            <span class="c1"># s1 1 3</span>
            <span class="c1"># 23 25</span>
            <span class="c1"># s2 5 10</span>
            <span class="c1"># 15 20</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="c1"># Multiloops are also pretty easy</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span> <span class="ow">or</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dims</span></div>

<div class="viewcode-block" id="BulgeGraph.get_node_from_residue_num"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_node_from_residue_num">[docs]</a>    <span class="nd">@profile</span>
    <span class="k">def</span> <span class="nf">get_node_from_residue_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_num</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the defines and see which one encompasses this base.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">seq_id</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_range_iterator</span><span class="p">(</span><span class="n">key</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">base_num</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">base_num</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="k">return</span> <span class="n">key</span>

        <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="s2">&quot;Base number </span><span class="si">{}</span><span class="s2"> not found in the defines </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">base_num</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.get_length"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_length">[docs]</a>    <span class="k">def</span> <span class="nf">get_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the minimum length of a vertex.</span>

<span class="sd">        If it&#39;s a stem, then the result is its length (in base pairs).</span>

<span class="sd">        If it&#39;s a bulge, then the length is the smaller of it&#39;s dimensions.</span>

<span class="sd">        :param vertex: The name of the vertex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">vertex</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.get_flanking_region"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_flanking_region">[docs]</a>    <span class="k">def</span> <span class="nf">get_flanking_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If a bulge is flanked by stems, return the lowest residue number</span>
<span class="sd">        of the previous stem and the highest residue number of the next</span>
<span class="sd">        stem.</span>

<span class="sd">        :param bulge_name: The name of the bulge</span>
<span class="sd">        :param side: The side of the bulge (indicating the strand)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># interior loop</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multiloop_side</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]</span>

            <span class="n">ends</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># go through the two sides and stems and pick</span>
            <span class="c1"># the other end of the same strand</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ss</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">GraphIntegrityError</span><span class="p">(</span><span class="s2">&quot;Weird multiloop sides: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                    <span class="n">bulge_name</span><span class="p">)</span>

            <span class="n">ends</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ends</span><span class="p">)</span>
            <span class="c1"># multiloop</span>

        <span class="k">return</span> <span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="BulgeGraph.get_flanking_sequence"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_flanking_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">get_flanking_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No sequence present in the bulge_graph: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_flanking_region</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">m1</span><span class="p">:</span><span class="n">m2</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="c1">#1 based indexing</span></div>

<div class="viewcode-block" id="BulgeGraph.get_flanking_handles"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_flanking_handles">[docs]</a>    <span class="k">def</span> <span class="nf">get_flanking_handles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the indices of the residues for fitting bulge regions.</span>

<span class="sd">        So if there is a loop like so (between residues 7 and 16)::</span>

<span class="sd">          (((...))))</span>
<span class="sd">          7890123456</span>
<span class="sd">            ^   ^</span>

<span class="sd">        Then residues 9 and 13 will be used as the handles against which</span>
<span class="sd">        to align the fitted region.</span>

<span class="sd">        In the fitted region, the residues (2,6) will be the ones that will</span>
<span class="sd">        be aligned to the handles.</span>

<span class="sd">        :return: (orig_chain_res1, orig_chain_res1, flanking_res1, flanking_res2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_flanking_region</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multiloop_side</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">s2</span><span class="p">[</span><span class="n">sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
            <span class="n">ab</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># probably still have to include the 5&#39; and 3&#39; regions, but that</span>
        <span class="c1"># will come a little later</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.are_adjacent_stems"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.are_adjacent_stems">[docs]</a>    <span class="k">def</span> <span class="nf">are_adjacent_stems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">multiloops_count</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Are two stems separated by only one element. If multiloops should not</span>
<span class="sd">        count as edges, then the appropriate parameter should be set.</span>

<span class="sd">        :param s1: The name of the first stem</span>
<span class="sd">        :param s2: The name of the second stem</span>
<span class="sd">        :param multiloops_count: Whether to count multiloops as an edge linking</span>
<span class="sd">                                 two stems</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">multiloops_count</span> <span class="ow">and</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BulgeGraph.random_subgraph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.random_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">random_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subgraph_length</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random subgraph of this graph.</span>

<span class="sd">        :return: A list containing a the nodes comprising a random subgraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subgraph_length</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">subgraph_length</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="n">start_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">curr_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">next_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_node</span><span class="p">]</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">curr_length</span> <span class="o">&lt;</span> <span class="n">subgraph_length</span><span class="p">:</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">next_nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span> <span class="ow">or</span> <span class="n">curr_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="c1"># if it&#39;s an interior loop or a multiloop, then we have to</span>
                <span class="c1"># add the adjacent stems</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">new_graph</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">next_nodes</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
                    <span class="n">curr_length</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
            <span class="n">next_nodes</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">curr_node</span><span class="p">])</span>
            <span class="n">next_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">next_nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">]</span>
            <span class="n">new_graph</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_node</span><span class="p">]</span>
            <span class="n">curr_length</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># self.element_length(curr_node)</span>

        <span class="k">return</span> <span class="n">new_graph</span></div>

<div class="viewcode-block" id="BulgeGraph.get_resseqs"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_resseqs">[docs]</a>    <span class="k">def</span> <span class="nf">get_resseqs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the pdb ids of the nucleotides in this define.</span>

<span class="sd">        :param define: The name of this element.</span>
<span class="sd">        :param: Return a tuple of two arrays containing the residue ids</span>
<span class="sd">                on each strand</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">define</span><span class="p">])]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">strand_resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seq_ids</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">res_id</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">except</span> <span class="ne">IndexError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                        <span class="k">with</span> <span class="n">log_to_exception</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                            <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Index </span><span class="si">%s</span><span class="s2"> not in seq_ids.&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
                        <span class="k">raise</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;chain&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="n">res_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chain</span>
                    <span class="n">strand_resnames</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">res_id</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">strand_resnames</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

            <span class="n">resnames</span> <span class="o">+=</span> <span class="p">[</span><span class="n">strand_resnames</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">resnames</span></div>

    <span class="k">def</span> <span class="nf">_insert_cutpoints_into_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">breakpoint</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">backbone_breaks_after</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Inserting breakpoint into seq &#39;</span><span class="si">{}</span><span class="s2">&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">subseq_with_cutpoints</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">breakpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="s2">&quot;&amp;&quot;</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">subseq_with_cutpoints</span><span class="p">(</span><span class="n">breakpoint</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;seq now has </span><span class="si">{}</span><span class="s2"> cutpoints&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="o">.</span><span class="n">count</span><span class="p">(</span><span class="s1">&#39;&amp;&#39;</span><span class="p">)))</span>



    <span class="c1"># This function seems to be dead code, but might be useful in the future.</span>
    <span class="c1"># Consider adding this to whitelist.py</span>
<div class="viewcode-block" id="BulgeGraph.connected_stem_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.connected_stem_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">connected_stem_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all pairs of connected stems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloop_iterator</span><span class="p">()):</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">edge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.sorted_edges_for_mst"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.sorted_edges_for_mst">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_edges_for_mst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep track of all linked nodes. Used for the generation of the minimal spanning tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">priority</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">(),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">iloop_iterator</span><span class="p">()),</span>
                       <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">priority</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_dimensions</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span><span class="n">x</span><span class="p">)</span> <span class="p">)</span>
        <span class="k">return</span> <span class="n">edges</span></div>
<div class="viewcode-block" id="BulgeGraph.get_mst"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_mst">[docs]</a>    <span class="k">def</span> <span class="nf">get_mst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a minimum spanning tree from this BulgeGraph. This is useful</span>
<span class="sd">        for constructing a structure where each section of a multiloop is</span>
<span class="sd">        sampled independently and we want to introduce a break at the largest</span>
<span class="sd">        multiloop section.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># keep track of all linked nodes</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_edges_for_mst</span><span class="p">()</span>

        <span class="n">mst</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">floop_iterator</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">tloop_iterator</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">hloop_iterator</span><span class="p">()))</span>

        <span class="c1"># store all of the disconnected trees</span>
        <span class="n">forest</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">([</span><span class="n">m</span><span class="p">])</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mst</span><span class="p">]</span>

        <span class="c1"># get the tree containing a particular element</span>
        <span class="k">def</span> <span class="nf">get_tree</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">forest</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">t</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">conn</span><span class="p">])</span>

            <span class="c1"># get the trees containing the neighbors of this node</span>
            <span class="c1"># the node should be an interior loop or multiloop so</span>
            <span class="c1"># the neighbors should necessarily be stems, 5&#39; or 3&#39;</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">get_tree</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">get_tree</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if this node connects two disparate trees, then add it to the mst</span>
                <span class="n">new_tree</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
                <span class="n">forest</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                <span class="n">forest</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
                <span class="n">forest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tree</span><span class="p">)</span>

                <span class="n">mst</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mst</span></div>

<div class="viewcode-block" id="BulgeGraph.traverse_graph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.traverse_graph">[docs]</a>    <span class="k">def</span> <span class="nf">traverse_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Traverse the graph to get the angle types. The angle type depends on</span>
<span class="sd">        which corners of the stem are connected by the multiloop or internal</span>
<span class="sd">        loop.</span>

<span class="sd">        :returns: A list of triples (stem, loop, stem)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mst</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mst</span><span class="p">()</span>

        <span class="n">build_order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;s0&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">)]</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;s0&#39;</span><span class="p">])</span>
        <span class="n">build_paths</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_visit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">to_visit</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_dimensions</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span> <span class="ow">and</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mst</span><span class="p">:</span>
                    <span class="c1"># make sure the node hasn&#39;t been visited</span>
                    <span class="c1"># and is in the minimum spanning tree</span>
                    <span class="n">to_visit</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>

                    <span class="n">build_paths</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">build_paths</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+=</span> <span class="n">build_paths</span><span class="p">[</span><span class="n">current</span><span class="p">]</span>

                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># multiloop or interior loop</span>

                <span class="c1"># overkill method of getting the stem that isn&#39;t</span>
                <span class="c1"># equal to prev</span>
                <span class="n">next_stem</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">],</span>
                                           <span class="nb">set</span><span class="p">([</span><span class="n">prev</span><span class="p">]))</span>
                <span class="n">build_order</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">prev</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">next_stem</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="c1"># If pseudoknots exist, the direction is not always 0!</span>
                <span class="c1"># assert self.get_stem_direction(prev, build_order[-1][2])==0</span>
		<span class="c1"># does not hold for pseudoknots!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="o">=</span> <span class="n">build_order</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ang_type</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">return</span> <span class="n">build_order</span></div>

<div class="viewcode-block" id="BulgeGraph.set_angle_types"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.set_angle_types">[docs]</a>    <span class="k">def</span> <span class="nf">set_angle_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill in the angle types based on the build order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.get_angle_type"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_angle_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_angle_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">,</span> <span class="n">allow_broken</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return what type of angle this bulge is, based on the way this</span>
<span class="sd">        would be built using a breadth-first traversal along the minimum</span>
<span class="sd">        spanning tree.</span>

<span class="sd">        :param allow_broken: How to treat broken multiloop segments.</span>
<span class="sd">        </span>
<span class="sd">                             *  False (default): Return None</span>
<span class="sd">                             *  The string &quot;bo&quot; or &quot;build_order&quot;: Return the</span>
<span class="sd">                                angle type according to the build-order</span>
<span class="sd">                                (i.e. from the first built stem to the last-built stem)</span>
<span class="sd">                             *  True: Return the angle_type from the stem with</span>
<span class="sd">                                lower nt number to the stem with higher nt number.</span>
<span class="sd">                                In forgi 2.0 this will be removed and the behavior of &quot;bo&quot;</span>
<span class="sd">                                will be used instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_angle_types</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">bulge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span><span class="p">[</span><span class="n">bulge</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">allow_broken</span> <span class="o">==</span> <span class="s2">&quot;bo&quot;</span> <span class="ow">or</span> <span class="n">allow_broken</span> <span class="o">==</span><span class="s2">&quot; build_order&quot;</span><span class="p">:</span>
                <span class="n">stems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">[</span><span class="n">bulge</span><span class="p">]</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">stems</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">buildorder_of</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">allow_broken</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The behavior of &#39;allow_broken=True&#39; will change &quot;</span>
                              <span class="s2">&quot;to reflect the behavior of &#39;allow_broken=</span><span class="se">\&quot;</span><span class="s2">bo</span><span class="se">\&quot;</span><span class="s2">&#39; &quot;</span>
                              <span class="s2">&quot;with forgi version 2.0&quot;</span><span class="p">,</span> <span class="ne">DeprecationWarning</span><span class="p">)</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge</span><span class="p">)</span> <span class="c1">#Ordered by nucleotide number</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.buildorder_of"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.buildorder_of">[docs]</a>    <span class="k">def</span> <span class="nf">buildorder_of</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index into build_order where the element FIRST appears.</span>

<span class="sd">        :param element: Element name, a string. e.g. &quot;m0&quot; or &quot;s0&quot;</span>
<span class="sd">        :returns: An index into self.build_order or None, if the element is not</span>
<span class="sd">                  part of the build_order (e.g. hairpin loops)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">elements</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">build_order</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">i</span>
        <span class="k">return</span> <span class="kc">None</span></div>


<div class="viewcode-block" id="BulgeGraph.is_loop_pseudoknot"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.is_loop_pseudoknot">[docs]</a>    <span class="k">def</span> <span class="nf">is_loop_pseudoknot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is a particular loop a pseudoknot?</span>

<span class="sd">        :param loop: A list of elements that are part of the loop (only m,f and t elements).</span>

<span class="sd">        :return: Either True or false</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;pseudoknot&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">describe_multiloop</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.iter_elements_along_backbone"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.iter_elements_along_backbone">[docs]</a>    <span class="k">def</span> <span class="nf">iter_elements_along_backbone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">startpos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate all coarse grained elements along the backbone.</span>

<span class="sd">        Note that stems are yielded twice (for forward and backward strand).</span>
<span class="sd">        Interior loops may be yielded twice or once (if one side has no nucleotide)</span>

<span class="sd">        :param startpos: The nucleotide position at which tio start</span>
<span class="sd">        :yields: Coarse grained element names, like &quot;s0&quot;, &quot;i0&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nuc</span> <span class="o">=</span> <span class="n">startpos</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">nuc</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span><span class="o">==</span><span class="mi">0</span>
            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;Empty Graph&quot;</span><span class="p">)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">node</span>
            <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;si&quot;</span><span class="p">:</span> <span class="c1">#The strand matters</span>
                <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span><span class="p">:</span>
                    <span class="n">strand</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_stem_edge</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nuc</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">strand</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1">#forward</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nuc_at_stem_side</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nuc_at_stem_side</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">,</span><span class="n">f3</span><span class="p">,</span><span class="n">f4</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">f1</span><span class="o">&lt;</span><span class="n">nuc</span><span class="o">&lt;</span><span class="n">f2</span><span class="p">:</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="n">f2</span>
                    <span class="k">elif</span> <span class="n">f3</span><span class="o">&lt;</span><span class="n">nuc</span><span class="o">&lt;</span><span class="n">f4</span><span class="p">:</span>
                        <span class="n">nuc</span> <span class="o">=</span> <span class="n">f4</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">assert</span> <span class="kc">False</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">next_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">nuc</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;End of chain reached&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#We need to make sure there is no 0-length multiloop between the two stems.</span>
                    <span class="n">intersect</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span>
                    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">intersect</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">el</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;m&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">==</span><span class="p">[]:</span>
                            <span class="c1">#In case of this structuire ([)], there are 2 0-length multiloops between the two stems.</span>
                            <span class="n">prev_nuc</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">el</span><span class="p">))</span>
                            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">prev_nuc</span><span class="p">)</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                                <span class="n">node</span> <span class="o">=</span> <span class="n">el</span>
                                <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">node</span> <span class="o">=</span> <span class="n">next_node</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span> <span class="c1">#Too few values to unpack</span>
                    <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;f&quot;</span><span class="p">:</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                            <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;Single stranded-only RNA&quot;</span><span class="p">)</span>
                        <span class="n">nuc</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flanking_nucleotides</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">(</span><span class="s2">&quot;End of chain reached&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">f1</span><span class="o">&gt;</span><span class="n">f2</span><span class="p">:</span>
                        <span class="n">nuc</span><span class="o">=</span><span class="n">f1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">nuc</span><span class="o">=</span><span class="n">f2</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Next nuc is </span><span class="si">{}</span><span class="s2"> (</span><span class="si">{}</span><span class="s2">)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">nuc</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">nuc</span><span class="p">)))</span>
                <span class="n">node</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">nuc</span><span class="p">)</span></div>



<div class="viewcode-block" id="BulgeGraph.to_networkx"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.to_networkx">[docs]</a>    <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this graph to a networkx representation. This representation</span>
<span class="sd">        will contain all of the nucleotides as nodes and all of the base pairs</span>
<span class="sd">        as edges as well as the adjacent nucleotides.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">residues</span> <span class="o">+=</span> <span class="p">[</span><span class="n">r</span><span class="p">]</span>

        <span class="c1">#Add links along the backbone</span>
        <span class="n">residues</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">r</span>

        <span class="c1">#Add links along basepairs</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="BulgeGraph.remove_pseudoknots"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.remove_pseudoknots">[docs]</a>    <span class="k">def</span> <span class="nf">remove_pseudoknots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all of the pseudoknots using the knotted2nested.py script.</span>

<span class="sd">        :return: A list of base-pairs that were removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># remove unpaired bases and redundant pairs (i.e. (2,3) and (3,2))</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_tuples</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pairs</span><span class="p">))</span>

        <span class="kn">import</span> <span class="nn">forgi._k2n_standalone.knots</span> <span class="k">as</span> <span class="nn">fakk</span>

        <span class="n">pk_function</span> <span class="o">=</span> <span class="n">fakk</span><span class="o">.</span><span class="n">eg</span>
        <span class="n">nested_pairs</span><span class="p">,</span> <span class="n">removed_pairs</span> <span class="o">=</span> <span class="n">pk_function</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">return_removed</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_base_pairs</span><span class="p">(</span><span class="n">removed_pairs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">removed_pairs</span></div>

    <span class="c1">#Seems to be unused...</span>
<div class="viewcode-block" id="BulgeGraph.ss_distance"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.ss_distance">[docs]</a>    <span class="k">def</span> <span class="nf">ss_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the distance between two elements (e1, e2)</span>
<span class="sd">        along the secondary structure. The distance only starts</span>
<span class="sd">        at the edge of each element, and is the closest distance</span>
<span class="sd">        between the two elements.</span>

<span class="sd">        :param e1: The name of the first element</span>
<span class="sd">        :param e2: The name of the second element</span>
<span class="sd">        :return: The integer distance between the two along the secondary</span>
<span class="sd">                 structure.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># get the edge nucleotides</span>
        <span class="c1"># thanks to:</span>
        <span class="c1"># http://stackoverflow.com/questions/2154249/identify-groups-of-continuous-numbers-in-a-list</span>
        <span class="c1"># we get the edges, except that they might be one too close because we use adjacent</span>
        <span class="c1"># nucleotides, nevertheless we&#39;ll take care of that later</span>
        <span class="n">d1_corners</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d2_corners</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span>
                                  <span class="k">lambda</span> <span class="n">index_item</span><span class="p">:</span> <span class="n">index_item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_item</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">group</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">oper</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">group</span><span class="p">))</span>
            <span class="n">d1_corners</span> <span class="o">+=</span> <span class="n">group</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">)),</span>
                                  <span class="k">lambda</span> <span class="n">index_item</span><span class="p">:</span> <span class="n">index_item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_item</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">group</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">oper</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">group</span><span class="p">))</span>
            <span class="n">d2_corners</span> <span class="o">+=</span> <span class="n">group</span>

        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
        <span class="n">path_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">d1_corners</span><span class="p">,</span> <span class="n">d2_corners</span><span class="p">):</span>
            <span class="n">path_lengths</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">e1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e2</span><span class="p">]:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># make some exceptions for edges which have length 0</span>
        <span class="n">common_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e2</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">common_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="BulgeGraph.shortest_path"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.shortest_path">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determine the shortest path between two elements (e1, e2)</span>
<span class="sd">        along the secondary structure.</span>

<span class="sd">        :param e1: The name of the first element</span>
<span class="sd">        :param e2: The name of the second element</span>
<span class="sd">        :return: A list of the element names along the shortest path</span>

<span class="sd">        &#39;&#39;&#39;</span>

        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>

        <span class="c1"># Get residue numbers of source and targets, for shortest_path in nx</span>
        <span class="n">source</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="p">[</span><span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e1</span><span class="p">)]</span> <span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="p">[</span><span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e2</span><span class="p">)]</span> <span class="p">)</span>

        <span class="c1"># Get nx graph, and the shortest path</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
        <span class="n">nx_sp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>

        <span class="c1"># Convert shortest path of residue numbers to a shortest path of node names</span>
        <span class="n">sp</span><span class="p">,</span> <span class="n">sp_set</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Use set to keep track of additions for faster lookup</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">nx_sp</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
                <span class="n">sp_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="c1"># assymetric bulges with a length of 0 on 1 side are missed,</span>
        <span class="c1"># two adjacent stems indicate a bulge with length 0 along the path</span>
        <span class="n">shortest_path</span><span class="p">,</span> <span class="n">sp_set</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">traversal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span> <span class="c1"># Connections are ordered compared to connected_stem_iterator()</span>

        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span> <span class="c1"># Iterate through adjacent pairs of elements in the list</span>
            <span class="k">if</span> <span class="n">n1</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n2</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">):</span> <span class="c1"># If two elements are both stems</span>
                <span class="n">connection</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">conn</span> <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">traversal</span> <span class="k">if</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">conn</span> <span class="ow">and</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">conn</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># Find their connection in graph traversal</span>
                <span class="k">if</span> <span class="n">connection</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">connection</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span> <span class="c1">#If we&#39;re moving &#39;backwards&#39; on the traversal</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">connection</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
                        <span class="n">sp_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                        <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
                    <span class="n">sp_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
                    <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
            <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="c1"># Append last item in path</span>

        <span class="k">return</span> <span class="n">shortest_path</span></div>

<div class="viewcode-block" id="BulgeGraph.get_position_in_element"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_position_in_element">[docs]</a>    <span class="k">def</span> <span class="nf">get_position_in_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resnum</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the position of the residue in the cg-element and the length of the element.</span>

<span class="sd">        :param resnum: An integer. The 1-based position in the total sequence.</span>
<span class="sd">        :returns: A tuple (p,l) where p is the position of the residue in the cg-element</span>
<span class="sd">                  (0-based for stems, 1-based for loops) and p/l gives a measure for the position</span>
<span class="sd">                  of the residue along the cg-element&#39;s axis (0 means at cg.coords[elem][0],</span>
<span class="sd">                  1 at cg.coords[elem][1] and 0.5 exactely in the middle of these two. )</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">resnum</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">resnum</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">3</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="n">s0</span><span class="p">,</span><span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">resnum</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">pos1</span> <span class="o">=</span> <span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pos2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>


        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">resnum</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">resnum</span> <span class="o">-</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">2</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="BulgeGraph.connected"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.connected">[docs]</a>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Are the nucleotides n1 and n2 connected?</span>

<span class="sd">        :param n1: A node in the BulgeGraph</span>
<span class="sd">        :param n2: Another node in the BulgeGraph</span>
<span class="sd">        :return: True or False indicating whether they are connected.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">n1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">n2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># two multiloops can be considered connected if they both</span>
        <span class="c1"># link to the same side of the same stem</span>
        <span class="k">if</span> <span class="n">n1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">and</span> <span class="n">n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">common_stems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_stems</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="n">common_stem</span> <span class="o">=</span> <span class="n">common_stems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">b1c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">common_stem</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s2c</span><span class="p">,</span> <span class="n">b1c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">common_stem</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="BulgeGraph.flanking_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.flanking_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">flanking_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the nucleotides directly flanking an element.</span>

<span class="sd">        :param d: the name of the element</span>
<span class="sd">        :return: a list of nucleotides</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">set_adjacent</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">set_not_adjacent</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">set_adjacent</span> <span class="o">-</span> <span class="n">set_not_adjacent</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.min_max_bp_distance"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.min_max_bp_distance">[docs]</a>    <span class="k">def</span> <span class="nf">min_max_bp_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the minimum and maximum base pair distance between</span>
<span class="sd">        these two elements.</span>

<span class="sd">        If they are connected, the minimum distance will be 1.</span>
<span class="sd">        The maximum will be 1 + length(e1) + length(e1)</span>

<span class="sd">        :param e1: The name of the first element</span>
<span class="sd">        :param e2: The name of the second element</span>
<span class="sd">        :return:   A tuple containing the minimum and maximum distance between</span>
<span class="sd">                   the two elements.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">:</span> <span class="c1">#Shortcut if cached.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">[(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">)]</span>

        <span class="n">min_bp</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
        <span class="n">max_bp</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="c1">#col.defaultdict(dict)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">floyd_warshall_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span><span class="p">))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">n1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span>
                                               <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e1</span><span class="p">]),</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e2</span><span class="p">])):</span>
            <span class="c1">#d =  nx.dijkstra_path_length(self.nx_graph, f1, f2)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">min_bp</span><span class="p">:</span>
                <span class="n">min_bp</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">max_bp</span><span class="p">:</span>
                <span class="n">max_bp</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">[(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_bp</span><span class="p">,</span> <span class="n">max_bp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">[(</span><span class="n">e2</span><span class="p">,</span><span class="n">e1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_bp</span><span class="p">,</span> <span class="n">max_bp</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">min_bp</span><span class="p">,</span> <span class="n">max_bp</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.nd_define_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.nd_define_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">nd_define_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Iterate over defines which contain some nucleotides.</span>

<span class="sd">        :return: An iterator over all defines which contain some</span>
<span class="sd">                 nucleotides.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.get_domains"><a class="viewcode-back" href="../../../apidoc/forgi.graph.bulge_graph.html#forgi.graph.bulge_graph.BulgeGraph.get_domains">[docs]</a>    <span class="k">def</span> <span class="nf">get_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get secondary structure domains.</span>

<span class="sd">        Currently domains found are:</span>
<span class="sd">          * multiloops (without any connected stems)</span>
<span class="sd">          * rods: stretches of stems + interior loops (without branching), with trailing hairpins</span>
<span class="sd">          * pseudoknots</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">domains</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">multiloops</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_mlonly_multiloops</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ml</span> <span class="ow">in</span> <span class="n">multiloops</span><span class="p">:</span>
            <span class="n">ml</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loop_pseudoknot</span><span class="p">(</span><span class="n">ml</span><span class="p">):</span>
                <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;pseudoknots&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;multiloops&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>

        <span class="n">doublestr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">doublestr</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">region</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="n">region</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">):</span>
                    <span class="n">curr_region</span> <span class="o">=</span> <span class="n">region</span>
                    <span class="n">curr_region</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">doublestr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">s</span><span class="p">]))</span>
                <span class="n">curr_region</span> <span class="o">=</span> <span class="n">doublestr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;sih&quot;</span><span class="p">:</span>
                    <span class="n">curr_region</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1">#print(doublestr)</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">doublestr</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">reg1</span> <span class="o">&amp;</span> <span class="n">reg2</span><span class="p">:</span>
                    <span class="n">doublestr</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">reg1</span><span class="p">)</span>
                    <span class="n">doublestr</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">reg2</span><span class="p">)</span>
                    <span class="n">doublestr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg1</span><span class="o">|</span><span class="n">reg2</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>

        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">doublestr</span><span class="p">:</span>
            <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;rods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">region</span><span class="p">))</span>
        <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;pseudoknots&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;multiloops&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;rods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1">#print(domains)</span>
        <span class="k">return</span> <span class="n">domains</span></div></div>
</pre></div>

      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016 Peter Kerpedjiev &lt;pkerp@tbi.univie.ac.at&gt;; 2015,2016 Bernhard Thiel &lt;thiel@tbi.univie.ac.at&gt;.
      Last updated on Feb 06, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>