
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>forgi.graph.bulge_graph &mdash; forgi 0.4 documentation</title>
    
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.4',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/theme_extras.js"></script>
    <link rel="top" title="forgi 0.4 documentation" href="../../../index.html" />
    <link rel="up" title="forgi" href="../../forgi.html" /> 
  </head>
  <body role="document">
      <div class="header"><h1 class="heading"><a href="../../../index.html">
          <span>forgi 0.4 documentation</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for forgi.graph.bulge_graph</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="kn">import</span> <span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">chr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">hex</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span>
                      <span class="nb">map</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span> <span class="nb">oct</span><span class="p">,</span> <span class="nb">pow</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">round</span><span class="p">,</span>
                      <span class="nb">str</span><span class="p">,</span> <span class="nb">super</span><span class="p">,</span> <span class="nb">zip</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;bulge_graph.py: A graph representation of RNA secondary structure based</span>
<span class="sd">   on its decomposition into primitive structure types: stems, hairpins,</span>
<span class="sd">   interior loops, multiloops, etc...&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Peter Kerpedjiev, Bernhard Thiel&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2012 - 2016&quot;</span>
<span class="n">__license__</span> <span class="o">=</span> <span class="s2">&quot;GNU Affero GPL v 3.0&quot;</span>
<span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.4&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Peter Kerpedjiev, Bernhard Thiel&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;pkerp@tbi.univie.ac.at, thiel@tbi.univie.ac.at&quot;</span>

<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">collections</span> <span class="kn">as</span> <span class="nn">col</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="kn">as</span> <span class="nn">it</span>
<span class="kn">from</span> <span class="nn">..aux.k2n_standalone</span> <span class="kn">import</span> <span class="n">knotted2nested</span> <span class="k">as</span> <span class="n">fak</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="kn">import</span> <span class="n">debug</span> <span class="k">as</span> <span class="n">fud</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="kn">import</span> <span class="n">stuff</span> <span class="k">as</span> <span class="n">fus</span>
<span class="kn">from</span> <span class="nn">..threedee.utilities</span> <span class="kn">import</span> <span class="n">mcannotate</span> <span class="k">as</span> <span class="n">ftum</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">operator</span> <span class="kn">as</span> <span class="nn">oper</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>

<div class="viewcode-block" id="add_bulge"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.add_bulge">[docs]</a><span class="k">def</span> <span class="nf">add_bulge</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="n">bulge</span><span class="p">,</span> <span class="n">context</span><span class="p">,</span> <span class="n">message</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A wrapper for a simple dictionary addition</span>
<span class="sd">    Added so that debugging can be made easier</span>

<span class="sd">    :param bulges:</span>
<span class="sd">    :param bulge:</span>
<span class="sd">    :param context:</span>
<span class="sd">    :param message:</span>
<span class="sd">    :return:</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># bulge = (context, bulge)</span>
    <span class="n">bulges</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="n">bulges</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span><span class="n">bulge</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">bulges</span></div>


<div class="viewcode-block" id="from_id_seq_struct"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.from_id_seq_struct">[docs]</a><span class="k">def</span> <span class="nf">from_id_seq_struct</span><span class="p">(</span><span class="n">id_str</span><span class="p">,</span> <span class="n">seq</span><span class="p">,</span> <span class="n">struct</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return a new BulgeGraph with the given id, </span>
<span class="sd">    sequence and structure.</span>

<span class="sd">    :param id_str: The id (i.e. &gt;1y26)</span>
<span class="sd">    :param seq: the sequence (i.e. &#39;ACCGGG&#39;)</span>
<span class="sd">    :param struct: The dotplot secondary structure (i.e. &#39;((..))&#39;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">bg</span> <span class="o">=</span> <span class="n">BulgeGraph</span><span class="p">()</span>
    <span class="n">bg</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="n">struct</span><span class="p">)</span>
    <span class="n">bg</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">id_str</span>
    <span class="n">bg</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span>

    <span class="k">return</span> <span class="n">bg</span></div>


<div class="viewcode-block" id="from_fasta_text"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.from_fasta_text">[docs]</a><span class="k">def</span> <span class="nf">from_fasta_text</span><span class="p">(</span><span class="n">fasta_text</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a bulge graph or multiple bulge</span>
<span class="sd">    graphs from some fasta text.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># compile searches for the fasta id, sequence and </span>
    <span class="c1"># secondary structure respectively</span>
    <span class="n">id_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;&gt;(.+)&#39;</span><span class="p">)</span>
    <span class="n">seq_search</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="s1">&#39;^([acguACGU]+)$&#39;</span><span class="p">)</span> <span class="c1">#BT: This does not allow for &quot;t&quot;/&quot;T&quot;(DNA)/&quot;N&quot;. Is it on purpose?</span>

    <span class="n">prev_id</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">prev_seq</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">prev_struct</span> <span class="o">=</span> <span class="bp">None</span>
    <span class="n">curr_id</span><span class="o">=</span><span class="bp">None</span>

    <span class="n">bgs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">fasta_text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">):</span>
        <span class="c1"># newlines suck</span>
        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="c1"># find out what this line contains</span>
        <span class="n">id_match</span> <span class="o">=</span> <span class="n">id_search</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="n">seq_match</span> <span class="o">=</span> <span class="n">seq_search</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">id_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">prev_id</span><span class="o">=</span><span class="n">curr_id</span>
            <span class="c1"># we found an id, check if there&#39;s a previous</span>
            <span class="c1"># sequence and structure, and create a BG</span>
            <span class="n">curr_id</span> <span class="o">=</span> <span class="n">id_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">prev_seq</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">prev_struct</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="c1"># must be the first sequence/structure</span>
                <span class="k">continue</span>

            <span class="c1"># make sure we have</span>
            <span class="k">if</span> <span class="n">prev_seq</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">Error</span><span class="p">(</span><span class="s2">&quot;No sequence for id: {}&quot;</span><span class="p">,</span> <span class="n">prev_id</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">prev_struct</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No sequence for id: {}&quot;</span><span class="p">,</span> <span class="n">prev_id</span><span class="p">)</span> 
                <span class="c1">#BT: This message not very helpful, if wrong character (&quot;N&quot;/..) in sequence</span>
            <span class="k">if</span> <span class="n">prev_id</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No previous id&quot;</span><span class="p">)</span>

            <span class="n">bgs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">from_id_seq_struct</span><span class="p">(</span><span class="n">prev_id</span><span class="p">,</span> <span class="n">prev_seq</span><span class="p">,</span> <span class="n">prev_struct</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">seq_match</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">prev_seq</span> <span class="o">=</span> <span class="n">seq_match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">id_match</span> <span class="ow">is</span> <span class="bp">None</span> <span class="ow">and</span> <span class="n">seq_match</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">prev_struct</span> <span class="o">=</span> <span class="n">line</span>

    <span class="n">bgs</span> <span class="o">+=</span> <span class="p">[</span><span class="n">from_id_seq_struct</span><span class="p">(</span><span class="n">curr_id</span><span class="p">,</span> <span class="n">prev_seq</span><span class="p">,</span> <span class="n">prev_struct</span><span class="p">)]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bgs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">bgs</span></div>


<div class="viewcode-block" id="from_fasta"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.from_fasta">[docs]</a><span class="k">def</span> <span class="nf">from_fasta</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Load a bulge graph from a fasta file. The format of the fasta</span>
<span class="sd">    file is roughly:</span>

<span class="sd">        &gt;1</span>
<span class="sd">        AACCCAA</span>
<span class="sd">        ((...))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="n">bg</span> <span class="o">=</span> <span class="n">BulgeGraph</span><span class="p">()</span>
        <span class="n">bg</span><span class="o">.</span><span class="n">from_fasta</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bg</span></div>


<div class="viewcode-block" id="any_difference_of_one"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.any_difference_of_one">[docs]</a><span class="k">def</span> <span class="nf">any_difference_of_one</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    See if there&#39;s any difference of one between the two</span>
<span class="sd">    ends of the stem [(a,b),(c,d)] and a bulge (e,f)</span>

<span class="sd">    :param stem: A couple of couples (2 x 2-tuple) indicating the start and end</span>
<span class="sd">                 nucleotides of the stem in the form ((s1, e1), (s2, e2))</span>
<span class="sd">    :param bulge: A couple (2-tuple) indicating the first and last position</span>
<span class="sd">                  of the bulge.</span>
<span class="sd">    :return: True if there is an overlap between the stem nucleotides and the </span>
<span class="sd">                  bulge nucleotides. False otherwise</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">stem_part</span> <span class="ow">in</span> <span class="n">stem</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">part</span> <span class="ow">in</span> <span class="n">stem_part</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">bulge_part</span> <span class="ow">in</span> <span class="n">bulge</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">bulge_part</span> <span class="o">-</span> <span class="n">part</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="bp">True</span>
    <span class="k">return</span> <span class="bp">False</span></div>


<div class="viewcode-block" id="print_bulges"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.print_bulges">[docs]</a><span class="k">def</span> <span class="nf">print_bulges</span><span class="p">(</span><span class="n">bulges</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print the names and definitions of the bulges.</span>

<span class="sd">    :param bulges: A list of tuples of the form [(s, e)] where s and e are the </span>
<span class="sd">                   numbers of the nucleotides at the start and end of the bulge.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulges</span><span class="p">)):</span>
        <span class="c1"># print &quot;bulge:&quot;, bulge</span>
        <span class="n">bulge_str</span> <span class="o">=</span> <span class="s2">&quot;define b{} 1&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">bulge</span> <span class="o">=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="n">bulge_str</span> <span class="o">+=</span> <span class="s2">&quot; {} {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">print</span> <span class="p">(</span><span class="n">bulge_str</span><span class="p">)</span></div>


<div class="viewcode-block" id="condense_stem_pairs"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.condense_stem_pairs">[docs]</a><span class="k">def</span> <span class="nf">condense_stem_pairs</span><span class="p">(</span><span class="n">stem_pairs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Given a list of stem pairs, condense them into stem definitions</span>

<span class="sd">    I.e. the pairs (0,10),(1,9),(2,8),(3,7) can be condensed into</span>
<span class="sd">    just the ends of the stem: [(0,10),(3,7)]</span>

<span class="sd">    :param stem_pairs: A list of tuples containing paired base numbers.</span>

<span class="sd">    :returns: A list of tuples of tuples of the form [((s1, e1), (s2, e2))]</span>
<span class="sd">                  where s1 and e1 are the nucleotides at one end of the stem</span>
<span class="sd">                  and s2 and e2 are the nucleotides at the other.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">stem_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

    <span class="n">prev_pair</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">)</span>

    <span class="n">stems</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start_pair</span> <span class="o">=</span> <span class="bp">None</span>

    <span class="k">for</span> <span class="n">pair</span> <span class="ow">in</span> <span class="n">stem_pairs</span><span class="p">:</span>
        <span class="c1"># There&#39;s a potential bug here since we don&#39;t check the direction</span>
        <span class="c1"># but hopefully it won&#39;t bite us in the ass later</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">prev_pair</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">or</span> <span class="nb">abs</span><span class="p">(</span><span class="n">pair</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">prev_pair</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">start_pair</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">stems</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">start_pair</span><span class="p">,</span> <span class="n">prev_pair</span><span class="p">)]</span>
            <span class="n">start_pair</span> <span class="o">=</span> <span class="n">pair</span>

        <span class="n">prev_pair</span> <span class="o">=</span> <span class="n">pair</span>

    <span class="k">if</span> <span class="n">start_pair</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">stems</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">start_pair</span><span class="p">,</span> <span class="n">prev_pair</span><span class="p">)]</span>

    <span class="k">return</span> <span class="n">stems</span></div>


<div class="viewcode-block" id="print_brackets"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.print_brackets">[docs]</a><span class="k">def</span> <span class="nf">print_brackets</span><span class="p">(</span><span class="n">brackets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Print the brackets and a numbering, for debugging purposes</span>

<span class="sd">    :param brackets: A string with the dotplot passed as input to this script.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">))]</span>
    <span class="n">tens</span> <span class="o">=</span> <span class="p">[</span><span class="nb">chr</span><span class="p">(</span><span class="nb">ord</span><span class="p">(</span><span class="s1">&#39;0&#39;</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">))]</span>
    <span class="k">print</span> <span class="p">(</span><span class="s2">&quot;brackets:</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">brackets</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">tens</span><span class="p">),</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">numbers</span><span class="p">))</span></div>

<span class="c1"># @Coverage: Seems to be unused. If this is removed, condense_stem_pairs can be removed as well.</span>
<div class="viewcode-block" id="find_bulges_and_stems"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.find_bulges_and_stems">[docs]</a><span class="k">def</span> <span class="nf">find_bulges_and_stems</span><span class="p">(</span><span class="n">brackets</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Iterate through the structure and enumerate the bulges and the stems that are</span>
<span class="sd">    present.</span>

<span class="sd">    The returned stems are of the form [[(s1, s2), (e1,e2)], [(s1,s2),(e1,e2)],...]</span>
<span class="sd">    where (s1,s2) are the residue numbers of one end of the stem and (e1,e2) are the</span>
<span class="sd">    residue numbers at the other end of the stem</span>
<span class="sd">    (see condense_stem_pairs)</span>

<span class="sd">    The returned bulges are of the form [(s,e), (s,e),...] where s is the start of a bulge</span>
<span class="sd">    and e is the end of a bulge</span>

<span class="sd">    :param brackets: A string with the dotbracket passed as input to this script.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">prev</span> <span class="o">=</span> <span class="s1">&#39;x&#39;</span>
    <span class="n">context</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">bulges</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">finished_bulges</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">context_depths</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="n">opens</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">stem_pairs</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">dots_start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">context_depths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">brackets</span><span class="p">)):</span>
        <span class="k">if</span> <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
            <span class="n">opens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
                <span class="n">context_depths</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="n">context_depths</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">context</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">context_depths</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                <span class="n">dots_end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">bulges</span> <span class="o">=</span> <span class="n">add_bulge</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="p">(</span><span class="n">dots_start</span><span class="p">,</span> <span class="n">dots_end</span><span class="p">),</span> <span class="n">context</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;)&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opens</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unmatched close bracket&quot;</span><span class="p">)</span>

            <span class="n">stem_pairs</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">opens</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">i</span><span class="p">))</span>

            <span class="n">context_depths</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">context_depths</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">bulges</span><span class="p">:</span>
                    <span class="n">finished_bulges</span> <span class="o">+=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">context</span><span class="p">]</span>
                <span class="n">bulges</span><span class="p">[</span><span class="n">context</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">context</span> <span class="o">-=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                <span class="n">dots_end</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">bulges</span> <span class="o">=</span> <span class="n">add_bulge</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="p">(</span><span class="n">dots_start</span><span class="p">,</span> <span class="n">dots_end</span><span class="p">),</span> <span class="n">context</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">dots_start</span> <span class="o">=</span> <span class="n">i</span>

        <span class="n">prev</span> <span class="o">=</span> <span class="n">brackets</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;.&#39;</span><span class="p">:</span>
        <span class="n">dots_end</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">bulges</span> <span class="o">=</span> <span class="n">add_bulge</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="p">(</span><span class="n">dots_start</span><span class="p">,</span> <span class="n">dots_end</span><span class="p">),</span> <span class="n">context</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">prev</span> <span class="o">==</span> <span class="s1">&#39;(&#39;</span><span class="p">:</span>
        <span class="k">print</span> <span class="p">(</span><span class="s2">&quot;Unmatched bracket at the end&quot;</span><span class="p">,</span> <span class="nb">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    elif prev == &#39;)&#39;:</span>
<span class="sd">        bulges = add_bulge(bulges, (i+1, i+1), context, &quot;8&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">context</span> <span class="ow">in</span> <span class="n">bulges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">finished_bulges</span> <span class="o">+=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">context</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opens</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Unmatched open bracket&quot;</span><span class="p">)</span>

    <span class="n">stem_pairs</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
    <span class="n">stems</span> <span class="o">=</span> <span class="n">condense_stem_pairs</span><span class="p">(</span><span class="n">stem_pairs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">finished_bulges</span><span class="p">,</span> <span class="n">stems</span></div>

<div class="viewcode-block" id="BulgeGraph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph">[docs]</a><span class="k">class</span> <span class="nc">BulgeGraph</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bg_file</span><span class="o">=</span><span class="bp">None</span><span class="p">,</span> <span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A bulge graph object.</span>

<span class="sd">        :var self.defines: The coarse grain element definitions: Keys are for example &#39;s1&#39;/ &#39;m2&#39;/ &#39;h3&#39;/ &#39;f1&#39;/ &#39;t1&#39;</span>
<span class="sd">                       Values are the positions in the sequence (1D-coordinate) of start , end, ...</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mst</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;untitled&quot;</span>
        <span class="c1">#: The coarse grain element definitions: Keys are for example &#39;s1&#39;/ &#39;m2&#39;/ &#39;h3&#39;/ &#39;f1&#39;/ &#39;t1&#39;</span>
        <span class="c1">#: Values are the positions in the sequence (1D-coordinate) of start , end, ...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">set</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span> <span class="o">=</span> <span class="p">{}</span>

        <span class="c1"># store the coordinate basis for each stem</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bases</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">stem_invs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># Additional infos as key-value pairs are stored here.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infos</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">name_counter</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">dotbracket_str</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">seq</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="s1">&#39; &#39;</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">bg_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_bg_file</span><span class="p">(</span><span class="n">bg_file</span><span class="p">)</span>

    <span class="c1"># get an internal index for a named vertex</span>
    <span class="c1"># this applies to both stems and edges</span>
<div class="viewcode-block" id="BulgeGraph.get_vertex"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">get_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a new unique vertex name.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;x{}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name_counter</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">name</span></div>

<div class="viewcode-block" id="BulgeGraph.element_length"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.element_length">[docs]</a>    <span class="k">def</span> <span class="nf">element_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the number of residues that are contained within this element.</span>

<span class="sd">        :param key: The name of the element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">length</span> <span class="o">+=</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">length</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_length"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_length">[docs]</a>    <span class="k">def</span> <span class="nf">stem_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the length of a particular element. If it&#39;s a stem, it&#39;s equal to</span>
<span class="sd">        the number of paired bases. If it&#39;s an interior loop, it&#39;s equal to the</span>
<span class="sd">        number of unpaired bases on the strand with less unpaired bases. If</span>
<span class="sd">        it&#39;s a multiloop, then it&#39;s the number of unpaired bases.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span> <span class="ow">or</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.add_info"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.add_info">[docs]</a>    <span class="k">def</span> <span class="nf">add_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.get_single_define_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_single_define_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_single_define_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get a define string for a single key.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;define {} {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]]))</span></div>

<div class="viewcode-block" id="BulgeGraph.get_define_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_define_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_define_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the defines into a string. </span>

<span class="sd">        Format:</span>

<span class="sd">        define [name] [start_res1] [end_res1] [start_res2] [end_res2]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">defines_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="c1"># a method for sorting the defines</span>
        <span class="k">def</span> <span class="nf">define_sorter</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">drni</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">drni</span><span class="p">)</span> <span class="c1">#.next()</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="n">define_sorter</span><span class="p">):</span>
            <span class="n">defines_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_single_define_str</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="c1"># defines_str += &quot;define %s %s&quot; % ( key, &quot; &quot;.join([str(d) for d in self.defines[key]]))</span>
            <span class="n">defines_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">defines_str</span></div>

<div class="viewcode-block" id="BulgeGraph.get_length_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_length_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_length_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s2">&quot;length &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">)</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span></div>
  
<div class="viewcode-block" id="BulgeGraph.get_info_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_info_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_info_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out</span><span class="o">=</span><span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">info</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">[</span><span class="n">info</span><span class="p">]:</span>
                <span class="n">out</span><span class="o">+=</span><span class="s2">&quot;info &quot;</span><span class="o">+</span><span class="n">info</span><span class="o">+</span><span class="s2">&quot; &quot;</span><span class="o">+</span><span class="n">value</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="BulgeGraph.get_connect_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_connect_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_connect_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the connections of the bulges in the graph.</span>

<span class="sd">        Format:</span>

<span class="sd">        connect [from] [to1] [to2] [to3]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">whole_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Our graph will be defined by the stems and the bulges they connect to</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">key</span>
            <span class="k">if</span> <span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">out_str</span> <span class="o">=</span> <span class="s2">&quot;connect {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">dest</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                    <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot; {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">dest</span><span class="p">)</span>

                <span class="n">whole_str</span> <span class="o">+=</span> <span class="n">out_str</span>
                <span class="n">whole_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>

        <span class="k">return</span> <span class="n">whole_str</span></div>

<div class="viewcode-block" id="BulgeGraph.get_sequence_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_sequence_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_sequence_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sequence along with its keyword. I.e.</span>

<span class="sd">            seq ACGGGCC</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;seq {}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span></div>

<div class="viewcode-block" id="BulgeGraph.get_seq_ids_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_seq_ids_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_seq_ids_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the sequence id string</span>

<span class="sd">        seq_ids 1 2 2.A 17</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s2">&quot;seq_ids &quot;</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ftum</span><span class="o">.</span><span class="n">format_resid</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">))</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="BulgeGraph.get_name_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_name_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_name_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the name of this structure along with its keyword:</span>

<span class="sd">            name 1y26</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;name {}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_bg_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.to_bg_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_bg_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output a string representation that can be stored and reloaded.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_name_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sequence_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_seq_ids_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_define_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connect_str</span><span class="p">()</span>
        <span class="n">out_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_info_str</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="BulgeGraph.to_file"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.to_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">out_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">out_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_element_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.to_element_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_element_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">with_numbers</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a string similar to dotbracket notation that identifies what</span>
<span class="sd">        type of element is present at each location.</span>

<span class="sd">        For example the following dotbracket:</span>

<span class="sd">        ..((..))..</span>

<span class="sd">        Should yield the following element string:</span>

<span class="sd">        ffsshhsstt</span>

<span class="sd">        Indicating that it begins with a fiveprime region, continues with a</span>
<span class="sd">        stem, has a hairpin after the stem, the stem continues and it is terminated</span>
<span class="sd">        by a threeprime region.</span>

<span class="sd">        :param with_numbers: show the last digit of the element id in a second line.::</span>

<span class="sd">                                 (((.(((...))))))</span>

<span class="sd">                             Could result in::</span>

<span class="sd">                                 sssissshhhssssss</span>
<span class="sd">                                 0000111000111000</span>

<span class="sd">                             Indicating that the first stem is named &#39;s0&#39;, followed by &#39;i0&#39;,&#39;</span>
<span class="sd">                             s1&#39;, &#39;h0&#39;, the second strand of &#39;s1&#39; and the second strand of &#39;s0&#39;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_str</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">output_nr</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39; &#39;</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">resi</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
                <span class="n">output_str</span><span class="p">[</span><span class="n">resi</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">output_nr</span><span class="p">[</span><span class="n">resi</span><span class="p">]</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">with_numbers</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_str</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">+</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_nr</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_str</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span></div>

<div class="viewcode-block" id="BulgeGraph.define_range_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.define_range_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">define_range_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the ranges of the nucleotides in the define.</span>

<span class="sd">        In other words, if a define contains the following: [1,2,7,8]</span>
<span class="sd">        The ranges will be [1,2] and [7,8].</span>

<span class="sd">        :param adjacent: Use the nucleotides in the neighboring element which</span>
<span class="sd">                         connect to this element as the range starts and ends.</span>
<span class="sd">        :return: A list of two-element lists</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># interior loops have to be treated specially because</span>
            <span class="c1"># they might have a bulge that has no unpaired nucleotides on one strand</span>

            <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
                <span class="n">conns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">conns</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">conns</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                <span class="c1"># offset by one, which will be reversed in the yield step</span>
                <span class="c1"># below</span>
                <span class="n">ranges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
                <span class="n">conns</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">conns</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">conns</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">node</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

                <span class="n">rnge</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">conns</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">s1</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">conns</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">s2</span><span class="p">]])</span>
                <span class="n">ranges</span> <span class="o">=</span> <span class="p">[[</span><span class="n">rnge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">rnge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">ds1</span><span class="p">,</span> <span class="n">ds2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ds1</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ds1</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">ds2</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">:</span>
                    <span class="n">ds2</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="n">seq_ids</span><span class="p">:</span>
                <span class="c1"># this will cause problems if the nucleotide has insertion codes</span>
                <span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">ds1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">ds2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">[</span><span class="n">ds1</span><span class="p">,</span> <span class="n">ds2</span><span class="p">]</span></div>

<div class="viewcode-block" id="BulgeGraph.define_residue_num_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.define_residue_num_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">define_residue_num_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the residue numbers that belong to this node.</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span><span class="o">=</span><span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_range_iterator</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">adjacent</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seq_ids</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                        <span class="k">yield</span> <span class="n">i</span></div>

<div class="viewcode-block" id="BulgeGraph.iterate_over_seqid_range"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.iterate_over_seqid_range">[docs]</a>    <span class="k">def</span> <span class="nf">iterate_over_seqid_range</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_id</span><span class="p">,</span> <span class="n">end_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the seq_ids between the start_id and end_id.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">start_id</span><span class="p">)</span>
        <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">end_id</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>
    
<div class="viewcode-block" id="BulgeGraph.seq_id_to_pos"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.seq_id_to_pos">[docs]</a>    <span class="k">def</span> <span class="nf">seq_id_to_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seq_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a pdb seq_id to a 1-based nucleotide position</span>

<span class="sd">        :param seq_id: A triple or an integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">seq_id</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
            <span class="n">seq_id</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="n">seq_id</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">seq_id</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span></div>

<div class="viewcode-block" id="BulgeGraph.create_bulge_graph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.create_bulge_graph">[docs]</a>    <span class="k">def</span> <span class="nf">create_bulge_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stems</span><span class="p">,</span> <span class="n">bulges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find out which stems connect to which bulges</span>

<span class="sd">        Stems and bulges which share a nucleotide are considered connected.</span>

<span class="sd">        :param stems: A list of tuples of tuples of the form [((s1, e1), (s2, e2))]</span>
<span class="sd">                      where s1 and e1 are the nucleotides at one end of the stem</span>
<span class="sd">                      and s2 and e2 are the nucleotides at the other.</span>

<span class="sd">        :param bulges: A list of tuples of the form [(s, e)] where s and e are the </span>
<span class="sd">                       numbers of the nucleotides at the start and end of the bulge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">)):</span>
            <span class="n">stem</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulges</span><span class="p">)):</span>
                <span class="n">bulge</span> <span class="o">=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">any_difference_of_one</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;y{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;b{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;b{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;y{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.create_stem_graph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.create_stem_graph">[docs]</a>    <span class="k">def</span> <span class="nf">create_stem_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stems</span><span class="p">,</span> <span class="n">bulge_counter</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Determine which stems are connected to each other. A stem can be connected to</span>
<span class="sd">        another stem when there is an interior loop with an unpaired nucleotide on</span>
<span class="sd">        one side. In this case, a bulge will be created on the other side, but it</span>
<span class="sd">        will only consist of the two paired bases around where the unpaired base </span>
<span class="sd">        would be if it existed.</span>

<span class="sd">        The defines for these bulges will be printed as well as the connection strings</span>
<span class="sd">        for the stems they are connected to.</span>

<span class="sd">        :param stems: A list of tuples of tuples of the form [((s1, e1), (s2, e2))]</span>
<span class="sd">                      where s1 and e1 are the nucleotides at one end of the stem</span>
<span class="sd">                      and s2 and e2 are the nucleotides at the other.</span>
<span class="sd">        :param bulge_counter: The number of bulges that have been encountered so far.</span>

<span class="sd">        :returns: A dictionary indexed by the number of a stem, containing a set of the </span>
<span class="sd">                 other stems that the index is connected to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print &quot;stems:&quot;, stems</span>
        <span class="n">stem_stems</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">)):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                    <span class="c1"># don&#39;t fear the for loop</span>
                    <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                        <span class="k">for</span> <span class="n">l1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                            <span class="k">for</span> <span class="n">l2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">):</span>
                                <span class="n">s1</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k1</span><span class="p">][</span><span class="n">l1</span><span class="p">]</span>
                                <span class="n">s2</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k2</span><span class="p">][</span><span class="n">l2</span><span class="p">]</span>
                                <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s1</span> <span class="o">-</span> <span class="n">s2</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                                    <span class="n">stem_stems_set</span> <span class="o">=</span> <span class="n">stem_stems</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="nb">set</span><span class="p">())</span>
                                    <span class="k">if</span> <span class="n">j</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stem_stems_set</span><span class="p">:</span>
                                        <span class="n">bn</span> <span class="o">=</span> <span class="s1">&#39;b{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bulge_counter</span><span class="p">)</span>
                                        <span class="c1"># self.defines[bn] = [min(s1, s2)+1, max(s1, s2)+1]</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                                        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;y{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bn</span><span class="p">)</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;y{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>

                                        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="s1">&#39;y{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">)]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bn</span><span class="p">)</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;y{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">j</span><span class="p">))</span>

                                        <span class="n">bulge_counter</span> <span class="o">+=</span> <span class="mi">1</span>
                                        <span class="n">stem_stems_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                                    <span class="n">stem_stems</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">stem_stems_set</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">s2</span> <span class="o">-</span> <span class="n">e1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">bn</span> <span class="o">=</span> <span class="s1">&#39;b{}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bulge_counter</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">bn</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">bn</span><span class="p">)</span>

                <span class="n">bulge_counter</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">stem_stems</span></div>

<div class="viewcode-block" id="BulgeGraph.remove_vertex"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.remove_vertex">[docs]</a>    <span class="k">def</span> <span class="nf">remove_vertex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete a node after merging it with another</span>

<span class="sd">        :param v: The name of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># delete all edges to this node</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>

        <span class="c1"># delete all edges from this node</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">]</span></div>

    <span class="k">def</span> <span class="nf">_reduce_defines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Make defines like this:</span>

<span class="sd">        define x0 2 124 124 3 4 125 127 5 5</span>
<span class="sd">        </span>
<span class="sd">        Into this:</span>

<span class="sd">        define x0 2 3 5 124 127</span>

<span class="sd">        That is, consolidate contiguous bulge region defines.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="k">assert</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">])</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">new_j</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">while</span> <span class="n">new_j</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]):</span>

                    <span class="n">j</span> <span class="o">=</span> <span class="n">new_j</span>
                    <span class="n">new_j</span> <span class="o">+=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">2</span>

                    <span class="p">(</span><span class="n">f1</span><span class="p">,</span> <span class="n">t1</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>

                    <span class="c1"># remove bulges of length 0</span>
                    <span class="k">if</span> <span class="n">f1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">==</span> <span class="o">-</span><span class="mi">2</span><span class="p">:</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>

                        <span class="n">new_j</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">continue</span>

                    <span class="c1"># merge contiguous bulge regions</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">j</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]),</span> <span class="mi">2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                            <span class="c1"># we can have stems with defines like: [1,2,3,4]</span>
                            <span class="c1"># which would imply a non-existant loop at its end</span>
                            <span class="k">continue</span>

                        <span class="p">(</span><span class="n">f2</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">k</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]))</span>

                        <span class="k">if</span> <span class="n">t2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">f1</span> <span class="ow">and</span> <span class="n">t1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="n">f2</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="k">if</span> <span class="n">t2</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">f1</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">f2</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                        <span class="k">elif</span> <span class="n">t1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">f2</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">f1</span><span class="p">)</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>

                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>
                        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">k</span><span class="p">]</span>

                        <span class="n">new_j</span> <span class="o">=</span> <span class="mi">0</span>

                        <span class="k">break</span>

    <span class="k">def</span> <span class="nf">_merge_vertices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertices</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is done when two of the outgoing strands of a stem</span>
<span class="sd">        go to different bulges</span>
<span class="sd">        It is assumed that the two ends are on the same sides because</span>
<span class="sd">        at least one vertex has a weight of 2, implying that it accounts</span>
<span class="sd">        for all of the edges going out of one side of the stem</span>

<span class="sd">        :param vertices: A list of vertex names to combine into one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_vertex</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_vertex</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># assert(len(vertices) == 2)</span>

        <span class="n">connections</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">vertices</span><span class="p">:</span>

            <span class="c1"># what are we gonna merge?</span>
            <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v</span><span class="p">]:</span>
                <span class="n">connections</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>

            <span class="c1"># Add the definition of this vertex to the new vertex</span>
            <span class="c1"># self.merge_defs[new_vertex] = self.merge_defs.get(new_vertex, []) + [v]</span>

            <span class="k">if</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+</span> <span class="p">[</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">new_vertex</span><span class="p">,</span> <span class="p">[])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">v</span><span class="p">]</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># remove the old vertex, since it&#39;s been replaced by new_vertex</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_reduce_defines</span><span class="p">()</span>

        <span class="c1"># self.weights[new_vertex] = 2</span>
        <span class="k">for</span> <span class="n">connection</span> <span class="ow">in</span> <span class="n">connections</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">new_vertex</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">connection</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">connection</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_vertex</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">new_vertex</span>

<div class="viewcode-block" id="BulgeGraph.shortest_bg_loop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.shortest_bg_loop">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_bg_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find the shortest loop containing this node. The vertex should</span>
<span class="sd">        be a multiloop.</span>

<span class="sd">        :param vertex: The name of the vertex to find the loop.</span>
<span class="sd">        :return: A list containing the elements in the shortest cycle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>

        <span class="c1"># use the nucleotide in the middle of this element as the starting point</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">True</span><span class="p">)))</span>
        <span class="n">mid_res</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">residues</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># no-residue multiloop</span>
            <span class="c1"># find the neighbor which isn&#39;t part of the multiloop</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">G</span><span class="o">.</span><span class="n">neighbors</span><span class="p">(</span><span class="n">mid_res</span><span class="p">)</span> <span class="k">if</span> <span class="n">n</span> <span class="o">!=</span> <span class="n">residues</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neighbors</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># break the chain so that we don&#39;t get cycles within a stem</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">mid_res</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">G</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">mid_res</span><span class="p">)</span>
                        <span class="k">break</span>

        <span class="kn">import</span> <span class="nn">forgi.utilities.graph</span> <span class="kn">as</span> <span class="nn">fug</span>

        <span class="n">path</span> <span class="o">=</span> <span class="n">fug</span><span class="o">.</span><span class="n">shortest_cycle</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">mid_res</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">path</span></div>

<div class="viewcode-block" id="BulgeGraph.nucleotides_to_elements"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.nucleotides_to_elements">[docs]</a>    <span class="k">def</span> <span class="nf">nucleotides_to_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nucleotides</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a list of nucleotides (nucleotide numbers) to element names.</span>

<span class="sd">        Remove redundant entries and return a set.</span>

<span class="sd">        ..note::</span>
<span class="sd">            Use `self.get_node_from_residue_num` if you have only a single nucleotide number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">nucleotides</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.find_bulge_loop"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.find_bulge_loop">[docs]</a>    <span class="k">def</span> <span class="nf">find_bulge_loop</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">,</span> <span class="n">max_length</span><span class="o">=</span><span class="mi">4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find a set of nodes that form a loop containing the</span>
<span class="sd">        given vertex and being no greater than max_length nodes long.</span>

<span class="sd">        :param vertex: The vertex to start the search from.</span>
<span class="sd">        :param max_length: Only fond loops that contain no mor then this many elements</span>
<span class="sd">        :returns: A list of the nodes in the loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="p">[(</span><span class="n">key</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">vertex</span><span class="p">]]</span>
        <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
        <span class="n">in_path</span> <span class="o">=</span> <span class="p">[</span><span class="n">vertex</span><span class="p">]</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_visit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">depth</span><span class="p">)</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

            <span class="n">in_path</span> <span class="o">=</span> <span class="n">in_path</span><span class="p">[:</span><span class="n">depth</span><span class="p">]</span>
            <span class="n">in_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">current</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="n">vertex</span> <span class="ow">and</span> <span class="n">depth</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">in_path</span><span class="p">[:</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">max_length</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">in_path</span><span class="p">[:</span><span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">to_visit</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">key</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">[]</span></div>

<div class="viewcode-block" id="BulgeGraph.add_node"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.add_node">[docs]</a>    <span class="k">def</span> <span class="nf">add_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">edges</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">define</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">edges</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

        <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">name</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">edge</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">name</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.dissolve_stem"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.dissolve_stem">[docs]</a>    <span class="k">def</span> <span class="nf">dissolve_stem</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove a stem. This means that we need</span>
<span class="sd">        to reconfigure all of the adjacent elements in such a manner</span>
<span class="sd">        that they now include the nucleotides that were formerly </span>
<span class="sd">        in this stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">st</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_base_pairs</span><span class="p">(</span><span class="n">st</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.remove_base_pairs"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.remove_base_pairs">[docs]</a>    <span class="k">def</span> <span class="nf">remove_base_pairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">to_remove</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all of the base pairs which are in pair_list.</span>

<span class="sd">        :param to_remove: A list of tuples containing the names of the base pairs.</span>
<span class="sd">        :return: nothing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_tuples</span><span class="p">()</span>

        <span class="n">nt</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pt</span><span class="p">:</span>
            <span class="n">to_add</span> <span class="o">=</span> <span class="n">p</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                    <span class="n">to_add</span> <span class="o">=</span> <span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="n">nt</span> <span class="o">+=</span> <span class="p">[</span><span class="n">to_add</span><span class="p">]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="c1"># self.edges = dict()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">nt</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_collapse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If any vertices form a loop, then they are either a bulge region of </span>
<span class="sd">        a fork region. The bulge (interior loop) regions will be condensed </span>
<span class="sd">        into one node.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">new_vertex</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">new_vertex</span><span class="p">:</span>
            <span class="n">new_vertex</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">bulges</span> <span class="o">=</span> <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;y&#39;</span><span class="p">]</span>

            <span class="k">for</span> <span class="p">(</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">bulges</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">b1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">b2</span><span class="p">]</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">b1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">b1</span><span class="p">)</span>

                    <span class="n">all_connections</span> <span class="o">=</span> <span class="p">[</span><span class="nb">sorted</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b2</span><span class="p">)[</span><span class="mi">0</span><span class="p">])),</span>
                                       <span class="nb">sorted</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b1</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">b2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]))]</span>

                    <span class="k">if</span> <span class="n">all_connections</span> <span class="o">==</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">]]:</span>
                        <span class="c1"># interior loop</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_merge_vertices</span><span class="p">([</span><span class="n">b1</span><span class="p">,</span> <span class="n">b2</span><span class="p">])</span>
                        <span class="n">new_vertex</span> <span class="o">=</span> <span class="bp">True</span>
                        <span class="k">break</span>

<div class="viewcode-block" id="BulgeGraph.interior_loop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.interior_loop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">interior_loop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all of the interior loops.</span>

<span class="sd">        An interior loop can only have two connections: to the two stems which it links. </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">key</span></div>

<div class="viewcode-block" id="BulgeGraph.relabel_node"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.relabel_node">[docs]</a>    <span class="k">def</span> <span class="nf">relabel_node</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old_name</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the name of a node.</span>

<span class="sd">        param old_name: The previous name of the node</span>
<span class="sd">        param new_name: The new name of the node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># replace the define name</span>
        <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>

        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">define</span>

        <span class="c1"># replace the index into the edges array</span>
        <span class="n">edge</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">old_name</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">new_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">edge</span>

        <span class="c1">#replace the name of any edge that pointed to old_name</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">new_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">==</span> <span class="n">old_name</span><span class="p">:</span>
                    <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">new_name</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_edges</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_edges</span></div>

<div class="viewcode-block" id="BulgeGraph.compare_stems"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.compare_stems">[docs]</a>    <span class="k">def</span> <span class="nf">compare_stems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        A function that can be passed in as the key to a sort.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">b</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span></div>


<div class="viewcode-block" id="BulgeGraph.compare_bulges"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.compare_bulges">[docs]</a>    <span class="k">def</span> <span class="nf">compare_bulges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.compare_hairpins"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.compare_hairpins">[docs]</a>    <span class="k">def</span> <span class="nf">compare_hairpins</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">1</span><span class="p">],</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxint</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.relabel_nodes"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.relabel_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">relabel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Change the labels of the nodes to be more indicative of their nature.</span>

<span class="sd">        s: stem</span>
<span class="sd">        h: hairpin</span>
<span class="sd">        i: interior loop</span>
<span class="sd">        m: multiloop</span>
<span class="sd">        f: five-prime unpaired</span>
<span class="sd">        t: three-prime unpaired</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">hairpins</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">interior_loops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">multiloops</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">fiveprimes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">threeprimes</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span> <span class="ow">or</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">stems</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

                <span class="n">stems</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compare_stems</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">hairpins</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">multiloops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">&lt;=</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">fiveprimes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">:</span>
                <span class="n">threeprimes</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">):</span>
                <span class="n">hairpins</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

                <span class="n">hairpins</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compare_hairpins</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">or</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;i&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span> <span class="ow">and</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="p">):</span>
                <span class="n">multiloops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

                <span class="n">multiloops</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compare_bulges</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">interior_loops</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="n">interior_loops</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">compare_stems</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">fiveprimes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;f1&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">threeprimes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;t1&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">stems</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;s</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">interior_loops</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;i</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">multiloops</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;m</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">hairpins</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">relabel_node</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="s1">&#39;h</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.has_connection"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.has_connection">[docs]</a>    <span class="k">def</span> <span class="nf">has_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Is there an edge between these two nodes &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">v2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># two multiloops can be connected at the end of a stem</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">v1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">if</span> <span class="n">v2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
                    <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">s1e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">v1</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">s2b</span><span class="p">,</span> <span class="n">s2e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

                    <span class="k">if</span> <span class="n">s1b</span> <span class="o">==</span> <span class="n">s2b</span><span class="p">:</span>
                        <span class="k">return</span> <span class="bp">True</span>

            <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="BulgeGraph.connection_type"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.connection_type">[docs]</a>    <span class="k">def</span> <span class="nf">connection_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Classify the way that two stems are connected according to the type</span>
<span class="sd">        of bulge that separates them.</span>

<span class="sd">        Potential angle types for single stranded segments, and the ends of</span>
<span class="sd">        the stems they connect:</span>
<span class="sd">      </span>
<span class="sd">        =   = ======  ===========</span>
<span class="sd">        1   2 (1, 1)  #pseudoknot</span>
<span class="sd">        1   0 (1, 0)</span>
<span class="sd">        3   2 (0, 1)</span>
<span class="sd">        3   0 (0, 0)</span>
<span class="sd">        =   = ======  ===========</span>

<span class="sd">        :param define: The name of the bulge separating the two stems</span>
<span class="sd">        :param connections: The two stems and their separation</span>

<span class="sd">        :returns: INT connection type</span>

<span class="sd">                  =   ======================================================================</span>
<span class="sd">                  +   positive values mean forward (from the connected stem starting at the </span>
<span class="sd">                      lower nucleotide number to the one starting at the higher nuc. number)</span>
<span class="sd">                  -   negative values mean backwards.</span>
<span class="sd">                  1   interior loop</span>
<span class="sd">                  2   first multi-loop segment of normal multiloops and most pseudoknots</span>
<span class="sd">                  3   middle segment of a normal multiloop</span>
<span class="sd">                  4   last segment of normal multiloops and most pseudoknots</span>
<span class="sd">                  5   middle segments of pseudoknots</span>
<span class="sd">                  =   ======================================================================</span>
<span class="sd">                  </span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># interior loop, we just have to check if </span>
            <span class="c1"># connections[0] &lt; connections[1]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">elif</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">b1c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">define</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s2c</span><span class="p">,</span> <span class="n">b2c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">define</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">2</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">2</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">3</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">3</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">4</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">4</span>

            <span class="c1"># the next two refer to pseudoknots</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">return</span> <span class="mi">5</span>
            <span class="k">elif</span> <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">return</span> <span class="o">-</span><span class="mi">5</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Weird angle type: (s1c, s2c) = (</span><span class="si">%d</span><span class="s2">, </span><span class="si">%d</span><span class="s2">)&quot;</span> <span class="o">%</span>
                                <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;connection_type called on non-interior loop/multiloop&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.connection_ends"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.connection_ends">[docs]</a>    <span class="k">def</span> <span class="nf">connection_ends</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">connection_type</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find out which ends of the stems are connected by a particular angle</span>
<span class="sd">        type.</span>

<span class="sd">        :param connection_type: The angle type, as determined by which corners</span>
<span class="sd">                                of a stem are connected</span>
<span class="sd">        :return: (s1e, s2b) 0 means the side of the stem with the lowest nucleotide, 1 the other side</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ends</span> <span class="o">=</span> <span class="p">()</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">connection_type</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">ends</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s1">&#39;Unknown connection type: </span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">connection_type</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">connection_type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ends</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ends</span></div>

    <span class="c1"># This function seems to be unused. Consider deprecation...</span>
<div class="viewcode-block" id="BulgeGraph.get_multiloop_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_multiloop_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">get_multiloop_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiloop_loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a list of nucleotides which make up a particular</span>
<span class="sd">        multiloop.</span>

<span class="sd">        :param multiloop_loop: The elements which make up this multiloop</span>
<span class="sd">        :return: A list of nucleotides</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">multiloop_loop</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">]</span>
        <span class="n">multis</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">multiloop_loop</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">]</span>
        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
            <span class="n">relevant_edges</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">multiloop_loop</span><span class="p">]</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">c</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">relevant_edges</span><span class="p">]</span>
            <span class="n">sides</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="c1"># the whole stem is part of this multiloop</span>
            <span class="k">if</span> <span class="n">sides</span> <span class="o">==</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="ow">or</span> <span class="n">sides</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
                <span class="n">residues</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">residues</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">multis</span><span class="p">:</span>
            <span class="n">residues</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">residues</span></div>

    <span class="c1"># This function seems to be unused. Consider deprecation...</span>
<div class="viewcode-block" id="BulgeGraph.find_external_loops"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.find_external_loops">[docs]</a>    <span class="k">def</span> <span class="nf">find_external_loops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return all of the elements which are part of</span>
<span class="sd">        an external loop.</span>

<span class="sd">        :return: A list containing the external loops in this molecule</span>
<span class="sd">                 (i.e. [&#39;f0, m3, m5, t0&#39;])</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ext_loop</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">floop_iterator</span><span class="p">(),</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">tloop_iterator</span><span class="p">(),</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">()):</span>
            <span class="n">loop_nts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_bg_loop</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loop_nts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ext_loop</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">ext_loop</span></div>

<div class="viewcode-block" id="BulgeGraph.find_multiloop_loops"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.find_multiloop_loops">[docs]</a>    <span class="k">def</span> <span class="nf">find_multiloop_loops</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find out which defines are connected in a multiloop.</span>

<span class="sd">        :return: Two lists, one containing the sets of nucleotides comprising the shortest loops</span>
<span class="sd">                 and the other containing sets of nucleotides comprising the shortest loops.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">loops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">():</span>
            <span class="n">loop_nts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shortest_bg_loop</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loop_nts</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">loops</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">loop_nts</span><span class="p">)))</span>

        <span class="n">loops</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">loops</span><span class="p">)</span>
        <span class="n">loop_elems</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">loop</span> <span class="ow">in</span> <span class="n">loops</span><span class="p">:</span>
            <span class="n">all_loops</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">])</span>

            <span class="c1"># some multiloops might not contain any nucleotides, so we</span>
            <span class="c1"># have to explicitly add these</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">all_loops</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">common_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">common_edges</span><span class="p">:</span>
                    <span class="n">all_loops</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

            <span class="n">loop_elems</span> <span class="o">+=</span> <span class="p">[</span><span class="n">all_loops</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">loop_elems</span><span class="p">,</span> <span class="n">loops</span></div>

<div class="viewcode-block" id="BulgeGraph.from_fasta"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.from_fasta">[docs]</a>    <span class="k">def</span> <span class="nf">from_fasta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fasta_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bulge graph from a fasta-type file containing the following</span>
<span class="sd">        format:</span>

<span class="sd">            &gt; id</span>
<span class="sd">            ACCGGGG</span>
<span class="sd">            ((...))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">fasta_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="n">lines</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">dissolve_length_one_stems</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s1">&#39;&gt;&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">lines</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids_from_seq</span><span class="p">()</span></div>

<div class="viewcode-block" id="BulgeGraph.seq_ids_from_seq"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.seq_ids_from_seq">[docs]</a>    <span class="k">def</span> <span class="nf">seq_ids_from_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the sequence ids of the string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># when provided with just a sequence, we presume that the</span>
        <span class="c1"># residue ids are numbered from 1-up</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">+=</span> <span class="p">[(</span><span class="s1">&#39; &#39;</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)]</span></div>

<div class="viewcode-block" id="BulgeGraph.remove_degenerate_nodes"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.remove_degenerate_nodes">[docs]</a>    <span class="k">def</span> <span class="nf">remove_degenerate_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For now just remove all hairpins that have no length.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">to_remove</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">to_remove</span> <span class="o">+=</span> <span class="p">[</span><span class="n">d</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">to_remove</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">remove_vertex</span><span class="p">(</span><span class="n">r</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.from_stems_and_bulges"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.from_stems_and_bulges">[docs]</a>    <span class="k">def</span> <span class="nf">from_stems_and_bulges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stems</span><span class="p">,</span> <span class="n">bulges</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the graph from the list of stems and bulges.</span>

<span class="sd">        :param stems: A list of tuples of two two-tuples, each containing the start</span>
<span class="sd">                      and end nucleotides of each strand of the stem.</span>
<span class="sd">        :param bulges: A list of tuples containing the starts and ends of the </span>
<span class="sd">                       of the bulge regions.</span>
<span class="sd">        :return: Nothing, just make the bulgegraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">)):</span>
            <span class="c1"># one is added to each coordinate to make up for the fact that residues are 1-based</span>
            <span class="n">ss1</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ss2</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">se1</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">se2</span> <span class="o">=</span> <span class="n">stems</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="s1">&#39;y</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="p">[</span><span class="nb">min</span><span class="p">(</span><span class="n">ss1</span><span class="p">,</span> <span class="n">se1</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ss1</span><span class="p">,</span> <span class="n">se1</span><span class="p">),</span>
                                         <span class="nb">min</span><span class="p">(</span><span class="n">ss2</span><span class="p">,</span> <span class="n">se2</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">ss2</span><span class="p">,</span> <span class="n">se2</span><span class="p">)]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="s1">&#39;y</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bulges</span><span class="p">)):</span>
            <span class="n">bulge</span> <span class="o">=</span> <span class="n">bulges</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="s1">&#39;b</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">weights</span><span class="p">[</span><span class="s1">&#39;b</span><span class="si">%d</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">create_bulge_graph</span><span class="p">(</span><span class="n">stems</span><span class="p">,</span> <span class="n">bulges</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">create_stem_graph</span><span class="p">(</span><span class="n">stems</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">bulges</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collapse</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relabel_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">remove_degenerate_nodes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sort_defines</span><span class="p">()</span></div>

<div class="viewcode-block" id="BulgeGraph.dissolve_length_one_stems"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.dissolve_length_one_stems">[docs]</a>    <span class="k">def</span> <span class="nf">dissolve_length_one_stems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># dissolve all stems which have a length of one</span>
        <span class="n">repeat</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">repeat</span><span class="p">:</span>
            <span class="n">repeat</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">dissolve_stem</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="n">repeat</span> <span class="o">=</span> <span class="bp">True</span>
                    <span class="k">break</span></div>

<div class="viewcode-block" id="BulgeGraph.from_dotbracket"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.from_dotbracket">[docs]</a>    <span class="k">def</span> <span class="nf">from_dotbracket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dotbracket_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate the BulgeGraph structure from a dotbracket representation.</span>

<span class="sd">        ie: ..((..))..</span>

<span class="sd">        :param dotbracket_str: A string containing the dotbracket representation</span>
<span class="sd">                               of the structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dotbracket_str</span> <span class="o">=</span> <span class="n">dotbracket_str</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="n">pt</span> <span class="o">=</span> <span class="n">fus</span><span class="o">.</span><span class="n">dotbracket_to_pairtable</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">)</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="n">fus</span><span class="o">.</span><span class="n">pairtable_to_tuples</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dissolve_length_one_stems</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dissolve_length_one_stems</span><span class="p">()</span></div>

<div class="viewcode-block" id="BulgeGraph.to_pair_table"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.to_pair_table">[docs]</a>    <span class="k">def</span> <span class="nf">to_pair_table</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a pair table from the list of elements.</span>

<span class="sd">        The first element in the returned list indicates the number of</span>
<span class="sd">        nucleotides in the structure.</span>

<span class="sd">        i.e. [5,5,4,0,2,1]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pair_tuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_tuples</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">fus</span><span class="o">.</span><span class="n">tuples_to_pairtable</span><span class="p">(</span><span class="n">pair_tuples</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_pair_tuples"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.to_pair_tuples">[docs]</a>    <span class="k">def</span> <span class="nf">to_pair_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a list of tuples corresponding to all of the base pairs in the</span>
<span class="sd">        structure. Unpaired bases will be shown as being paired with a</span>
<span class="sd">        nucleotide numbered 0.</span>

<span class="sd">        i.e. [(1,5),(2,4),(3,0),(4,2),(5,1)]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># iterate over each element</span>
        <span class="n">table</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="c1"># iterate over each nucleotide in each element</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">p</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">table</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span> <span class="n">p</span><span class="p">)]</span>

        <span class="k">return</span> <span class="n">table</span></div>

<div class="viewcode-block" id="BulgeGraph.to_bpseq_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.to_bpseq_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_bpseq_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bpseq string from this structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">pp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">pp</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">pp</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;{} {} {}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">pp</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="BulgeGraph.bpseq_to_tuples_and_seq"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.bpseq_to_tuples_and_seq">[docs]</a>    <span class="k">def</span> <span class="nf">bpseq_to_tuples_and_seq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bpseq_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert a bpseq string to a list of pair tuples and a sequence</span>
<span class="sd">        dictionary. The return value is a tuple of the list of pair tuples</span>
<span class="sd">        and a sequence string.</span>
<span class="sd">        </span>
<span class="sd">        :param bpseq_str: The bpseq string</span>
<span class="sd">        :return: ([(1,5),(2,4),(3,0),(4,2),(5,1)], &#39;ACCAA&#39;)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">bpseq_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">seq</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
            <span class="n">tuples</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)]</span>
            <span class="n">seq</span> <span class="o">+=</span> <span class="p">[</span><span class="n">s</span><span class="p">]</span>

        <span class="n">seq</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;T&#39;</span><span class="p">,</span> <span class="s1">&#39;U&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">tuples</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.from_bpseq_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.from_bpseq_str">[docs]</a>    <span class="k">def</span> <span class="nf">from_bpseq_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bpseq_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the graph from a string listing the base pairs.</span>

<span class="sd">        The string should be formatted like so:</span>

<span class="sd">            1 G 115</span>
<span class="sd">            2 A 0</span>
<span class="sd">            3 A 0</span>
<span class="sd">            4 U 0</span>
<span class="sd">            5 U 112</span>
<span class="sd">            6 G 111</span>

<span class="sd">        :param bpseq_str: The string, containing newline characters.</span>
<span class="sd">        :return: Nothing, but fill out this structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>

        <span class="n">tuples</span><span class="p">,</span> <span class="n">seq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bpseq_to_tuples_and_seq</span><span class="p">(</span><span class="n">bpseq_str</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">seq</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">seq</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">dissolve_length_one_stems</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dissolve_length_one_stems</span><span class="p">()</span></div>

<div class="viewcode-block" id="BulgeGraph.from_tuples"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.from_tuples">[docs]</a>    <span class="k">def</span> <span class="nf">from_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tuples</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a bulge_graph from a list of pair tuples. Unpaired</span>
<span class="sd">        nucleotides have a pairing partner of 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">bulges</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">tuples</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span>
        <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">tuples</span><span class="p">)</span> <span class="c1">#.next()</span>

        <span class="n">prev_from</span> <span class="o">=</span> <span class="n">t1</span>
        <span class="n">prev_to</span> <span class="o">=</span> <span class="n">t2</span>

        <span class="n">start_from</span> <span class="o">=</span> <span class="n">prev_from</span>
        <span class="n">start_to</span> <span class="o">=</span> <span class="n">prev_to</span>
        <span class="n">last_paired</span> <span class="o">=</span> <span class="n">prev_from</span>

        <span class="k">for</span> <span class="n">t1</span><span class="p">,</span> <span class="n">t2</span> <span class="ow">in</span> <span class="n">tuples</span><span class="p">:</span>
            <span class="p">(</span><span class="n">from_bp</span><span class="p">,</span> <span class="n">to_bp</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">to_bp</span> <span class="o">-</span> <span class="n">prev_to</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">prev_to</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># stem</span>
                <span class="k">if</span> <span class="p">(((</span><span class="n">prev_to</span> <span class="o">-</span> <span class="n">prev_from</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">to_bp</span> <span class="o">-</span> <span class="n">from_bp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span>
                         <span class="p">(</span><span class="n">prev_to</span> <span class="o">-</span> <span class="n">prev_from</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">to_bp</span> <span class="o">-</span> <span class="n">from_bp</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="ow">and</span>
                            <span class="p">(</span><span class="n">to_bp</span> <span class="o">-</span> <span class="n">prev_to</span><span class="p">)</span> <span class="o">==</span> <span class="o">-</span><span class="p">(</span><span class="n">from_bp</span> <span class="o">-</span> <span class="n">prev_from</span><span class="p">)):</span>
                    <span class="p">(</span><span class="n">prev_from</span><span class="p">,</span> <span class="n">prev_to</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">from_bp</span><span class="p">,</span> <span class="n">to_bp</span><span class="p">)</span>
                    <span class="n">last_paired</span> <span class="o">=</span> <span class="n">from_bp</span>
                    <span class="k">continue</span>

            <span class="k">if</span> <span class="n">to_bp</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">prev_to</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># bulge</span>
                <span class="p">(</span><span class="n">prev_from</span><span class="p">,</span> <span class="n">prev_to</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">from_bp</span><span class="p">,</span> <span class="n">to_bp</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">prev_to</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">new_stem</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">start_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])),</span>
                                             <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">prev_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))]))</span>
                    <span class="k">if</span> <span class="n">new_stem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
                        <span class="n">stems</span> <span class="o">+=</span> <span class="p">[</span><span class="n">new_stem</span><span class="p">]</span>

                    <span class="n">last_paired</span> <span class="o">=</span> <span class="n">from_bp</span>
                    <span class="n">start_from</span> <span class="o">=</span> <span class="n">from_bp</span>
                    <span class="n">start_to</span> <span class="o">=</span> <span class="n">to_bp</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">new_bulge</span> <span class="o">=</span> <span class="p">((</span><span class="n">last_paired</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="n">bulges</span> <span class="o">+=</span> <span class="p">[</span><span class="n">new_bulge</span><span class="p">]</span>

                    <span class="n">start_from</span> <span class="o">=</span> <span class="n">from_bp</span>
                    <span class="n">start_to</span> <span class="o">=</span> <span class="n">to_bp</span>

            <span class="n">prev_from</span> <span class="o">=</span> <span class="n">from_bp</span>
            <span class="n">prev_to</span> <span class="o">=</span> <span class="n">to_bp</span>

        <span class="c1"># Take care of the last element</span>
        <span class="k">if</span> <span class="n">prev_to</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_stem</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">start_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">start_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])),</span>
                                     <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">prev_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_to</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]))]))</span>
            <span class="k">if</span> <span class="n">new_stem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
                <span class="n">stems</span> <span class="o">+=</span> <span class="p">[</span><span class="n">new_stem</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">prev_to</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">new_bulge</span> <span class="o">=</span> <span class="p">((</span><span class="n">last_paired</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">prev_from</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">bulges</span> <span class="o">+=</span> <span class="p">[</span><span class="n">new_bulge</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_stems_and_bulges</span><span class="p">(</span><span class="n">stems</span><span class="p">,</span> <span class="n">bulges</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.sort_defines"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.sort_defines">[docs]</a>    <span class="k">def</span> <span class="nf">sort_defines</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sort the defines of interior loops and stems so that the 5&#39; region</span>
<span class="sd">        is always first.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                    <span class="n">new_d</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_d</span></div>

<div class="viewcode-block" id="BulgeGraph.to_dotbracket_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.to_dotbracket_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_dotbracket_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert the BulgeGraph representation to a dot-bracket string</span>
<span class="sd">        and return it.</span>

<span class="sd">        :return: A dot-bracket representation of this BulgeGraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_table</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">fus</span><span class="o">.</span><span class="n">pairtable_to_dotbracket</span><span class="p">(</span><span class="n">pt</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.to_fasta_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.to_fasta_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_fasta_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Output the BulgeGraph representation as a fast string of the</span>
<span class="sd">        format:</span>

<span class="sd">            &gt;id</span>
<span class="sd">            AACCCAA</span>
<span class="sd">            ((...))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">output_string</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">output_string</span> <span class="o">+=</span> <span class="s2">&quot;&gt;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">output_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span>
        <span class="n">output_string</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">())</span>

        <span class="k">return</span> <span class="n">output_string</span></div>

<div class="viewcode-block" id="BulgeGraph.from_bg_file"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.from_bg_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_bg_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bg_file</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load from a file containing a text-based representation</span>
<span class="sd">        of this BulgeGraph.</span>

<span class="sd">        :param bg_file: The filename.</span>
<span class="sd">        :return: No return value since the current structure is the one</span>
<span class="sd">                 being loaded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">bg_file</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">bg_string</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">())</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_bg_string</span><span class="p">(</span><span class="n">bg_string</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.from_bg_string"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.from_bg_string">[docs]</a>    <span class="k">def</span> <span class="nf">from_bg_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bg_str</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Populate this BulgeGraph from the string created by the method</span>
<span class="sd">        to_bg_string.</span>

<span class="sd">        :param bg_str: The string representation of this BugleGraph.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">bg_str</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># blank line</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;length&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;define&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;connect&#39;</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;seq&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seq</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;seq_ids&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">ftum</span><span class="o">.</span><span class="n">parse_resid</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;name&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">elif</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;info&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">infos</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:]))</span></div>

<div class="viewcode-block" id="BulgeGraph.sorted_stem_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.sorted_stem_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_stem_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over a list of the stems sorted by the lowest numbered</span>
<span class="sd">        nucleotide in each stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">]</span>
        <span class="n">stems</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">stems</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">s</span></div>

<div class="viewcode-block" id="BulgeGraph.sorted_element_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.sorted_element_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_element_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over a list of the coarse grained elements sorted by the lowest numbered</span>
<span class="sd">        nucleotide in each stem. Multiloops with no nucleotide coordinates come last.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[</span><span class="n">d</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="p">]</span>
        <span class="n">elements</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="k">else</span> <span class="mi">10000</span><span class="o">+</span><span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]))</span>

        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">e</span></div>

<div class="viewcode-block" id="BulgeGraph.is_single_stranded"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.is_single_stranded">[docs]</a>    <span class="k">def</span> <span class="nf">is_single_stranded</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Does this node represent a single-stranded region?</span>

<span class="sd">        Single stranded regions are five-prime and three-prime unpaired</span>
<span class="sd">        regions, multiloops, and hairpins</span>

<span class="sd">        .. warning::</span>
<span class="sd">            Interior loops are never considered single stranded by this function.</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        :return: True if yes, False if no</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">or</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="BulgeGraph.get_node_dimensions"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_node_dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimensions of a node.</span>

<span class="sd">        If the node is a stem, then the dimensions will be l where l is</span>
<span class="sd">        the length of the stem.</span>

<span class="sd">        Otherwise, see get_bulge_dimensions(node)</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        :return: A pair containing its dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">node</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">node</span><span class="p">))</span>
            <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            return (self.defines[node][1] - self.defines[node][0] + 1,</span>
<span class="sd">                    self.defines[node][1] - self.defines[node][0] + 1)</span>
<span class="sd">            &quot;&quot;&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">node</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.adjacent_stem_pairs_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.adjacent_stem_pairs_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">adjacent_stem_pairs_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all pairs of stems which are separated by some element.</span>

<span class="sd">        This will always yield triples of the form (s1, e1, s2) where s1 and</span>
<span class="sd">        s2 are the stem identifiers and e1 denotes the element that separates</span>
<span class="sd">        them.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">,</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_bp_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_bp_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">stem_bp_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all the base pairs in the stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>
        <span class="n">stem_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">stem_length</span><span class="p">):</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.get_connected_residues"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_connected_residues">[docs]</a>    <span class="k">def</span> <span class="nf">get_connected_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">bulge</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nucleotides which are connected by the element separating</span>
<span class="sd">        s1 and s2. They should be adjacent stems.</span>

<span class="sd">        :param s1, s2: 2 adjacent stems</span>
<span class="sd">        :param bulge: Optional: The bulge seperating the two stems. </span>
<span class="sd">                      If s1 and s2 are connected by more than one element,</span>
<span class="sd">                      this has to be given, or a ValueError will be raised.</span>
<span class="sd">                      (useful for pseudoknots)</span>

<span class="sd">        The connected nucleotides are those which are spanned by a single</span>
<span class="sd">        interior loop or multiloop. In the case of an interior loop, this</span>
<span class="sd">        function will return a list of two tuples and in the case of multiloops</span>
<span class="sd">        if it will be a list of one tuple.</span>

<span class="sd">        If the two stems are not separated by a single element, then return</span>
<span class="sd">        an empty list.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">c1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
        <span class="n">c2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s2</span><span class="p">]</span>

        <span class="c1"># find out which edges they share</span>
        <span class="n">common_edges</span> <span class="o">=</span> <span class="n">c1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># not connected</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">bulge</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Too many connections between the stems. &quot;</span>
                            <span class="s2">&quot;Please provide the connectiong bulge you are interested in.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge</span> <span class="ow">and</span> <span class="n">bulge</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">common_edges</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;{}  does not connecty the stems {} and {}.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">))</span>

        <span class="c1"># the element linking the two stems</span>
        <span class="k">if</span> <span class="n">bulge</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">bulge</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># find out the sides of the stems that face the bulge</span>
        <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">s1e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
        <span class="p">(</span><span class="n">s2b</span><span class="p">,</span> <span class="n">s2e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>

        <span class="c1"># get the nucleotides on the side facing the stem</span>
        <span class="n">s1_nucleotides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">s1b</span><span class="p">)</span>
        <span class="n">s2_nucleotides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">s2b</span><span class="p">)</span>

        <span class="c1"># find out the distances between all the nucleotides flanking</span>
        <span class="c1"># the bulge</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">s1_nucleotides</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">s2_nucleotides</span><span class="p">:</span>
                <span class="n">dists</span> <span class="o">+=</span> <span class="p">[(</span><span class="nb">abs</span><span class="p">(</span><span class="n">n2</span> <span class="o">-</span> <span class="n">n1</span><span class="p">),</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">)]</span>
        <span class="n">dists</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

        <span class="c1"># return the ones which are closest to each other</span>
        <span class="k">if</span> <span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:]),</span> <span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">:])])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">dists</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">:])]</span></div>

<div class="viewcode-block" id="BulgeGraph.get_link_direction"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_link_direction">[docs]</a>    <span class="k">def</span> <span class="nf">get_link_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span> <span class="o">=</span> <span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the direction in which stem1 and stem2 are linked (by the bulge)</span>
<span class="sd">        </span>
<span class="sd">        :returns: 1 if the bulge connects stem1 with stem2 in forward direction (5&#39; to 3&#39;)</span>
<span class="sd">                  -1 otherwise</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">linked</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connected_residues</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">linked</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">linked</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span></div>

<div class="viewcode-block" id="BulgeGraph.get_side_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_side_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">get_side_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the nucleotide numbers on the given side of</span>
<span class="sd">        them stem. Side 0 corresponds to the 5&#39; end of the</span>
<span class="sd">        stem whereas as side 1 corresponds to the 3&#39; side</span>
<span class="sd">        of the stem.</span>

<span class="sd">        :param stem: The name of the stem</span>
<span class="sd">        :param side: Either 0 or 1, indicating the 5&#39; or 3&#39; end of the stem</span>
<span class="sd">        :return: A tuple of the nucleotide numbers on the given side of</span>
<span class="sd">                 the stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span>

        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid side (</span><span class="si">%d</span><span class="s2">) for the stem (</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">side</span><span class="p">))</span></div>

    <span class="c1"># Seems to be unused. Consider deprecation</span>
<div class="viewcode-block" id="BulgeGraph.get_stem_edge"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_stem_edge">[docs]</a>    <span class="k">def</span> <span class="nf">get_stem_edge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the side of the stem that position is on.</span>
<span class="sd">        Side 0 corresponds to the 5&#39; pairing residues in the</span>
<span class="sd">        stem whereas as side 1 corresponds to the 3&#39; pairing</span>
<span class="sd">        residues in the stem.</span>
<span class="sd">        :param stem: The name of the stem</span>
<span class="sd">        :param pos: A position in the stem</span>
<span class="sd">        :return: 0 if pos on 5&#39; edge of stem</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fp_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tp_side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_side_nucleotides</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        
        <span class="n">fp_edge</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">fp_side</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">tp_side</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">tp_edge</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="n">tp_side</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fp_side</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">fp_edge</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">pos</span> <span class="ow">in</span> <span class="n">tp_edge</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        
        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Position (</span><span class="si">%d</span><span class="s2">) not in stem (</span><span class="si">%s</span><span class="s2">).&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">stem</span><span class="p">))</span></div>

    <span class="c1"># Seems to be unused. Consider deprecation</span>
<div class="viewcode-block" id="BulgeGraph.get_any_sides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_any_sides">[docs]</a>    <span class="k">def</span> <span class="nf">get_any_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the side of e1 that e2 is on. The only difference from the get_sides</span>
<span class="sd">        method is the fact that e1 does not have to be a stem.</span>

<span class="sd">        0 indicates that e2 is on the side with lower numbered</span>
<span class="sd">        nucleotides and 1 indicates that e2 is on the side with</span>
<span class="sd">        greater nucleotide numbers.</span>

<span class="sd">        :param e1: The name of the first element.</span>
<span class="sd">        :param e2: The name of the second element.</span>
<span class="sd">        :return: A tuple indicating the side of e1 adjacent to e2 and the side of e2</span>
<span class="sd">                 adjacent to e1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">e1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">e2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">e1</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="BulgeGraph.get_sides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_sides">[docs]</a>    <span class="k">def</span> <span class="nf">get_sides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the side of s1 that is next to b.</span>

<span class="sd">        s1e -&gt; s1b -&gt; b</span>

<span class="sd">        :param s1: The stem.</span>
<span class="sd">        :param b: The bulge.</span>
<span class="sd">        :return: A tuple indicating which side is the one next to the bulge</span>
<span class="sd">                 and which is away from the bulge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="c1"># if the bulge is a length 0 multiloop then use the adjacent</span>
        <span class="c1"># stem to determine its side</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">s1</span><span class="p">:</span>
                    <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="k">break</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">4</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)):</span>
                <span class="k">if</span> <span class="n">s1d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">s1b</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                        <span class="n">s1b</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">break</span>
                <span class="k">elif</span> <span class="n">s1d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">s1b</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="n">s1b</span> <span class="o">=</span> <span class="mi">0</span>
                        <span class="k">break</span>
        <span class="k">if</span> <span class="n">s1b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s1e</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s1e</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">s1e</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.get_sides_plus"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_sides_plus">[docs]</a>    <span class="k">def</span> <span class="nf">get_sides_plus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the side of s1 that is next to b.</span>

<span class="sd">        s1e -&gt; s1b -&gt; b</span>

<span class="sd">        :param s1: The stem.</span>
<span class="sd">        :param b: The bulge.</span>
<span class="sd">        :return: A tuple indicating the corner of the stem that connects</span>
<span class="sd">                 to the bulge as well as the corner of the bulge that connects</span>
<span class="sd">                 to the stem.</span>
<span class="sd">                 These sides are equivalent to the indices of the define.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">s1d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">]</span>
        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">b</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">edges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="o">!=</span> <span class="n">s1</span><span class="p">:</span>
                    <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="c1">#For bulges of length 0, use the next stem</span>
                    <span class="k">break</span>

        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)):</span>
            <span class="c1"># before the stem on the 5&#39; strand</span>
            <span class="k">if</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="c1"># after the stem on the 5&#39; strand</span>
            <span class="k">elif</span> <span class="n">bd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="c1"># before the stem on the 3&#39; strand</span>
            <span class="k">elif</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>
            <span class="c1"># after the stem on the 3&#39; strand</span>
            <span class="k">elif</span> <span class="n">bd</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Faulty multiloop </span><span class="si">%s</span><span class="s2"> connecting </span><span class="si">%s</span><span class="s2">&quot;</span>
                        <span class="o">%</span> <span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">bd</span><span class="p">)),</span>
                           <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">s1d</span><span class="p">))))</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_resn_to_stem_vres_side"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_resn_to_stem_vres_side">[docs]</a>    <span class="k">def</span> <span class="nf">stem_resn_to_stem_vres_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">res</span><span class="p">):</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">res</span><span class="o">&lt;=</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">res</span><span class="o">-</span><span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">side</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">res</span><span class="o">&lt;=</span><span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span>
            <span class="n">pos</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="n">res</span>
            <span class="n">side</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Residue {} not in stem {} with define {}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">res</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">d</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">pos</span><span class="p">,</span> <span class="n">side</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_side_vres_to_resn"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_side_vres_to_resn">[docs]</a>    <span class="k">def</span> <span class="nf">stem_side_vres_to_resn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="n">side</span><span class="p">,</span> <span class="n">vres</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the residue number given the stem name, the strand (side) it&#39;s on</span>
<span class="sd">        and the virtual residue number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vres</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">vres</span></div>

<div class="viewcode-block" id="BulgeGraph.stem_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.stem_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">stem_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the stems in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.hloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.hloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">hloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the hairpin in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.mloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.mloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">mloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the multiloops in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.iloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.iloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">iloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterator over all of the interior loops in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.floop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.floop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">floop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the name of the 5&#39; prime unpaired region if it is</span>
<span class="sd">        present in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;f1&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">yield</span> <span class="s1">&#39;f1&#39;</span></div>

<div class="viewcode-block" id="BulgeGraph.tloop_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.tloop_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">tloop_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Yield the name of the 3&#39; prime unpaired region if it is</span>
<span class="sd">        present in the structure.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;t1&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">yield</span> <span class="s1">&#39;t1&#39;</span></div>

<div class="viewcode-block" id="BulgeGraph.pairing_partner"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.pairing_partner">[docs]</a>    <span class="k">def</span> <span class="nf">pairing_partner</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nucleotide_number</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the base pairing partner of the nucleotide at position</span>
<span class="sd">        nucleotide_number. If this nucleotide is unpaired, return None.</span>

<span class="sd">        :param nucleotide_number: The position of the query nucleotide in the</span>
<span class="sd">                                  sequence.</span>
<span class="sd">        :return: The number of the nucleotide base paired with the one at</span>
<span class="sd">                 position nucleotide_number.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">r1</span> <span class="o">==</span> <span class="n">nucleotide_number</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">r2</span>
                <span class="k">elif</span> <span class="n">r2</span> <span class="o">==</span> <span class="n">nucleotide_number</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">r1</span>
        <span class="k">return</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="BulgeGraph.connections"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.connections">[docs]</a>    <span class="k">def</span> <span class="nf">connections</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the edges that connect to a bulge in a list form,</span>
<span class="sd">        sorted by lowest res number of the connection.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">sort_key</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">x</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">x</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># special case for stems at the beginning since there is no</span>
                    <span class="c1"># adjacent nucleotide 0</span>
                    <span class="k">return</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">True</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>


        <span class="n">connections</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">bulge</span><span class="p">])</span>
        <span class="n">connections</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">sort_key</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">connections</span></div>

<div class="viewcode-block" id="BulgeGraph.get_define_seq_str"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_define_seq_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_define_seq_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an array containing the sequences for the given define.</span>
<span class="sd">        Non-stem sequences will contain the sequence without the overlapping</span>
<span class="sd">        stem residues that are part of the define.</span>

<span class="sd">        :param d: The define for which to get the sequences</span>
<span class="sd">        :return: An array containing the sequences corresponding to the defines</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="n">define</span><span class="p">)]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span><span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">i1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">)[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">),</span> <span class="nb">max</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">i1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">i2</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">i1</span><span class="p">:</span><span class="n">i2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">seqs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                    <span class="n">seqs</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">adjacent</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">seqs</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">:</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">seqs</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">seqs</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>

            <span class="k">return</span> <span class="n">seqs</span></div>

<div class="viewcode-block" id="BulgeGraph.get_stem_direction"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_stem_direction">[docs]</a>    <span class="k">def</span> <span class="nf">get_stem_direction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return 0 if the lowest numbered residue in s1</span>
<span class="sd">        is lower than the lowest numbered residue in s2.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;get_stem_direction is deprecated and will be removed in the future!&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s2</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="mi">1</span></div>

<div class="viewcode-block" id="BulgeGraph.get_multiloop_side"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_multiloop_side">[docs]</a>    <span class="k">def</span> <span class="nf">get_multiloop_side</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Find out which strand a multiloop is on. An example of a situation in</span>
<span class="sd">        which the loop can be on both sides can be seen in the three-stemmed</span>
<span class="sd">        structure below:</span>

<span class="sd">            (.().().)</span>

<span class="sd">        In this case, the first multiloop section comes off of the 5&#39; strand of</span>
<span class="sd">        the first stem (the prior stem is always the one with a lower numbered</span>
<span class="sd">        first residue). The second multiloop section comess of the 3&#39; strand of </span>
<span class="sd">        the second stem and the third loop comes off the 3&#39; strand of the third</span>
<span class="sd">        stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>

        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">m</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p2</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span></div>

    <span class="c1"># This function seems to be unused here. This code is possible duplicated somewhere.</span>
    <span class="c1"># Requires cleanup.</span>
<div class="viewcode-block" id="BulgeGraph.get_strand"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_strand">[docs]</a>    <span class="k">def</span> <span class="nf">get_strand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">multiloop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the strand on which this multiloop is located.</span>

<span class="sd">        :param multiloop: The name of the multiloop</span>
<span class="sd">        :return: 0 for being on the lower numbered strand and 1 for</span>
<span class="sd">                 being on the higher numbered strand.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">multiloop</span><span class="p">)</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">multiloop</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span>
        <span class="k">pass</span></div>

<div class="viewcode-block" id="BulgeGraph.get_bulge_dimensions"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_bulge_dimensions">[docs]</a>    <span class="k">def</span> <span class="nf">get_bulge_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the dimensions of the bulge.</span>

<span class="sd">        If it is single stranded it will be (0, x). Otherwise it will be (x, y).</span>

<span class="sd">        :param bulge: The name of the bulge.</span>
<span class="sd">        :return: A pair containing its dimensions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">bd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">bulge</span><span class="p">]</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># if this interior loop only has one unpaired region</span>
            <span class="c1"># then we have to find out if it&#39;s on the 5&#39; strand or</span>
            <span class="c1"># the 3&#39; strand</span>
            <span class="c1"># Example:</span>
            <span class="c1"># s1 1 3 </span>
            <span class="c1"># 23 25</span>
            <span class="c1"># s2 5 10 </span>
            <span class="c1"># 15 20</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="c1"># Multiloops are also pretty easy</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bd</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;f&#39;</span> <span class="ow">or</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">dims</span> <span class="o">=</span> <span class="p">(</span><span class="n">bd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">bd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">dims</span></div>

<div class="viewcode-block" id="BulgeGraph.get_node_from_residue_num"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_node_from_residue_num">[docs]</a>    <span class="k">def</span> <span class="nf">get_node_from_residue_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_num</span><span class="p">,</span> <span class="n">seq_id</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over the defines and see which one encompasses this base.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">define</span><span class="p">),</span> <span class="mi">2</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span> <span class="nb">int</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])]</span>
                <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">seq_id</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">base_num</span><span class="p">:</span>
                            <span class="k">return</span> <span class="n">key</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">base_num</span> <span class="o">&gt;=</span> <span class="n">a</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">base_num</span> <span class="o">&lt;=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                        <span class="k">return</span> <span class="n">key</span>

        <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span><span class="s2">&quot;Base number </span><span class="si">%d</span><span class="s2"> not found in the defines.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base_num</span><span class="p">))</span></div>

<div class="viewcode-block" id="BulgeGraph.get_length"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_length">[docs]</a>    <span class="k">def</span> <span class="nf">get_length</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vertex</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the minimum length of a vertex.</span>

<span class="sd">        If it&#39;s a stem, then the result is its length (in base pairs).</span>

<span class="sd">        If it&#39;s a bulge, then the length is the smaller of it&#39;s dimensions.</span>

<span class="sd">        :param vertex: The name of the vertex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">vertex</span><span class="p">])</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">vertex</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">vertex</span><span class="p">))</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

                <span class="k">if</span> <span class="n">vertex</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dims</span><span class="p">))</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.get_flanking_region"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_flanking_region">[docs]</a>    <span class="k">def</span> <span class="nf">get_flanking_region</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If a bulge is flanked by stems, return the lowest residue number</span>
<span class="sd">        of the previous stem and the highest residue number of the next</span>
<span class="sd">        stem.</span>

<span class="sd">        :param bulge_name: The name of the bulge</span>
<span class="sd">        :param side: The side of the bulge (indicating the strand)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="c1"># interior loop</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">s2</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>

        <span class="k">elif</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">ss</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multiloop_side</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>
            <span class="n">st</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]</span>

            <span class="n">ends</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="c1"># go through the two sides and stems and pick</span>
            <span class="c1"># the other end of the same strand</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ss</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">3</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">s</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">ends</span> <span class="o">+=</span> <span class="p">[</span><span class="n">st</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">2</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;Weird multiloop sides: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                                    <span class="n">bulge_name</span><span class="p">)</span>

            <span class="n">ends</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ends</span><span class="p">)</span>
            <span class="c1"># multiloop</span>

        <span class="k">return</span> <span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span></div>


<div class="viewcode-block" id="BulgeGraph.get_flanking_sequence"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_flanking_sequence">[docs]</a>    <span class="k">def</span> <span class="nf">get_flanking_sequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="s2">&quot;No sequence present in the bulge_graph: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">))</span>

        <span class="p">(</span><span class="n">m1</span><span class="p">,</span> <span class="n">m2</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_flanking_region</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq</span><span class="p">[</span><span class="n">m1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span><span class="n">m2</span><span class="p">]</span></div>

<div class="viewcode-block" id="BulgeGraph.get_flanking_handles"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_flanking_handles">[docs]</a>    <span class="k">def</span> <span class="nf">get_flanking_handles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the indices of the residues for fitting bulge regions.</span>

<span class="sd">        So if there is a loop like so (between residues 7 and 16)::</span>
<span class="sd">        </span>
<span class="sd">          (((...))))</span>
<span class="sd">          7890123456</span>
<span class="sd">            ^   ^</span>

<span class="sd">        Then residues 9 and 13 will be used as the handles against which</span>
<span class="sd">        to align the fitted region.</span>

<span class="sd">        In the fitted region, the residues (2,6) will be the ones that will</span>
<span class="sd">        be aligned to the handles.</span>

<span class="sd">        :return: (orig_chain_res1, orig_chain_res1, flanking_res1, flanking_res2)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_flanking_region</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">sides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_multiloop_side</span><span class="p">(</span><span class="n">bulge_name</span><span class="p">)</span>
            <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="n">sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">s2</span><span class="p">[</span><span class="n">sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]]]</span>
            <span class="n">ab</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">bulge_name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s1</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s2</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ab</span> <span class="o">=</span> <span class="p">[</span><span class="n">s2</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">s1</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ab</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">f1</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># probably still have to include the 5&#39; and 3&#39; regions, but that</span>
        <span class="c1"># will come a little later</span>
        <span class="k">return</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="BulgeGraph.are_adjacent_stems"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.are_adjacent_stems">[docs]</a>    <span class="k">def</span> <span class="nf">are_adjacent_stems</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">,</span> <span class="n">multiloops_count</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Are two stems separated by only one element. If multiloops should not</span>
<span class="sd">        count as edges, then the appropriate parameter should be set.</span>

<span class="sd">        :param s1: The name of the first stem</span>
<span class="sd">        :param s2: The name of the second stem</span>
<span class="sd">        :param multiloops_count: Whether to count multiloops as an edge linking</span>
<span class="sd">                                 two stems</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">multiloops_count</span> <span class="ow">and</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">s2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="BulgeGraph.random_subgraph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.random_subgraph">[docs]</a>    <span class="k">def</span> <span class="nf">random_subgraph</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">subgraph_length</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a random subgraph of this graph.</span>

<span class="sd">        :return: A list containing a the nodes comprising a random subgraph</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">subgraph_length</span> <span class="o">==</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">subgraph_length</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>

        <span class="n">start_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span>
        <span class="n">curr_length</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">next_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">start_node</span><span class="p">]</span>
        <span class="n">new_graph</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">while</span> <span class="n">curr_length</span> <span class="o">&lt;</span> <span class="n">subgraph_length</span><span class="p">:</span>
            <span class="n">curr_node</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">choice</span><span class="p">(</span><span class="n">next_nodes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">curr_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span> <span class="ow">or</span> <span class="n">curr_node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="c1"># if it&#39;s an interior loop or a multiloop, then we have to</span>
                <span class="c1"># add the adjacent stems</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">curr_node</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">new_graph</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="n">new_graph</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">next_nodes</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
                    <span class="n">curr_length</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curr_node</span><span class="p">)</span>
            <span class="n">next_nodes</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">curr_node</span><span class="p">])</span>
            <span class="n">next_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">next_nodes</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">]</span>
            <span class="n">new_graph</span> <span class="o">+=</span> <span class="p">[</span><span class="n">curr_node</span><span class="p">]</span>
            <span class="n">curr_length</span> <span class="o">+=</span> <span class="mi">1</span>  <span class="c1"># self.element_length(curr_node)</span>

        <span class="k">return</span> <span class="n">new_graph</span></div>

<div class="viewcode-block" id="BulgeGraph.get_resseqs"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_resseqs">[docs]</a>    <span class="k">def</span> <span class="nf">get_resseqs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">seq_ids</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return the pdb ids of the nucleotides in this define.</span>

<span class="sd">        :param define: The name of this element.</span>
<span class="sd">        :param: Return a tuple of two arrays containing the residue ids</span>
<span class="sd">                on each strand</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resnames</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ranges</span> <span class="o">=</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="p">[</span><span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">define</span><span class="p">])]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
            <span class="n">strand_resnames</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">seq_ids</span><span class="p">:</span>
                    <span class="n">strand_resnames</span> <span class="o">+=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">strand_resnames</span> <span class="o">+=</span> <span class="p">[</span><span class="n">x</span><span class="p">]</span>

            <span class="n">resnames</span> <span class="o">+=</span> <span class="p">[</span><span class="n">strand_resnames</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">resnames</span></div>

<div class="viewcode-block" id="BulgeGraph.seqids_from_residue_map"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.seqids_from_residue_map">[docs]</a>    <span class="k">def</span> <span class="nf">seqids_from_residue_map</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">residue_map</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create the list of seq_ids from the list of MC-Annotate identifiers in the</span>
<span class="sd">        residue map.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residue_map</span><span class="p">:</span>
            <span class="p">(</span><span class="n">from_chain</span><span class="p">,</span> <span class="n">from_base</span><span class="p">)</span> <span class="o">=</span> <span class="n">ftum</span><span class="o">.</span><span class="n">parse_chain_base</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">seq_ids</span> <span class="o">+=</span> <span class="p">[</span><span class="n">ftum</span><span class="o">.</span><span class="n">parse_resid</span><span class="p">(</span><span class="n">from_base</span><span class="p">)]</span></div>

    <span class="c1"># This function seems to be dead code, but might be useful in the future.</span>
    <span class="c1"># Consider adding this to whitelist.py</span>
<div class="viewcode-block" id="BulgeGraph.connected_stem_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.connected_stem_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">connected_stem_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Iterate over all pairs of connected stems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">iloop_iterator</span><span class="p">()):</span>
            <span class="n">edge_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">l</span><span class="p">])</span>
            <span class="k">yield</span> <span class="p">(</span><span class="n">edge_list</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">,</span> <span class="n">edge_list</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.sorted_edges_for_mst"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.sorted_edges_for_mst">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_edges_for_mst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep track of all linked nodes. Used for the generation of the minimal spanning tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">priority</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">(),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">iloop_iterator</span><span class="p">()),</span>
                       <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">priority</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_dimensions</span><span class="p">(</span><span class="n">x</span><span class="p">))))</span>
        <span class="k">return</span> <span class="n">edges</span></div>
<div class="viewcode-block" id="BulgeGraph.get_mst"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_mst">[docs]</a>    <span class="k">def</span> <span class="nf">get_mst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a minimum spanning tree from this BulgeGraph. This is useful</span>
<span class="sd">        for constructing a structure where each section of a multiloop is</span>
<span class="sd">        sampled independently and we want to introduce a break at the largest</span>
<span class="sd">        multiloop section.</span>
<span class="sd">        &quot;&quot;&quot;</span>        
        <span class="c1"># keep track of all linked nodes</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_edges_for_mst</span><span class="p">()</span>

        <span class="n">mst</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">floop_iterator</span><span class="p">(),</span>
                           <span class="bp">self</span><span class="o">.</span><span class="n">tloop_iterator</span><span class="p">()))</span>

        <span class="c1"># store all of the disconnected trees</span>
        <span class="n">forest</span> <span class="o">=</span> <span class="p">[</span><span class="nb">set</span><span class="p">([</span><span class="n">m</span><span class="p">])</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mst</span><span class="p">]</span>

        <span class="c1"># get the tree containing a particular element</span>
        <span class="k">def</span> <span class="nf">get_tree</span><span class="p">(</span><span class="n">elem</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">forest</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">elem</span> <span class="ow">in</span> <span class="n">t</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">t</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="n">edges</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">conn</span><span class="p">])</span>

            <span class="c1"># get the trees containing the neighbors of this node</span>
            <span class="c1"># the node should be an interior loop or multiloop so</span>
            <span class="c1"># the neighbors should necessarily be stems, 5&#39; or 3&#39;</span>
            <span class="n">t1</span> <span class="o">=</span> <span class="n">get_tree</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">t2</span> <span class="o">=</span> <span class="n">get_tree</span><span class="p">(</span><span class="n">neighbors</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">t1</span><span class="p">,</span> <span class="n">t2</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># if this node connects two disparate trees, then add it to the mst</span>
                <span class="n">new_tree</span> <span class="o">=</span> <span class="n">t1</span><span class="o">.</span><span class="n">union</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
                <span class="n">forest</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t1</span><span class="p">)</span>
                <span class="n">forest</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">t2</span><span class="p">)</span>
                <span class="n">forest</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_tree</span><span class="p">)</span>

                <span class="n">mst</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">mst</span></div>

<div class="viewcode-block" id="BulgeGraph.traverse_graph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.traverse_graph">[docs]</a>    <span class="k">def</span> <span class="nf">traverse_graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Traverse the graph to get the angle types. The angle type depends on </span>
<span class="sd">        which corners of the stem are connected by the multiloop or internal</span>
<span class="sd">        loop.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">mst</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">mst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_mst</span><span class="p">()</span>

        <span class="n">build_order</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">to_visit</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;s0&#39;</span><span class="p">,</span> <span class="s1">&#39;start&#39;</span><span class="p">)]</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">([</span><span class="s1">&#39;s0&#39;</span><span class="p">])</span>
        <span class="n">build_paths</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>

        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">to_visit</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">to_visit</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_dimensions</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])))</span>
            <span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span> <span class="o">=</span> <span class="n">to_visit</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span> <span class="ow">and</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mst</span><span class="p">:</span>
                    <span class="c1"># make sure the node hasn&#39;t been visited</span>
                    <span class="c1"># and is in the minimum spanning tree</span>
                    <span class="n">to_visit</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">e</span><span class="p">,</span> <span class="n">current</span><span class="p">))</span>

                    <span class="n">build_paths</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+=</span> <span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">build_paths</span><span class="p">[</span><span class="n">e</span><span class="p">]</span> <span class="o">+=</span> <span class="n">build_paths</span><span class="p">[</span><span class="n">current</span><span class="p">]</span>

                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">current</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">])</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># multiloop or interior loop</span>

                <span class="c1"># overkill method of getting the stem that isn&#39;t</span>
                <span class="c1"># equal to prev</span>
                <span class="n">next_stem</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">difference</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">current</span><span class="p">],</span>
                                           <span class="nb">set</span><span class="p">([</span><span class="n">prev</span><span class="p">]))</span>
                <span class="n">build_order</span> <span class="o">+=</span> <span class="p">[(</span><span class="n">prev</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">next_stem</span><span class="p">)[</span><span class="mi">0</span><span class="p">])]</span>
                <span class="c1"># If pseudoknots exist, the direction is not always 0! </span>
                <span class="c1"># assert self.get_stem_direction(prev, build_order[-1][2])==0 does not hold!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="o">=</span> <span class="n">build_order</span>

        <span class="k">return</span> <span class="n">build_order</span></div>

<div class="viewcode-block" id="BulgeGraph.set_angle_types"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.set_angle_types">[docs]</a>    <span class="k">def</span> <span class="nf">set_angle_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fill in the angle types based on the build order</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">s1</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">s2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">[</span><span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">])</span></div>

<div class="viewcode-block" id="BulgeGraph.get_angle_type"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_angle_type">[docs]</a>    <span class="k">def</span> <span class="nf">get_angle_type</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return what type of angle this bulge is, based on the way this</span>
<span class="sd">        would be built using a breadth-first traversal along the minimum</span>
<span class="sd">        spanning tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_angle_types</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">bulge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">ang_types</span><span class="p">[</span><span class="n">bulge</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="BulgeGraph.is_node_pseudoknot"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.is_node_pseudoknot">[docs]</a>    <span class="k">def</span> <span class="nf">is_node_pseudoknot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is a particular multiloop part of a pseudoknot?</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">ct</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span> <span class="o">==</span> <span class="mi">5</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">True</span>
        <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="BulgeGraph.is_loop_pseudoknot"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.is_loop_pseudoknot">[docs]</a>    <span class="k">def</span> <span class="nf">is_loop_pseudoknot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Is a particular loop a pseudoknot?</span>

<span class="sd">        :param loop: A list of elements that are part of the loop.</span>
<span class="sd">        :return: Either True or false</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allowed_ang_types</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span>
        <span class="n">found_ang_types</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="n">loop</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">l</span><span class="p">)</span>
            <span class="n">ctype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">conn</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">ctype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed_ang_types</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">True</span>

            <span class="n">found_ang_types</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ctype</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">found_ang_types</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">False</span>

        <span class="k">return</span> <span class="bp">True</span></div>

<div class="viewcode-block" id="BulgeGraph.to_networkx"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.to_networkx">[docs]</a>    <span class="k">def</span> <span class="nf">to_networkx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert this graph to a networkx representation. This representation</span>
<span class="sd">        will contain all of the nucleotides as nodes and all of the base pairs</span>
<span class="sd">        as edges as well as the adjacent nucleotides.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>

        <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>

        <span class="n">residues</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>

            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
                <span class="n">residues</span> <span class="o">+=</span> <span class="p">[</span><span class="n">r</span><span class="p">]</span>

        <span class="n">residues</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">residues</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">prev</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="n">r</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_bp_iterator</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
                <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">G</span></div>

<div class="viewcode-block" id="BulgeGraph.remove_pseudoknots"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.remove_pseudoknots">[docs]</a>    <span class="k">def</span> <span class="nf">remove_pseudoknots</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Remove all of the pseudoknots using the knotted2nested.py script.</span>

<span class="sd">        :return: A list of base-pairs that were removed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># remove unpaired bases and redundant pairs (i.e. (2,3) and (3,2))</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">([</span><span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_pair_tuples</span><span class="p">()</span> <span class="k">if</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">pairs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">pairs</span><span class="p">))</span>

        <span class="c1"># knotted_struct = fak.KnottedStructure(pairs, Seq=self.seq, Header=[])</span>

        <span class="kn">import</span> <span class="nn">forgi.aux.k2n_standalone.knots</span> <span class="kn">as</span> <span class="nn">fakk</span>

        <span class="n">pk_function</span> <span class="o">=</span> <span class="n">fakk</span><span class="o">.</span><span class="n">eg</span>
        <span class="n">nested_pairs</span><span class="p">,</span> <span class="n">removed_pairs</span> <span class="o">=</span> <span class="n">pk_function</span><span class="p">(</span><span class="n">pairs</span><span class="p">,</span> <span class="n">return_removed</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">remove_base_pairs</span><span class="p">(</span><span class="n">removed_pairs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">removed_pairs</span></div>

    <span class="c1">#Seems to be unused...</span>
<div class="viewcode-block" id="BulgeGraph.ss_distance"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.ss_distance">[docs]</a>    <span class="k">def</span> <span class="nf">ss_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the distance between two elements (e1, e2)</span>
<span class="sd">        along the secondary structure. The distance only starts</span>
<span class="sd">        at the edge of each element, and is the closest distance</span>
<span class="sd">        between the two elements.</span>

<span class="sd">        :param e1: The name of the first element</span>
<span class="sd">        :param e2: The name of the second element</span>
<span class="sd">        :return: The integer distance between the two along the secondary</span>
<span class="sd">                 structure.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># get the edge nucleotides</span>
        <span class="c1"># thanks to:</span>
        <span class="c1"># http://stackoverflow.com/questions/2154249/identify-groups-of-continuous-numbers-in-a-list</span>
        <span class="c1"># we get the edges, except that they might be one too close because we use adjacent</span>
        <span class="c1"># nucleotides, nevertheless we&#39;ll take care of that later</span>
        <span class="n">d1_corners</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">d2_corners</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">True</span><span class="p">)),</span> 
                                  <span class="k">lambda</span> <span class="n">index_item</span><span class="p">:</span> <span class="n">index_item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_item</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">group</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">oper</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">group</span><span class="p">))</span>
            <span class="n">d1_corners</span> <span class="o">+=</span> <span class="n">group</span>

        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">groupby</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e2</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">True</span><span class="p">)),</span> 
                                  <span class="k">lambda</span> <span class="n">index_item</span><span class="p">:</span> <span class="n">index_item</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">index_item</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="n">group</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">oper</span><span class="o">.</span><span class="n">itemgetter</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">group</span><span class="p">))</span>
            <span class="n">d2_corners</span> <span class="o">+=</span> <span class="n">group</span>

        <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>

        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
        <span class="n">path_lengths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">d1_corners</span><span class="p">,</span> <span class="n">d2_corners</span><span class="p">):</span>
            <span class="n">path_lengths</span> <span class="o">+=</span> <span class="p">[</span><span class="n">nx</span><span class="o">.</span><span class="n">shortest_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">)]</span>

        <span class="k">if</span> <span class="n">e1</span> <span class="o">==</span> <span class="n">e2</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">e1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e2</span><span class="p">]:</span>
            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># make some exceptions for edges which have length 0</span>
        <span class="n">common_edges</span> <span class="o">=</span> <span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e2</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">common_edges</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">path_lengths</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span></div>

<div class="viewcode-block" id="BulgeGraph.shortest_path"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.shortest_path">[docs]</a>    <span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Determine the shortest path between two elements (e1, e2)</span>
<span class="sd">        along the secondary structure.</span>
<span class="sd">        </span>
<span class="sd">        :param e1: The name of the first element</span>
<span class="sd">        :param e2: The name of the second element</span>
<span class="sd">        :return: A list of the element names along the shortest path</span>
<span class="sd">        </span>
<span class="sd">        &#39;&#39;&#39;</span>
        
        <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
        
        <span class="c1"># Get residue numbers of source and targets, for shortest_path in nx</span>
        <span class="n">source</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="p">[</span><span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e1</span><span class="p">)]</span> <span class="p">)</span>
        <span class="n">target</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span> <span class="p">[</span><span class="n">res</span> <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">e2</span><span class="p">)]</span> <span class="p">)</span>
        
        <span class="c1"># Get nx graph, and the shortest path</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>
        <span class="n">nx_sp</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">source</span><span class="o">=</span><span class="n">source</span><span class="p">,</span> <span class="n">target</span><span class="o">=</span><span class="n">target</span><span class="p">)</span>
        
        <span class="c1"># Convert shortest path of residue numbers to a shortest path of node names</span>
        <span class="n">sp</span><span class="p">,</span> <span class="n">sp_set</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()</span> <span class="c1"># Use set to keep track of additions for faster lookup</span>
        <span class="k">for</span> <span class="n">res</span> <span class="ow">in</span> <span class="n">nx_sp</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">res</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
                <span class="n">sp_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
                <span class="n">sp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
        <span class="c1"># assymetric bulges with a length of 0 on 1 side are missed,</span>
        <span class="c1"># two adjacent stems indicate a bulge with length 0 along the path</span>
        <span class="n">shortest_path</span><span class="p">,</span> <span class="n">sp_set</span> <span class="o">=</span> <span class="p">[],</span> <span class="nb">set</span><span class="p">()</span>
        <span class="n">traversal</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span> <span class="c1"># Connections are ordered compared to connected_stem_iterator()</span>
        
        <span class="k">for</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">sp</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span> <span class="c1"># Iterate through adjacent pairs of elements in the list</span>
            <span class="k">if</span> <span class="n">n1</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">n2</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">):</span> <span class="c1"># If two elements are both stems</span>
                <span class="n">connection</span> <span class="o">=</span> <span class="nb">list</span><span class="p">([</span><span class="n">conn</span> <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">traversal</span> <span class="k">if</span> <span class="n">n1</span> <span class="ow">in</span> <span class="n">conn</span> <span class="ow">and</span> <span class="n">n2</span> <span class="ow">in</span> <span class="n">conn</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># Find their connection in graph traversal</span>
                <span class="k">if</span> <span class="n">connection</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">connection</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n2</span><span class="p">):</span> <span class="c1">#If we&#39;re moving &#39;backwards&#39; on the traversal</span>
                    <span class="n">connection</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">connection</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
                        <span class="n">sp_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>    
                        <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
                    <span class="n">sp_set</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
                    <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">sp_set</span><span class="p">:</span>
            <span class="n">shortest_path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n2</span><span class="p">)</span> <span class="c1"># Append last item in path</span>
        
        <span class="k">return</span> <span class="n">shortest_path</span></div>

<div class="viewcode-block" id="BulgeGraph.get_position_in_element"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_position_in_element">[docs]</a>    <span class="k">def</span> <span class="nf">get_position_in_element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">resnum</span><span class="p">):</span>
        <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">resnum</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">resnum</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">3</span><span class="p">]),</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span>
            <span class="n">s0</span><span class="p">,</span><span class="n">s1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">resnum</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">return</span> <span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">2</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s0</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">s1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;h&#39;</span><span class="p">:</span>
            <span class="n">pos1</span> <span class="o">=</span> <span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">pos2</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">resnum</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">return</span> <span class="nb">min</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">pos2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>


        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">]):</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">s</span> <span class="o">&lt;=</span> <span class="n">resnum</span> <span class="o">&lt;=</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">resnum</span> <span class="o">-</span> <span class="n">s</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">e</span> <span class="o">-</span> <span class="n">s</span> <span class="o">+</span> <span class="mi">2</span>

            <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="bp">None</span></div>

<div class="viewcode-block" id="BulgeGraph.connected"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.connected">[docs]</a>    <span class="k">def</span> <span class="nf">connected</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Are the nucleotides n1 and n2 connected?</span>

<span class="sd">        :param n1: A node in the BulgeGraph</span>
<span class="sd">        :param n2: Another node in the BulgeGraph</span>
<span class="sd">        :return: True or False indicating whether they are connected.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">n1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n2</span><span class="p">]</span> <span class="ow">or</span> <span class="n">n2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n1</span><span class="p">]:</span>
            <span class="k">return</span> <span class="bp">True</span>

        <span class="c1"># two multiloops can be considered connected if they both</span>
        <span class="c1"># link to the same side of the same stem</span>
        <span class="k">if</span> <span class="n">n1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span> <span class="ow">and</span> <span class="n">n2</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span>
            <span class="n">common_stems</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">n2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_stems</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">False</span>

            <span class="n">common_stem</span> <span class="o">=</span> <span class="n">common_stems</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="p">(</span><span class="n">s1c</span><span class="p">,</span> <span class="n">b1c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">common_stem</span><span class="p">,</span> <span class="n">n1</span><span class="p">)</span>
            <span class="p">(</span><span class="n">s2c</span><span class="p">,</span> <span class="n">b1c</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides_plus</span><span class="p">(</span><span class="n">common_stem</span><span class="p">,</span> <span class="n">n2</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span> <span class="ow">or</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">s1c</span><span class="p">,</span> <span class="n">s2c</span><span class="p">])</span> <span class="o">==</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]:</span>
                <span class="k">return</span> <span class="bp">True</span>

        <span class="k">return</span> <span class="bp">False</span></div>

<div class="viewcode-block" id="BulgeGraph.flanking_nucleotides"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.flanking_nucleotides">[docs]</a>    <span class="k">def</span> <span class="nf">flanking_nucleotides</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the nucleotides directly flanking an element.</span>
<span class="sd">    </span>
<span class="sd">        :param d: the name of the element</span>
<span class="sd">        :return: a set of nucleotides</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;This is deprecated and will be removed in the future&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">set_adjacent</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
        <span class="n">set_not_adjacent</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="bp">False</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">set_adjacent</span> <span class="o">-</span> <span class="n">set_not_adjacent</span></div>

<div class="viewcode-block" id="BulgeGraph.min_max_bp_distance"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.min_max_bp_distance">[docs]</a>    <span class="k">def</span> <span class="nf">min_max_bp_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the minimum and maximum base pair distance between</span>
<span class="sd">        these two elements.</span>

<span class="sd">        If they are connected, the minimum distance will be 1. </span>
<span class="sd">        The maximum will be 1 + length(e1) + length(e1)</span>

<span class="sd">        :param e1: The name of the first element</span>
<span class="sd">        :param e2: The name of the second element</span>
<span class="sd">        :return:   A tuple containing the minimum and maximum distance between</span>
<span class="sd">                   the two elements.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1">#flanking1 = self.flanking_nucleotides(e1)</span>
        <span class="c1">#flanking2 = self.flanking_nucleotides(e2)</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">)</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">:</span> <span class="c1">#Shortcut if cached.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">[(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">)]</span>

        <span class="n">min_bp</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">maxint</span>
        <span class="n">max_bp</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_networkx</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">networkx</span> <span class="kn">as</span> <span class="nn">nx</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span><span class="c1">#col.defaultdict(dict)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">dist_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">floyd_warshall_numpy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span><span class="p">))</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">i1</span><span class="p">,</span><span class="n">n1</span><span class="p">),</span> <span class="p">(</span><span class="n">i2</span><span class="p">,</span><span class="n">n2</span><span class="p">)</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">()),</span>
                                               <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nx_graph</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist_matrix</span><span class="p">[</span><span class="n">i1</span><span class="p">][</span><span class="n">i2</span><span class="p">]</span>

        <span class="k">for</span> <span class="n">f1</span><span class="p">,</span> <span class="n">f2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e1</span><span class="p">]),</span> <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">e2</span><span class="p">])):</span>
            <span class="c1">#d =  nx.dijkstra_path_length(self.nx_graph, f1, f2)</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nuc_bp_dists</span><span class="p">[</span><span class="n">f1</span><span class="p">,</span><span class="n">f2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">d</span> <span class="o">&lt;</span> <span class="n">min_bp</span><span class="p">:</span>
                <span class="n">min_bp</span> <span class="o">=</span> <span class="n">d</span>
            <span class="k">if</span> <span class="n">d</span> <span class="o">&gt;</span> <span class="n">max_bp</span><span class="p">:</span>
                <span class="n">max_bp</span> <span class="o">=</span> <span class="n">d</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">[(</span><span class="n">e1</span><span class="p">,</span><span class="n">e2</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_bp</span><span class="p">,</span> <span class="n">max_bp</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_elem_bp_dists</span><span class="p">[(</span><span class="n">e2</span><span class="p">,</span><span class="n">e1</span><span class="p">)]</span> <span class="o">=</span> <span class="p">(</span><span class="n">min_bp</span><span class="p">,</span> <span class="n">max_bp</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">min_bp</span><span class="p">,</span> <span class="n">max_bp</span><span class="p">)</span></div>

<div class="viewcode-block" id="BulgeGraph.nd_define_iterator"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.nd_define_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">nd_define_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Iterate over defines which contain some nucleotides.</span>

<span class="sd">        :return: An iterator over all defines which contain some</span>
<span class="sd">                 nucleotides.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">d</span></div>

<div class="viewcode-block" id="BulgeGraph.get_domains"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.BulgeGraph.get_domains">[docs]</a>    <span class="k">def</span> <span class="nf">get_domains</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get secondary structure domains. </span>

<span class="sd">        Currently domains found are:</span>
<span class="sd">          * multiloops with connected stems</span>
<span class="sd">          * rods: stretches of stems + interior loops (without branching), with trailing hairpins</span>
<span class="sd">          * pseudoknots</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">domains</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
        <span class="n">multiloops</span><span class="p">,</span> <span class="n">nucleotides</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_multiloop_loops</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">ml</span> <span class="ow">in</span> <span class="n">multiloops</span><span class="p">:</span>
            <span class="n">ml</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_loop_pseudoknot</span><span class="p">(</span><span class="n">ml</span><span class="p">):</span>
                <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;pseudoknots&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;multiloops&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ml</span><span class="p">)</span>

        <span class="n">doublestr</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="n">neighbors</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">doublestr</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">region</span> <span class="ow">or</span> <span class="nb">any</span><span class="p">(</span><span class="n">n</span> <span class="ow">in</span> <span class="n">region</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">):</span>
                    <span class="n">curr_region</span> <span class="o">=</span> <span class="n">region</span>
                    <span class="n">curr_region</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">doublestr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">s</span><span class="p">]))</span>
                <span class="n">curr_region</span> <span class="o">=</span> <span class="n">doublestr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">neighbors</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;sih&quot;</span><span class="p">:</span>
                    <span class="n">curr_region</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="c1">#print(doublestr)</span>
        <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">reg1</span><span class="p">,</span> <span class="n">reg2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">doublestr</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">reg1</span> <span class="o">&amp;</span> <span class="n">reg2</span><span class="p">:</span>
                    <span class="n">doublestr</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">reg1</span><span class="p">)</span>
                    <span class="n">doublestr</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">reg2</span><span class="p">)</span>
                    <span class="n">doublestr</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">reg1</span><span class="o">|</span><span class="n">reg2</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
    
        <span class="k">for</span> <span class="n">region</span> <span class="ow">in</span> <span class="n">doublestr</span><span class="p">:</span>
            <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;rods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">region</span><span class="p">))</span>
        <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;pseudoknots&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;multiloops&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="n">domains</span><span class="p">[</span><span class="s2">&quot;rods&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
        <span class="c1">#print(domains)</span>
        <span class="k">return</span> <span class="n">domains</span></div></div>

<div class="viewcode-block" id="bg_from_subgraph"><a class="viewcode-back" href="../../../apidoc/forgi.graph.html#forgi.graph.bulge_graph.bg_from_subgraph">[docs]</a><span class="k">def</span> <span class="nf">bg_from_subgraph</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">sg</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a BulgeGraph from a list containing the nodes</span>
<span class="sd">    to take from the original.</span>

<span class="sd">    WARNING: The sequence information is not copied</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nbg</span> <span class="o">=</span> <span class="n">BulgeGraph</span><span class="p">()</span>
    <span class="n">nbg</span><span class="o">.</span><span class="n">seq_length</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sg</span><span class="p">:</span>
        <span class="c1"># copy the define</span>
        <span class="n">nbg</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="n">bg</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">][::]</span>

    <span class="c1"># copy edges only if they connect elements which </span>
    <span class="c1"># are also in the new structure</span>
    <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">edges</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">conn</span> <span class="ow">in</span> <span class="n">sg</span><span class="p">:</span>
                <span class="n">nbg</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">nbg</span></div>

</pre></div>

      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &copy; Copyright 2012-2016 Peter Kerpedjiev &lt;pkerp@tbi.univie.ac.at&gt;; 2015,2016 Bernhard Thiel &lt;thiel@tbi.univie.ac.at&gt;.
      Last updated on Sep 05, 2016.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.4.
    </div>
  </body>
</html>