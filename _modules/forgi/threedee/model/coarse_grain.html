

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>forgi.threedee.model.coarse_grain &#8212; forgi 1.0 documentation</title>
    <link rel="stylesheet" href="../../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../../../index.html">
          <span>forgi 1.0 documentation</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for forgi.threedee.model.coarse_grain</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">unicode_literals</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="p">(</span><span class="n">ascii</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="nb">chr</span><span class="p">,</span> <span class="nb">dict</span><span class="p">,</span> <span class="nb">filter</span><span class="p">,</span> <span class="nb">hex</span><span class="p">,</span> <span class="nb">input</span><span class="p">,</span>
                      <span class="nb">map</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span> <span class="nb">oct</span><span class="p">,</span> <span class="nb">pow</span><span class="p">,</span> <span class="nb">range</span><span class="p">,</span> <span class="nb">round</span><span class="p">,</span>
                      <span class="nb">str</span><span class="p">,</span> <span class="nb">super</span><span class="p">,</span> <span class="nb">zip</span><span class="p">)</span>

<span class="kn">import</span> <span class="nn">collections</span> <span class="k">as</span> <span class="nn">c</span>
<span class="kn">import</span> <span class="nn">contextlib</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">os.path</span> <span class="k">as</span> <span class="nn">op</span>
<span class="kn">import</span> <span class="nn">shutil</span>
<span class="kn">import</span> <span class="nn">subprocess</span> <span class="k">as</span> <span class="nn">sp</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">import</span> <span class="nn">tempfile</span> <span class="k">as</span> <span class="nn">tf</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">io</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span> <span class="c1">#Python 2</span>
    <span class="kn">import</span> <span class="nn">StringIO</span> <span class="k">as</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">pprint</span> <span class="k">import</span> <span class="n">pprint</span>


<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="kn">import</span> <span class="nn">scipy.spatial</span>
<span class="kn">import</span> <span class="nn">scipy.stats</span>

<span class="kn">import</span> <span class="nn">Bio.PDB</span> <span class="k">as</span> <span class="nn">bpdb</span>

<span class="kn">from</span> <span class="nn">logging_exceptions</span> <span class="k">import</span> <span class="n">log_to_exception</span><span class="p">,</span> <span class="n">log_exception</span>


<span class="kn">from</span> <span class="nn">...graph</span> <span class="k">import</span> <span class="n">bulge_graph</span> <span class="k">as</span> <span class="n">fgb</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">graph_pdb</span> <span class="k">as</span> <span class="n">ftug</span>
<span class="kn">from</span> <span class="nn">..model</span> <span class="k">import</span> <span class="n">stats</span> <span class="k">as</span> <span class="n">ftms</span>

<span class="kn">from</span> <span class="nn">..._k2n_standalone</span> <span class="k">import</span> <span class="n">knotted2nested</span> <span class="k">as</span> <span class="n">cak</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">mcannotate</span> <span class="k">as</span> <span class="n">ftum</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">pdb</span> <span class="k">as</span> <span class="n">ftup</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">descriptors</span> <span class="k">as</span> <span class="n">ftud</span>
<span class="kn">from</span> <span class="nn">..utilities</span> <span class="k">import</span> <span class="n">vector</span> <span class="k">as</span> <span class="n">ftuv</span>
<span class="kn">from</span> <span class="nn">...utilities</span> <span class="k">import</span> <span class="n">debug</span> <span class="k">as</span> <span class="n">fud</span>
<span class="kn">from</span> <span class="nn">...utilities</span> <span class="k">import</span> <span class="n">stuff</span> <span class="k">as</span> <span class="n">fus</span>
<span class="kn">from</span> <span class="nn">...utilities.observedDict</span> <span class="k">import</span> <span class="n">observedDict</span>
<span class="kn">from</span> <span class="nn">...utilities.exceptions</span> <span class="k">import</span> <span class="n">CgConstructionError</span><span class="p">,</span> <span class="n">CgIntegrityError</span><span class="p">,</span> <span class="n">GraphConstructionError</span>
<span class="kn">from</span> <span class="nn">.linecloud</span> <span class="k">import</span> <span class="n">CoordinateStorage</span><span class="p">,</span> <span class="n">LineSegmentStorage</span>
<span class="kn">from</span> <span class="nn">...utilities.stuff</span> <span class="k">import</span> <span class="n">is_string_type</span>


<span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
  <span class="n">profile</span>  <span class="c1">#The @profile decorator from line_profiler (kernprof)</span>
<span class="k">except</span><span class="p">:</span>
<div class="viewcode-block" id="profile"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.profile">[docs]</a>  <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span></div>

<div class="viewcode-block" id="remove_hetatm"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.remove_hetatm">[docs]</a><span class="k">def</span> <span class="nf">remove_hetatm</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Go through the lines of a pdb file and remove any which refer to a</span>
<span class="sd">    HETATM.</span>

<span class="sd">    :param lines: A an array of lines of text from a pdb file.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">new_lines</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;HETATM&#39;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;5MU&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;5MU&#39;</span><span class="p">,</span> <span class="s1">&#39;  U&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;PSU&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;PSU&#39;</span><span class="p">,</span> <span class="s1">&#39;  U&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;5MC&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;5MC&#39;</span><span class="p">,</span> <span class="s1">&#39;  C&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;1MG&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;1MG&#39;</span><span class="p">,</span> <span class="s1">&#39;  G&#39;</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s1">&#39;H2U&#39;</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;H2U&#39;</span><span class="p">,</span> <span class="s1">&#39;  G&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">continue</span>

        <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;HETATM&#39;</span><span class="p">,</span> <span class="s1">&#39;ATOM  &#39;</span><span class="p">)</span>
        <span class="n">new_lines</span> <span class="o">+=</span> <span class="p">[</span><span class="n">line</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">new_lines</span></div>


<div class="viewcode-block" id="add_longrange_interactions"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.add_longrange_interactions">[docs]</a><span class="k">def</span> <span class="nf">add_longrange_interactions</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">lines</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Iterate over the lines in an MC-Annotate file and add information</span>
<span class="sd">    about interactions between non-adjacent elements.</span>

<span class="sd">    :param cg: A CoarseGrainRNA structure</span>
<span class="sd">    :param lines: All the lines in an MC-Annotate file</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">ftum</span><span class="o">.</span><span class="n">iterate_over_interactions</span><span class="p">(</span><span class="n">lines</span><span class="p">):</span>
        <span class="p">(</span><span class="n">from_chain</span><span class="p">,</span> <span class="n">from_base</span><span class="p">,</span> <span class="n">to_chain</span><span class="p">,</span> <span class="n">to_base</span><span class="p">)</span> <span class="o">=</span>  <span class="n">ftum</span><span class="o">.</span><span class="n">get_interacting_base_pairs</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">seq_id1</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">fgb</span><span class="o">.</span><span class="n">RESID</span><span class="p">(</span><span class="n">from_chain</span><span class="p">,</span> <span class="n">ftum</span><span class="o">.</span><span class="n">parse_resid</span><span class="p">(</span><span class="n">from_base</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">except</span> <span class="ne">ValueError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">log_to_exception</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;seq_ids are </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">))</span>
            <span class="k">raise</span>
        <span class="n">seq_id2</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">fgb</span><span class="o">.</span><span class="n">RESID</span><span class="p">(</span><span class="n">to_chain</span><span class="p">,</span> <span class="n">ftum</span><span class="o">.</span><span class="n">parse_resid</span><span class="p">(</span><span class="n">to_base</span><span class="p">)))</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">node1</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">seq_id1</span><span class="p">)</span>
        <span class="n">node2</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">seq_id2</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">seq_id2</span> <span class="o">-</span> <span class="n">seq_id1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">node1</span> <span class="o">!=</span> <span class="n">node2</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cg</span><span class="o">.</span><span class="n">has_connection</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
            <span class="n">cg</span><span class="o">.</span><span class="n">longrange</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
            <span class="n">cg</span><span class="o">.</span><span class="n">longrange</span><span class="p">[</span><span class="n">node2</span><span class="p">]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span></div>

<div class="viewcode-block" id="breakpoints_from_residuemap"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.breakpoints_from_residuemap">[docs]</a><span class="k">def</span> <span class="nf">breakpoints_from_residuemap</span><span class="p">(</span><span class="n">residue_map</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create the list of cofold cutpoints from the list of MC-Annotate identifiers in the</span>
<span class="sd">    residue map.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">breakpoints</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">old_chain</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">residue_map</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">residue_map</span><span class="p">):</span>
        <span class="p">(</span><span class="n">from_chain</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">ftum</span><span class="o">.</span><span class="n">parse_chain_base</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">old_chain</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">from_chain</span> <span class="o">!=</span> <span class="n">old_chain</span><span class="p">:</span>
            <span class="n">breakpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
        <span class="n">old_chain</span> <span class="o">=</span> <span class="n">from_chain</span>
    <span class="k">return</span> <span class="n">breakpoints</span></div>

<span class="k">def</span> <span class="nf">_are_adjacent_basepairs</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function used by connected_cgs_from_pdb.</span>

<span class="sd">    :param cg: A (potentially) inconsistent cg. Only seq_ids are needed.</span>
<span class="sd">    :param edge1, edge2: A dictionary with the key &quot;basepair&quot; mapping to a two-tuple of RESIDS</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">fromA</span><span class="p">,</span> <span class="n">toA</span> <span class="o">=</span> <span class="n">edge1</span><span class="p">[</span><span class="s2">&quot;basepair&quot;</span><span class="p">]</span>
    <span class="n">fromB</span><span class="p">,</span> <span class="n">toB</span> <span class="o">=</span> <span class="n">edge2</span><span class="p">[</span><span class="s2">&quot;basepair&quot;</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">fromA</span><span class="o">.</span><span class="n">chain</span> <span class="o">!=</span> <span class="n">fromB</span><span class="o">.</span><span class="n">chain</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">fromA</span><span class="o">.</span><span class="n">chain</span><span class="o">==</span><span class="n">toB</span><span class="o">.</span><span class="n">chain</span><span class="p">:</span>
            <span class="n">fromB</span><span class="p">,</span> <span class="n">toB</span> <span class="o">=</span> <span class="n">toB</span><span class="p">,</span> <span class="n">fromB</span>
            <span class="k">assert</span> <span class="n">toA</span><span class="o">.</span><span class="n">chain</span><span class="o">==</span><span class="n">toB</span><span class="o">.</span><span class="n">chain</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">assert</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">fromA</span><span class="p">)</span><span class="o">-</span><span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">fromB</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">toA</span><span class="p">)</span><span class="o">-</span><span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">toB</span><span class="p">))</span><span class="o">==</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Basepairs </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2"> are adjacent. No length 1 stem&quot;</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">True</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Basepairs </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2"> are NOT adjacent.&quot;</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">False</span>

<span class="k">def</span> <span class="nf">_run_mc_annotate</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">subprocess_kwargs</span><span class="o">=</span><span class="p">{}):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">check_output</span><span class="p">([</span><span class="s1">&#39;MC-Annotate&#39;</span><span class="p">,</span> <span class="n">filename</span><span class="p">],</span> <span class="n">universal_newlines</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">subprocess_kwargs</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">OSError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">op</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">),</span> <span class="s2">&quot;File </span><span class="si">{}</span><span class="s2"> (created by forgi) no longer exists&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">e</span><span class="o">.</span><span class="n">strerror</span><span class="o">+=</span><span class="s2">&quot;. Hint: Did you install MC-Annotate?&quot;</span>
        <span class="k">raise</span> <span class="n">e</span>
    <span class="k">return</span> <span class="n">out</span>

<div class="viewcode-block" id="connected_cgs_from_pdb"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.connected_cgs_from_pdb">[docs]</a><span class="k">def</span> <span class="nf">connected_cgs_from_pdb</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
    <span class="k">with</span> <span class="n">fus</span><span class="o">.</span><span class="n">make_temp_directory</span><span class="p">()</span> <span class="k">as</span> <span class="n">output_dir</span><span class="p">:</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="n">ftup</span><span class="o">.</span><span class="n">get_all_chains</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">)</span>
        <span class="n">new_chains</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Loaded Chain </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chain</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">chain</span> <span class="o">=</span> <span class="n">ftup</span><span class="o">.</span><span class="n">clean_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
            <span class="n">new_chains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>

        <span class="n">rna_pdb_fn</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;temp.pdb&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">rna_pdb_fn</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="c1">#We need to output in pdb format for MC-Annotate</span>
            <span class="n">ftup</span><span class="o">.</span><span class="n">output_multiple_chains</span><span class="p">(</span><span class="n">new_chains</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

        <span class="c1"># first we annotate the 3D structure</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting MC-Annotate for all chains&quot;</span><span class="p">)</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">_run_mc_annotate</span><span class="p">(</span><span class="n">rna_pdb_fn</span><span class="p">)</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

        <span class="c1"># convert the mcannotate output into bpseq format</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="p">(</span><span class="n">dotplot</span><span class="p">,</span> <span class="n">residue_map</span><span class="p">)</span> <span class="o">=</span> <span class="n">ftum</span><span class="o">.</span><span class="n">get_dotplot</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="nb">print</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stderr</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">[]</span>

        <span class="c1"># f2 will store the dotbracket notation</span>
        <span class="c1">#with open(op.join(output_dir, &#39;temp.bpseq&#39;), &#39;w&#39;) as f2:</span>
        <span class="c1">#    f2.write(dotplot)</span>
        <span class="c1">#    f2.flush()</span>

        <span class="c1"># remove pseudoknots</span>
        <span class="k">if</span> <span class="n">remove_pseudoknots</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removing pseudoknots&quot;</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">k2n_main</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">dotplot</span><span class="p">),</span> <span class="n">input_format</span><span class="o">=</span><span class="s1">&#39;bpseq&#39;</span><span class="p">,</span>
                               <span class="c1">#output_format = &#39;vienna&#39;,</span>
                               <span class="n">output_format</span> <span class="o">=</span> <span class="s1">&#39;bpseq&#39;</span><span class="p">,</span>
                               <span class="n">method</span> <span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">DEFAULT_METHOD</span><span class="p">,</span>
                               <span class="n">opt_method</span> <span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">DEFAULT_OPT_METHOD</span><span class="p">,</span>
                               <span class="n">verbose</span> <span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">DEFAULT_VERBOSE</span><span class="p">,</span>
                               <span class="n">removed</span><span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">DEFAULT_REMOVED</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">dotplot</span>
        <span class="c1">#(out, residue_map) = add_missing_nucleotides(out, residue_map)</span>

        <span class="n">breakpoints</span> <span class="o">=</span> <span class="n">breakpoints_from_residuemap</span><span class="p">(</span><span class="n">residue_map</span><span class="p">)</span>


        <span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
        <span class="n">chain_connections_multigraph</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">MultiGraph</span><span class="p">()</span>
        <span class="n">cg</span> <span class="o">=</span> <span class="n">CoarseGrainRNA</span><span class="p">()</span>
        <span class="n">cg</span><span class="o">.</span><span class="n">seqids_from_residue_map</span><span class="p">(</span><span class="n">residue_map</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">out</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">from_</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">to_</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">from_seqid</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">from_</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">from_chain</span> <span class="o">=</span> <span class="n">from_seqid</span><span class="o">.</span><span class="n">chain</span>
            <span class="n">chain_connections_multigraph</span><span class="o">.</span><span class="n">add_node</span><span class="p">(</span><span class="n">from_chain</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">int</span><span class="p">(</span><span class="n">to_</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">int</span><span class="p">(</span><span class="n">to_</span><span class="p">)</span><span class="o">&gt;</span><span class="nb">int</span><span class="p">(</span><span class="n">from_</span><span class="p">):</span>
                <span class="n">to_seqid</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">to_</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">from_seqid</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">from_</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">to_seqid</span> <span class="o">=</span> <span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">to_</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">from_chain</span> <span class="o">=</span> <span class="n">from_seqid</span><span class="o">.</span><span class="n">chain</span>
                <span class="n">to_chain</span>   <span class="o">=</span> <span class="n">to_seqid</span><span class="o">.</span><span class="n">chain</span>
                <span class="k">if</span> <span class="n">from_chain</span> <span class="o">!=</span> <span class="n">to_chain</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding </span><span class="si">{}</span><span class="s2"> - </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">from_chain</span><span class="p">,</span> <span class="n">to_chain</span><span class="p">))</span>
                    <span class="n">chain_connections_multigraph</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">from_chain</span><span class="p">,</span> <span class="n">to_chain</span><span class="p">,</span> <span class="n">basepair</span><span class="o">=</span><span class="p">(</span><span class="n">from_seqid</span><span class="p">,</span> <span class="n">to_seqid</span><span class="p">))</span>
        <span class="n">chain_connections</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">(</span><span class="n">chain_connections_multigraph</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dissolve_length_one_stems</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">chain1</span><span class="p">,</span> <span class="n">chain2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">chain_connections_multigraph</span><span class="o">.</span><span class="n">nodes</span><span class="p">(),</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">chain2</span> <span class="ow">in</span> <span class="n">chain_connections_multigraph</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">chain1</span><span class="p">]:</span>
                    <span class="k">for</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">chain_connections_multigraph</span><span class="o">.</span><span class="n">adj</span><span class="p">[</span><span class="n">chain1</span><span class="p">][</span><span class="n">chain2</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="mi">2</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">_are_adjacent_basepairs</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">edge1</span><span class="p">,</span> <span class="n">edge2</span><span class="p">):</span>
                            <span class="k">break</span>
                    <span class="k">else</span><span class="p">:</span> <span class="c1">#break NOT encountered.</span>
                        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;No connection remaining between chains </span><span class="si">%s</span><span class="s2"> and </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chain1</span><span class="p">,</span> <span class="n">chain2</span><span class="p">)</span>
                        <span class="n">chain_connections</span><span class="o">.</span><span class="n">remove_edge</span><span class="p">(</span><span class="n">chain1</span><span class="p">,</span> <span class="n">chain2</span><span class="p">)</span>

        <span class="c1"># Now remove multiple edges. We don&#39;t care what nx does with the edge attributes.</span>

        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;CONNECTIONS: </span><span class="si">{}</span><span class="s2">, nodes </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain_connections</span><span class="p">,</span> <span class="n">chain_connections</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Edges </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">chain_connections</span><span class="o">.</span><span class="n">edges</span><span class="p">()))</span>
        <span class="n">cgs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">component</span> <span class="ow">in</span> <span class="n">nx</span><span class="o">.</span><span class="n">connected_components</span><span class="p">(</span><span class="n">chain_connections</span><span class="p">):</span>
            <span class="c1">#print(component, type(component))</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Loading PDB: Connected component with chains </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">component</span><span class="p">)))</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">cgs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">load_cg_from_pdb</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="n">remove_pseudoknots</span><span class="p">,</span> <span class="n">chain_id</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">component</span><span class="p">)))</span>
            <span class="k">except</span> <span class="n">GraphConstructionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="n">log_exception</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">logging</span><span class="o">.</span><span class="n">ERROR</span><span class="p">,</span> <span class="n">with_stacktrace</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Could not load chains </span><span class="si">%s</span><span class="s2">, due to the above mentioned error.&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">component</span><span class="p">))</span>
        <span class="n">cgs</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dissolve_length_one_stems</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">cg</span> <span class="ow">in</span> <span class="n">cgs</span><span class="p">:</span>
                <span class="n">cg</span><span class="o">.</span><span class="n">dissolve_length_one_stems</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">cgs</span></div>

<div class="viewcode-block" id="load_cg_from_pdb_in_dir"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.load_cg_from_pdb_in_dir">[docs]</a><span class="k">def</span> <span class="nf">load_cg_from_pdb_in_dir</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span> <span class="n">secondary_structure</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                            <span class="n">chain_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Create the coarse grain model from a pdb file and store all</span>
<span class="sd">    of the intermediate files in the given directory.</span>

<span class="sd">    :param pdb_filename: The name of the pdb file to be coarseified</span>
<span class="sd">    :param output_dir: The name of the output directory</span>
<span class="sd">    :param secondary_structure: Specify a particular secondary structure</span>
<span class="sd">                                for this coarsification.</span>
<span class="sd">    :param chain_id: The id of the chain to create the CG model from.</span>
<span class="sd">                    This can be one of the following:</span>

<span class="sd">                    * The string &quot;all&quot; in lowercase, to extract all chains.</span>
<span class="sd">                    * None, to extract the biggest chain</span>
<span class="sd">                    * A (single-letter) string containing the chain id</span>
<span class="sd">                    * A list of chain-ids. In that case only chains that match this id will be extracted.</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="c1">#chain = ftup.load_structure(pdb_filename)</span>
    <span class="n">chains</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="n">chain_id</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="n">ftup</span><span class="o">.</span><span class="n">get_all_chains</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">chain_id</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="p">[</span><span class="n">ftup</span><span class="o">.</span><span class="n">get_biggest_chain</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">)]</span>
    <span class="k">elif</span> <span class="n">is_string_type</span><span class="p">(</span><span class="n">chain_id</span><span class="p">):</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="p">[</span><span class="n">ftup</span><span class="o">.</span><span class="n">get_particular_chain</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">chain_id</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">)]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="n">ftup</span><span class="o">.</span><span class="n">get_all_chains</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">)</span>
        <span class="n">chains</span> <span class="o">=</span> <span class="p">[</span> <span class="n">chain</span> <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">chains</span> <span class="k">if</span> <span class="n">chain</span><span class="o">.</span><span class="n">id</span> <span class="ow">in</span> <span class="n">chain_id</span> <span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">chain_id</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">chains</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">CgConstructionError</span><span class="p">(</span><span class="s2">&quot;Bad chain-id given. &quot;</span>
                                      <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> not present (or not an RNA)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="nb">set</span><span class="p">(</span><span class="n">chain_id</span><span class="p">)</span> <span class="o">-</span>
                                                                                       <span class="nb">set</span><span class="p">([</span><span class="n">chain</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">])))</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Before cleanup: chains-&gt; residues: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">chain</span><span class="o">.</span><span class="n">id</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span> <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">})</span>
    <span class="n">new_chains</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">chains</span><span class="p">:</span>
        <span class="n">chain</span> <span class="o">=</span> <span class="n">ftup</span><span class="o">.</span><span class="n">clean_chain</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
        <span class="n">new_chains</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;After cleanup: chains-&gt; residues: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">chain</span><span class="o">.</span><span class="n">id</span><span class="p">:</span><span class="nb">len</span><span class="p">(</span><span class="n">chain</span><span class="p">)</span> <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">new_chains</span><span class="p">})</span>

    <span class="n">pdb_base</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">splitext</span><span class="p">(</span><span class="n">op</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">new_chains</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="n">pdb_base</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="n">new_chains</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">id</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">pdb_base</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">new_chains</span><span class="p">)</span>

    <span class="n">cg</span> <span class="o">=</span> <span class="n">CoarseGrainRNA</span><span class="p">()</span>
    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chain</span><span class="o">.</span><span class="n">get_list</span><span class="p">())</span> <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">new_chains</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cg</span>

    <span class="c1"># output a pdb with RNA only (for MCAnnotate):</span>
    <span class="n">output_dir</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="n">pdb_base</span> <span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">op</span><span class="o">.</span><span class="n">exists</span><span class="p">(</span><span class="n">output_dir</span><span class="p">):</span>
        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">output_dir</span><span class="p">)</span>
    <span class="n">rna_pdb_fn</span> <span class="o">=</span> <span class="n">op</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">output_dir</span><span class="p">,</span> <span class="s1">&#39;temp.pdb&#39;</span><span class="p">)</span>
    <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">rna_pdb_fn</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
        <span class="c1">#We need to output in pdb format for MC-Annotate</span>
        <span class="n">ftup</span><span class="o">.</span><span class="n">output_multiple_chains</span><span class="p">(</span><span class="n">new_chains</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>

    <span class="c1"># first we annotate the 3D structure</span>
    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Starting MC-Annotate for chain(s) </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">chain_id</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="s2">&quot;DEVNULL&quot;</span><span class="p">):</span> <span class="c1">#python&gt;=3.3</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;stderr&quot;</span><span class="p">:</span><span class="n">sp</span><span class="o">.</span><span class="n">DEVNULL</span><span class="p">}</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">_run_mc_annotate</span><span class="p">(</span><span class="n">rna_pdb_fn</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>

    <span class="n">lines</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>

    <span class="c1"># convert the mcannotate output into bpseq format</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="p">(</span><span class="n">dotplot</span><span class="p">,</span> <span class="n">residue_map</span><span class="p">)</span> <span class="o">=</span> <span class="n">ftum</span><span class="o">.</span><span class="n">get_dotplot</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="n">log</span><span class="o">.</span><span class="n">exception</span><span class="p">(</span><span class="s2">&quot;Could not convert MC-Annotate output to dotplot&quot;</span><span class="p">)</span>
        <span class="k">raise</span> <span class="n">CgConstructionError</span><span class="p">(</span><span class="s2">&quot;Could not convert MC-Annotate output to dotplot&quot;</span><span class="p">)</span> <span class="c1">#from e</span>

    <span class="c1"># f2 will store the dotbracket notation</span>
    <span class="c1">#with open(op.join(output_dir, &#39;temp.bpseq&#39;), &#39;w&#39;) as f2:</span>
    <span class="c1">#    f2.write(dotplot)</span>
    <span class="c1">#    f2.flush()</span>


    <span class="k">if</span> <span class="n">secondary_structure</span><span class="p">:</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Not adding any longrange interactions because secondary structure is given.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">remove_pseudoknots</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Option &#39;remove_pseudoknots ignored, because secondary structure is given.&quot;</span><span class="p">)</span>
        <span class="n">cg</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="n">secondary_structure</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="n">dissolve_length_one_stems</span><span class="p">)</span>
        <span class="n">breakpoints</span> <span class="o">=</span> <span class="n">breakpoints_from_residuemap</span><span class="p">(</span><span class="n">residue_map</span><span class="p">)</span>
        <span class="n">cg</span><span class="o">.</span><span class="n">seqids_from_residue_map</span><span class="p">(</span><span class="n">residue_map</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">remove_pseudoknots</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Removing pseudoknots&quot;</span><span class="p">)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">k2n_main</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">dotplot</span><span class="p">),</span> <span class="n">input_format</span><span class="o">=</span><span class="s1">&#39;bpseq&#39;</span><span class="p">,</span>
                               <span class="c1">#output_format = &#39;vienna&#39;,</span>
                               <span class="n">output_format</span> <span class="o">=</span> <span class="s1">&#39;bpseq&#39;</span><span class="p">,</span>
                               <span class="n">method</span> <span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">DEFAULT_METHOD</span><span class="p">,</span>
                               <span class="n">opt_method</span> <span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">DEFAULT_OPT_METHOD</span><span class="p">,</span>
                               <span class="n">verbose</span> <span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">DEFAULT_VERBOSE</span><span class="p">,</span>
                               <span class="n">removed</span><span class="o">=</span> <span class="n">cak</span><span class="o">.</span><span class="n">DEFAULT_REMOVED</span><span class="p">)</span>

            <span class="n">out</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39; Nested structure&#39;</span><span class="p">,</span> <span class="n">pdb_base</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">dotplot</span>
        <span class="n">breakpoints</span> <span class="o">=</span> <span class="n">breakpoints_from_residuemap</span><span class="p">(</span><span class="n">residue_map</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Breakpoints in </span><span class="si">%s</span><span class="s2"> are </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">pdb_base</span><span class="p">,</span> <span class="n">breakpoints</span><span class="p">)</span>
        <span class="n">cg</span><span class="o">.</span><span class="n">from_bpseq_str</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">breakpoints</span> <span class="o">=</span> <span class="n">breakpoints</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="n">dissolve_length_one_stems</span><span class="p">)</span> <span class="c1">#Sets the seq without cutpoints</span>
        <span class="n">cg</span><span class="o">.</span><span class="n">seqids_from_residue_map</span><span class="p">(</span><span class="n">residue_map</span><span class="p">)</span>
        <span class="n">add_longrange_interactions</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">lines</span><span class="p">)</span>


    <span class="n">cg</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">pdb_base</span>
    <span class="c1"># Add the 3D information about the starts and ends of the stems</span>
    <span class="c1"># and loops</span>
    <span class="n">cg</span><span class="o">.</span><span class="n">chains</span> <span class="o">=</span> <span class="p">{</span> <span class="n">chain</span><span class="o">.</span><span class="n">id</span> <span class="p">:</span> <span class="n">chain</span> <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">new_chains</span> <span class="p">}</span>
    <span class="n">cg</span><span class="o">.</span><span class="n">chain_ids</span> <span class="o">=</span> <span class="p">[</span> <span class="n">chain</span><span class="o">.</span><span class="n">id</span> <span class="k">for</span> <span class="n">chain</span> <span class="ow">in</span> <span class="n">new_chains</span> <span class="p">]</span>

    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;First 10 seq-IDs of loaded structure are </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">cg</span><span class="o">.</span><span class="n">seq_ids</span><span class="p">[:</span><span class="mi">10</span><span class="p">])</span>
    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Elements </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">cg</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="c1">#Stems can span 2 chains.</span>
    <span class="n">ftug</span><span class="o">.</span><span class="n">add_stem_information_from_pdb_chains</span><span class="p">(</span><span class="n">cg</span><span class="p">)</span>
    <span class="n">cg</span><span class="o">.</span><span class="n">add_bulge_coords_from_stems</span><span class="p">()</span>
    <span class="n">ftug</span><span class="o">.</span><span class="n">add_loop_information_from_pdb_chains</span><span class="p">(</span><span class="n">cg</span><span class="p">)</span>
    <span class="n">cg</span><span class="o">.</span><span class="n">incomplete_elements</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_incomplete_elements</span><span class="p">(</span><span class="n">cg</span><span class="p">)</span>

    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">coords</span><span class="p">),</span> <span class="n">cg</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">^</span><span class="n">cg</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="c1">#with open(op.join(output_dir, &#39;temp.cg&#39;), &#39;w&#39;) as f3:</span>
    <span class="c1">#    f3.write(cg.to_cg_string())</span>
    <span class="c1">#    f3.flush()</span>

    <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Sequence </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">seq</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">cg</span></div>

<div class="viewcode-block" id="load_cg_from_pdb"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.load_cg_from_pdb">[docs]</a><span class="k">def</span> <span class="nf">load_cg_from_pdb</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">secondary_structure</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                     <span class="n">intermediate_file_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chain_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                    <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Load a coarse grain model from a PDB file, by extracing</span>
<span class="sd">    the bulge graph.</span>

<span class="sd">    :param pdb_filename: The filename of the 3D model</span>
<span class="sd">    :param secondary_structure: A dot-bracket string encoding the secondary</span>
<span class="sd">                                structure of this molecule</span>
<span class="sd">    &#39;&#39;&#39;</span>

    <span class="k">if</span> <span class="n">intermediate_file_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">output_dir</span> <span class="o">=</span> <span class="n">intermediate_file_dir</span>

        <span class="n">cg</span> <span class="o">=</span> <span class="n">load_cg_from_pdb_in_dir</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span>
                                     <span class="n">secondary_structure</span><span class="p">,</span> <span class="n">chain_id</span><span class="o">=</span><span class="n">chain_id</span><span class="p">,</span>
                                    <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="n">remove_pseudoknots</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span>
                                    <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="n">dissolve_length_one_stems</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">with</span> <span class="n">fus</span><span class="o">.</span><span class="n">make_temp_directory</span><span class="p">()</span> <span class="k">as</span> <span class="n">output_dir</span><span class="p">:</span>
            <span class="n">cg</span> <span class="o">=</span> <span class="n">load_cg_from_pdb_in_dir</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">output_dir</span><span class="p">,</span>
                                         <span class="n">secondary_structure</span><span class="p">,</span> <span class="n">chain_id</span> <span class="o">=</span> <span class="n">chain_id</span><span class="p">,</span>
                                        <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="n">remove_pseudoknots</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span>
                                        <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="n">dissolve_length_one_stems</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">cg</span></div>

<div class="viewcode-block" id="from_pdb"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.from_pdb">[docs]</a><span class="k">def</span> <span class="nf">from_pdb</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">secondary_structure</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">intermediate_file_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">chain_id</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="n">cg</span> <span class="o">=</span> <span class="n">load_cg_from_pdb</span><span class="p">(</span><span class="n">pdb_filename</span><span class="p">,</span> <span class="n">secondary_structure</span><span class="p">,</span>
                          <span class="n">intermediate_file_dir</span><span class="p">,</span> <span class="n">chain_id</span><span class="o">=</span><span class="n">chain_id</span><span class="p">,</span>
                         <span class="n">remove_pseudoknots</span><span class="o">=</span><span class="n">remove_pseudoknots</span><span class="p">,</span> <span class="n">parser</span><span class="o">=</span><span class="n">parser</span><span class="p">,</span>
                         <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="n">dissolve_length_one_stems</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">cg</span></div>

<div class="viewcode-block" id="from_bulge_graph"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.from_bulge_graph">[docs]</a><span class="k">def</span> <span class="nf">from_bulge_graph</span><span class="p">(</span><span class="n">bulge_graph</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Create a CoarseGrainRNA from a BulgeGraph</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">bulge_graph</span><span class="o">.</span><span class="n">seq</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">CgConstructionError</span><span class="p">(</span><span class="s2">&quot;Sequence missing in BulgeGraph. Cannot create CoarseGrainRNA.&quot;</span><span class="p">)</span>
    <span class="n">bg_str</span> <span class="o">=</span> <span class="n">bulge_graph</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>
    <span class="n">cg</span> <span class="o">=</span> <span class="n">CoarseGrainRNA</span><span class="p">()</span>
    <span class="n">cg</span><span class="o">.</span><span class="n">from_cg_string</span><span class="p">(</span><span class="n">bg_str</span><span class="p">)</span>
    <span class="k">return</span>  <span class="n">cg</span></div>

<div class="viewcode-block" id="RnaMissing3dError"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.RnaMissing3dError">[docs]</a><span class="k">class</span> <span class="nc">RnaMissing3dError</span><span class="p">(</span><span class="ne">LookupError</span><span class="p">):</span>
    <span class="k">pass</span></div>

<div class="viewcode-block" id="CoarseGrainRNA"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA">[docs]</a><span class="k">class</span> <span class="nc">CoarseGrainRNA</span><span class="p">(</span><span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    A coarse grain model of RNA structure based on the</span>
<span class="sd">    bulge graph representation.</span>

<span class="sd">    Each stem is represented by four parameters (two endpoints)</span>
<span class="sd">    and two twist vetors pointing towards the centers of the base</span>
<span class="sd">    pairs at each end of the helix.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cg_file</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">seq</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initialize the new structure.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CoarseGrainRNA</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">cg_file</span><span class="p">,</span> <span class="n">dotbracket_str</span><span class="p">,</span> <span class="n">seq</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="o">=</span><span class="p">{}</span>
        <span class="c1">#: Keys are element identifiers (e.g.: &quot;s1&quot; or &quot;i3&quot;), values are 2-tuples of vectors</span>
        <span class="c1">#: The first value of stem coordinates corresponds to the start of the stem</span>
        <span class="c1">#: (the one with the lowest nucleotide number),</span>
        <span class="c1">#: The second value to the end of the stem.</span>
        <span class="c1">#: If the coordinates for an element change, the virtual atom and virtual residue</span>
        <span class="c1">#: coordinates are automatically invalidated.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="kc">None</span> <span class="c1">#We can only initialize this, when we know defines.keys()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">twists</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sampled</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_init_coords</span><span class="p">()</span>

        <span class="c1">#:The following 5 defaultdicts are cleared when coords or twists change.</span>
        <span class="c1">#: Global (carthesian) position of the virtual residue</span>
        <span class="c1">#: (=offset of the residue&#39;s coordinate-system)</span>
        <span class="c1">#: generated by self.add_all_virtual_residues()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vposs</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span>
        <span class="c1">#: The coordinate system specific to each virtual residue</span>
        <span class="c1">#: (3x3 matrix, carthesian coordiantes)</span>
        <span class="c1">#: generated by self.add_all_virtual_residues()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vbases</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span>
        <span class="c1">#: generated by self.add_all_virtual_residues()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vvecs</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span>
        <span class="c1">#: generated by self.add_all_virtual_residues()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span>
        <span class="c1">#: generated by self.add_all_virtual_residues()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vinvs</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span>

        <span class="c1">#: A 3D vector. Used as hint, from what direction the Projection2D object</span>
        <span class="c1">#: should be generated in the default case.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">project_from</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">set</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chains</span> <span class="o">=</span> <span class="p">{}</span> <span class="c1">#the PDB chain if loaded from a PDB file</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">incomplete_elements</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># An estimated list of cg-elements with missing residues.</span>

        <span class="k">if</span> <span class="n">cg_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">from_file</span><span class="p">(</span><span class="n">cg_file</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">CgConstructionError</span><span class="p">(</span><span class="s2">&quot;Empty CoarseGrainRNA created. Was &#39;</span><span class="si">{}</span><span class="s2">&#39; in *.cg/ *.coord file format?&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">cg_file</span><span class="p">))</span>

<div class="viewcode-block" id="CoarseGrainRNA.get_coord_str"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_coord_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_coord_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Place the start and end coordinates of each stem into a string.</span>

<span class="sd">        The format is:</span>

<span class="sd">            coord s1 x1 y1 z1 x2 y2 z2</span>

<span class="sd">        Where s1 is the name of the stem, (x1,y1,z1) and (x2,y2,z2) are</span>
<span class="sd">        the two endpoints of the stem.</span>

<span class="sd">        :return: A string containing the coordinates for all of the stems.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;i&quot;</span><span class="p">]:</span> <span class="k">continue</span> <span class="c1">#Bulge coordinates are redundant. They can be deduced from the stem coordinates.</span>
            <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;coord </span><span class="si">{k}</span><span class="s2"> </span><span class="si">{x[0]:.16f}</span><span class="s2"> </span><span class="si">{x[1]:.16f}</span><span class="s2"> </span><span class="si">{x[2]:.16f}</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{y[0]:.16f}</span><span class="s2"> </span><span class="si">{y[1]:.16f}</span><span class="s2"> </span><span class="si">{y[2]:.16f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">out_str</span></div>
<div class="viewcode-block" id="CoarseGrainRNA.add_bulge_coords_from_stems"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.add_bulge_coords_from_stems">[docs]</a>    <span class="k">def</span> <span class="nf">add_bulge_coords_from_stems</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Add the information about the starts and ends of the bulges (i and m elements).</span>
<span class="sd">        The stems have to be created beforehand.</span>

<span class="sd">        This is called during loading of the RNA structure from pdb and from cg files.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">edges</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
                    <span class="p">(</span><span class="n">s2b</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>

                    <span class="n">mids1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">mids2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

                    <span class="c1">#Save coordinates in direction of the strand.</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_link_direction</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">d</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mids1</span><span class="p">[</span><span class="n">s1b</span><span class="p">],</span> <span class="n">mids2</span><span class="p">[</span><span class="n">s2b</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mids2</span><span class="p">[</span><span class="n">s2b</span><span class="p">],</span> <span class="n">mids1</span><span class="p">[</span><span class="n">s1b</span><span class="p">])</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.add_all_virtual_residues"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.add_all_virtual_residues">[docs]</a>    <span class="k">def</span> <span class="nf">add_all_virtual_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calls ftug.add_virtual_residues() for all stems of this RNA.</span>

<span class="sd">        .. note::</span>
<span class="sd">           Don&#39;t forget to call this again if you changed the structure of the RNA,</span>
<span class="sd">           to avoid leaving it in an inconsistent state.</span>

<span class="sd">        .. warning::</span>
<span class="sd">           Virtual residues are only added to stems, not to loop regions.</span>
<span class="sd">           The position of residues in loops is much more flexible, which is why virtual</span>
<span class="sd">           residue positions for loops usually do not make sense.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">stem</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Adding virtual residues for stem </span><span class="si">%s</span><span class="s2"> with coords </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stem</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem</span><span class="p">])</span>
                <span class="n">ftug</span><span class="o">.</span><span class="n">add_virtual_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">)</span>
            <span class="k">except</span> <span class="p">(</span><span class="ne">KeyError</span><span class="p">,</span> <span class="ne">ValueError</span><span class="p">,</span> <span class="ne">AssertionError</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem</span><span class="p">])):</span>
                    <span class="k">raise</span> <span class="n">RnaMissing3dError</span><span class="p">(</span><span class="s2">&quot;No 3D coordinates available for stem </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stem</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="p">[</span><span class="n">stem</span><span class="p">])):</span>
                    <span class="k">raise</span> <span class="n">RnaMissing3dError</span><span class="p">(</span><span class="s2">&quot;No twists available for stem </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">stem</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Reraising in add_all_virtual_residues&quot;</span><span class="p">)</span>
                    <span class="k">raise</span></div>
<div class="viewcode-block" id="CoarseGrainRNA.get_virtual_residue"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_virtual_residue">[docs]</a>    <span class="k">def</span> <span class="nf">get_virtual_residue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">allow_single_stranded</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the virtual residue for the nmucleotide at position pos (1-based)</span>

<span class="sd">        :param allow_single_stranded: If True and pos is not in a stem, return a</span>
<span class="sd">              rough estimate for the residue position instead of raising an error.</span>
<span class="sd">              Currenly, for non-stem elements, these positions are on the axis of the cg-element.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">elem</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span> <span class="ow">or</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span><span class="p">[</span><span class="n">elem</span><span class="p">]:</span>
                <span class="n">ftug</span><span class="o">.</span><span class="n">add_virtual_residues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elem</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">elem</span><span class="p">)):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span> <span class="o">==</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="n">vres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">vres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vres</span> <span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">-</span> <span class="n">i</span> <span class="o">==</span> <span class="n">pos</span><span class="p">:</span>
                    <span class="n">vres</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">return</span> <span class="n">vres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vres</span> <span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">allow_single_stranded</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Position </span><span class="si">{}</span><span class="s2"> is not in a stem! It is in </span><span class="si">{}</span><span class="s2">.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">elem</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;h&quot;</span><span class="p">:</span>
                <span class="c1">#We estimate the vres position along the axis of the hairpin.</span>
                <span class="n">h_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_length</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">h_length</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">h_length</span> <span class="o">-</span> <span class="p">(</span><span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">perc</span> <span class="o">=</span> <span class="n">l</span> <span class="o">/</span> <span class="n">h_length</span>
            <span class="k">elif</span> <span class="n">elem</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;i&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">pos</span><span class="o">&lt;=</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">1</span><span class="p">]:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">perc</span> <span class="o">=</span> <span class="n">l</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">tl</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">perc</span> <span class="o">=</span> <span class="p">(</span><span class="n">tl</span> <span class="o">-</span> <span class="n">l</span><span class="p">)</span><span class="o">/</span><span class="n">tl</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">perc</span> <span class="o">=</span> <span class="n">l</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">element_length</span><span class="p">(</span><span class="n">elem</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">elem</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">perc</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_ordered_stem_poss"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_ordered_stem_poss">[docs]</a>    <span class="k">def</span> <span class="nf">get_ordered_stem_poss</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_stem_iterator</span><span class="p">():</span>
            <span class="n">points</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">s</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_ordered_virtual_residue_poss"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_ordered_virtual_residue_poss">[docs]</a>    <span class="k">def</span> <span class="nf">get_ordered_virtual_residue_poss</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">return_elements</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the coordinates of all stem&#39;s virtual residues in a consistent order.</span>

<span class="sd">        This is used for RMSD calculation and is ment to replace ftug.bg_virtual_residues</span>
<span class="sd">        If no virtual_residue_positions are known, self.add_all_virtual_residues() is called</span>
<span class="sd">        automatically.</span>

<span class="sd">        :param return_elements: In addition to the positions, return a list with</span>
<span class="sd">                                the cg-elements these coordinates belong to</span>
<span class="sd">        :returns: A numpy array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_all_virtual_residues</span><span class="p">()</span>
        <span class="n">vress</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">elems</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sorted_stem_iterator</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                <span class="n">vres</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vress</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vres</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">vress</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">vres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vres</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">elems</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">s</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_elements</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vress</span><span class="p">),</span> <span class="n">elems</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vress</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_poss_for_domain"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_poss_for_domain">[docs]</a>    <span class="k">def</span> <span class="nf">get_poss_for_domain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;vres&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get an array of coordinates only for the elements specified.</span>

<span class="sd">        ..note::</span>

<span class="sd">            This code is still experimental in the current version of forgi.</span>

<span class="sd">        :param elements: A list of coarse grain element names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">points</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">if</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;fast&quot;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
                <span class="n">points</span> <span class="o">+=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">e</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">points</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mode</span><span class="o">==</span><span class="s2">&quot;vres&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_all_virtual_residues</span><span class="p">()</span>
            <span class="n">vress</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">elements</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">!=</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="k">continue</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">s</span><span class="p">)):</span>
                    <span class="n">vres</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span><span class="p">[</span><span class="n">s</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">vress</span> <span class="o">+=</span> <span class="p">[</span><span class="n">vres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vres</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">vres</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">vres</span><span class="p">[</span><span class="mi">3</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vress</span><span class="p">)</span>
        <span class="k">assert</span> <span class="kc">False</span></div>


<div class="viewcode-block" id="CoarseGrainRNA.steric_value"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.steric_value">[docs]</a>    <span class="k">def</span> <span class="nf">steric_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elements</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;r**-2&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Estimate, how difficult a set of elements was to build,</span>
<span class="sd">        by counting the atom density around the center of these elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">get_vector_centroid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">elements</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">elements</span><span class="o">.</span><span class="n">shape</span><span class="o">==</span><span class="p">(</span><span class="mi">3</span><span class="p">,):</span>
                <span class="n">center</span> <span class="o">=</span> <span class="n">elements</span>
            <span class="k">else</span><span class="p">:</span> <span class="k">assert</span> <span class="kc">False</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">elements</span><span class="p">,</span> <span class="nb">repr</span><span class="p">(</span><span class="n">elements</span><span class="p">))</span>
            <span class="k">raise</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;kde&quot;</span><span class="p">:</span>
        <span class="c1">#print(center)</span>
            <span class="n">all_vas</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">va</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_atoms</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">all_vas</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">va</span><span class="p">)</span>

            <span class="n">all_vas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_vas</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Shape of all atoms </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">all_vas</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="n">kde</span> <span class="o">=</span> <span class="n">scipy</span><span class="o">.</span><span class="n">stats</span><span class="o">.</span><span class="n">gaussian_kde</span><span class="p">(</span><span class="n">all_vas</span><span class="p">,</span> <span class="mi">50</span><span class="p">)</span> <span class="c1">#randomly take 50 Angstrom bandwidth</span>
            <span class="k">return</span> <span class="n">kde</span><span class="p">(</span><span class="n">center</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;r**&quot;</span><span class="p">):</span>
            <span class="n">power</span><span class="o">=-</span><span class="nb">int</span><span class="p">(</span><span class="n">method</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
            <span class="n">exclude</span><span class="o">=</span><span class="n">method</span><span class="p">[</span><span class="mi">5</span><span class="p">:]</span>
            <span class="k">if</span> <span class="n">exclude</span> <span class="ow">and</span> <span class="n">exclude</span><span class="o">!=</span><span class="s2">&quot;e&quot;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Not supported method&quot;</span><span class="p">)</span>
            <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">exclude</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">va</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_atoms</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="n">value</span><span class="o">+=</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">ftuv</span><span class="o">.</span><span class="n">vec_distance</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">center</span><span class="p">))</span><span class="o">**</span><span class="n">power</span>
            <span class="k">return</span> <span class="n">value</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;cutoff&quot;</span><span class="p">):</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">split</span><span class="p">()[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">value</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">va</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">virtual_atoms</span><span class="p">(</span><span class="n">pos</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_distance</span><span class="p">(</span><span class="n">va</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span><span class="o">&lt;</span> <span class="n">cutoff</span><span class="p">:</span>
                        <span class="n">value</span><span class="o">+=</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">value</span></div>
<div class="viewcode-block" id="CoarseGrainRNA.get_twist_str"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_twist_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_twist_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Place the twist vectors into a string.</span>

<span class="sd">        The format is:</span>

<span class="sd">            twist s1 x1 y1 z1 x2 y2 z2</span>

<span class="sd">        Where s1 is the name of the stem and (x1,y1,z1) and (x2,y2,z2) are</span>
<span class="sd">        the unit vectors from the start of each end of the stem to the middle</span>
<span class="sd">        of the base pairs.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="p">[</span><span class="n">p</span><span class="p">,</span> <span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;twist </span><span class="si">{k}</span><span class="s2"> </span><span class="si">{x[0]:.16f}</span><span class="s2"> </span><span class="si">{x[1]:.16f}</span><span class="s2"> </span><span class="si">{x[2]:.16f}</span><span class="s2"> &quot;</span>
                        <span class="s2">&quot;</span><span class="si">{y[0]:.16f}</span><span class="s2"> </span><span class="si">{y[1]:.16f}</span><span class="s2"> </span><span class="si">{y[2]:.16f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="n">key</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">n</span><span class="p">))</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span>
        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_long_range_str"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_long_range_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_long_range_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">printed</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">key1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">key2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span><span class="p">[</span><span class="n">key1</span><span class="p">]:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">]</span>
                <span class="n">k</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">printed</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">printed</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

                <span class="n">out_str</span> <span class="o">+=</span> <span class="s2">&quot;longrange </span><span class="si">%s</span><span class="s2"> </span><span class="si">%s</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key1</span><span class="p">,</span> <span class="n">key2</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_sampled_stems_str"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_sampled_stems_str">[docs]</a>    <span class="k">def</span> <span class="nf">get_sampled_stems_str</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">out_str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">out_str</span> <span class="o">+=</span> <span class="s1">&#39;sampled </span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled</span><span class="p">[</span><span class="n">key</span><span class="p">])))</span>
        <span class="k">return</span> <span class="n">out_str</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.to_cg_string"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.to_cg_string">[docs]</a>    <span class="k">def</span> <span class="nf">to_cg_string</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Output this structure in string form.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">curr_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>
        <span class="n">curr_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coord_str</span><span class="p">()</span>
        <span class="n">curr_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_twist_str</span><span class="p">()</span>
        <span class="n">curr_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sampled_stems_str</span><span class="p">()</span>
        <span class="n">curr_str</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_long_range_str</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">project_from</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">curr_str</span><span class="o">+=</span><span class="s2">&quot;project </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">project_from</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">curr_str</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.to_file"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.to_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">cg_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cg_string</span><span class="p">()</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">cg_str</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_bulge_angle_stats_core"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_bulge_angle_stats_core">[docs]</a>    <span class="k">def</span> <span class="nf">get_bulge_angle_stats_core</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">connections</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the angle stats for a particular bulge. These stats describe the</span>
<span class="sd">        relative orientation of the two stems that it connects.</span>

<span class="sd">        :param define: The name of the bulge.</span>
<span class="sd">        :param connections: The two stems that are connected by it.</span>
<span class="sd">        :return: ftms.AngleStat object</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Define </span><span class="si">%s</span><span class="s2"> connections </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span><span class="n">define</span><span class="p">,</span> <span class="n">connections</span><span class="p">)</span>
        <span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">twist1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">twist2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_stem_twist_and_bulge_vecs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">define</span><span class="p">,</span> <span class="n">connections</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;stem1 </span><span class="si">%s</span><span class="s2">, twist1 </span><span class="si">%s</span><span class="s2">, stem2 </span><span class="si">%s</span><span class="s2">, twist2 </span><span class="si">%s</span><span class="s2">, bulge </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stem1</span><span class="p">,</span> <span class="n">twist1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">twist2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">twist1</span><span class="p">),</span><span class="mi">10</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span> <span class="ow">or</span> <span class="nb">round</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">stem2</span><span class="p">,</span> <span class="n">twist2</span><span class="p">),</span><span class="mi">10</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">err</span> <span class="o">=</span> <span class="n">CgIntegrityError</span><span class="p">(</span><span class="s2">&quot;The twists are inconsistent. &quot;</span>
                               <span class="s2">&quot;They should be orthogonal to the corresponding stem vectors.&quot;</span>
                               <span class="s2">&quot;Inconsistency found for </span><span class="si">{}</span><span class="s2">,</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">define</span><span class="p">,</span> <span class="n">connections</span><span class="p">))</span>
            <span class="k">with</span> <span class="n">log_to_exception</span><span class="p">(</span><span class="n">log</span><span class="p">,</span><span class="n">err</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Angle stem1-twist1 </span><span class="si">%s</span><span class="s2"> dot_product=</span><span class="si">%s</span><span class="s2">, Angle stem2-twist2 </span><span class="si">%s</span><span class="s2"> degrees dot_product=</span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                          <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">vec_angle</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">twist1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">twist1</span><span class="p">),</span>
                          <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">vec_angle</span><span class="p">(</span><span class="n">stem2</span><span class="p">,</span> <span class="n">twist2</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">stem2</span><span class="p">,</span> <span class="n">twist2</span><span class="p">),)</span>
            <span class="k">raise</span> <span class="n">err</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span> <span class="n">u1</span><span class="p">,</span> <span class="n">v1</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_angle_stat_geometry</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">twist1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">twist2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">ZeroDivisionError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">log_to_error</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Error getting stats for define </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">define</span><span class="p">)</span>
            <span class="k">raise</span>
        <span class="n">dims</span> <span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="n">define</span><span class="p">)</span>
        <span class="n">ang_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">define</span><span class="p">,</span> <span class="n">connections</span><span class="p">)</span>
        <span class="n">seqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_define_seq_str</span><span class="p">(</span><span class="n">define</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;u </span><span class="si">%s</span><span class="s2">, v </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;m&quot;</span><span class="p">:</span>
            <span class="n">mls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_mlonly_multiloops</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">ml</span> <span class="ow">in</span> <span class="n">mls</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">define</span> <span class="ow">in</span> <span class="n">ml</span><span class="p">:</span>
                    <span class="n">descr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">describe_multiloop</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ml</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span><span class="s2">&quot;s&quot;</span><span class="p">])</span>
                    <span class="k">if</span> <span class="s2">&quot;pseudoknot&quot;</span> <span class="ow">in</span> <span class="n">descr</span><span class="p">:</span>
                        <span class="n">stat_type</span> <span class="o">=</span> <span class="s2">&quot;pseudo&quot;</span>
                    <span class="k">elif</span> <span class="s2">&quot;open&quot;</span> <span class="ow">in</span> <span class="n">descr</span><span class="p">:</span>
                        <span class="n">stat_type</span> <span class="o">=</span> <span class="s2">&quot;open&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">stat_type</span> <span class="o">=</span> <span class="s2">&quot;angle&quot;</span> <span class="c1">#ML</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">stat_type</span><span class="o">=</span><span class="s2">&quot;angle&quot;</span> <span class="c1">#IL</span>


        <span class="n">angle_stat</span> <span class="o">=</span> <span class="n">ftms</span><span class="o">.</span><span class="n">AngleStat</span><span class="p">(</span><span class="n">stat_type</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">r1</span><span class="p">,</span>
                                    <span class="n">u1</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">ang_type</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">define</span><span class="p">],</span>
                                    <span class="n">seqs</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">angle_stat</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_stats"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calls get_loop_stat/ get_bulge_angle_stats or get_stem_stats, depending on the element d.</span>

<span class="sd">        :returns: A 1- or 2 tuple of stats (2 in case of bulges. One for each direction)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_stem_stats</span><span class="p">(</span><span class="n">d</span><span class="p">),)</span>
        <span class="k">elif</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;mi&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_angle_stats</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">stat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_loop_stat</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">tuple</span><span class="p">()</span> <span class="c1">#A structure without any stem has no stats.</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span>
                <span class="n">stat</span><span class="o">.</span><span class="n">stat_type</span><span class="o">=</span><span class="s2">&quot;5prime&quot;</span>
            <span class="k">elif</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span>
                <span class="n">stat</span><span class="o">.</span><span class="n">stat_type</span><span class="o">=</span><span class="s2">&quot;3prime&quot;</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">stat</span><span class="p">,)</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_loop_stat"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_loop_stat">[docs]</a>    <span class="k">def</span> <span class="nf">get_loop_stat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the statistics for this loop.</span>

<span class="sd">        These stats describe the relative orientation of the loop to the stem</span>
<span class="sd">        to which it is attached.</span>

<span class="sd">        :param d: The name of the loop</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">loop_stat</span> <span class="o">=</span> <span class="n">ftms</span><span class="o">.</span><span class="n">LoopStat</span><span class="p">()</span>
        <span class="n">loop_stat</span><span class="o">.</span><span class="n">pdb_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>

        <span class="n">loop_stat</span><span class="o">.</span><span class="n">bp_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">loop_stat</span><span class="o">.</span><span class="n">phys_length</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">stem1</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="c1"># Make sure there is only one edge</span>

        <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">s1e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">stem1_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">s1b</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">s1e</span><span class="p">]</span>
        <span class="n">twist1_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">s1b</span><span class="p">]</span>
        <span class="n">bulge_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="n">bulge_vec</span><span class="p">)</span><span class="o">&lt;</span><span class="mi">10</span><span class="o">**-</span><span class="mi">3</span><span class="p">:</span> <span class="c1">#To avoid loops with 0 physical length. (If disconnects in the structure are modelled as loop)</span>
            <span class="n">bulge_vec</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">10</span><span class="o">**-</span><span class="mi">3</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">stem1_vec</span> <span class="o">/</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="n">stem1_vec</span><span class="p">))</span>

        <span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">u</span><span class="p">,</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_stem_separation_parameters</span><span class="p">(</span><span class="n">stem1_vec</span><span class="p">,</span> <span class="n">twist1_vec</span><span class="p">,</span>
                                                      <span class="n">bulge_vec</span><span class="p">)</span>
        <span class="p">(</span><span class="n">loop_stat</span><span class="o">.</span><span class="n">r</span><span class="p">,</span> <span class="n">loop_stat</span><span class="o">.</span><span class="n">u</span><span class="p">,</span> <span class="n">loop_stat</span><span class="o">.</span><span class="n">v</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
        <span class="n">loop_stat</span><span class="o">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">loop_stat</span><span class="o">.</span><span class="n">phys_length</span> <span class="c1"># Will this cause problems in other parts of the code base???</span>
        <span class="n">loop_stat</span><span class="o">.</span><span class="n">define</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
        <span class="n">loop_stat</span><span class="o">.</span><span class="n">seqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_define_seq_str</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;f&quot;</span><span class="p">:</span>
            <span class="n">loop_stat</span><span class="o">.</span><span class="n">stat_type</span> <span class="o">=</span> <span class="s2">&quot;5prime&quot;</span>
        <span class="k">elif</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;t&quot;</span><span class="p">:</span>
            <span class="n">loop_stat</span><span class="o">.</span><span class="n">stat_type</span> <span class="o">=</span> <span class="s2">&quot;3prime&quot;</span>
        <span class="k">return</span> <span class="n">loop_stat</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_bulge_angle_stats"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_bulge_angle_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_bulge_angle_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Return the angle stats for a particular bulge. These stats describe</span>
<span class="sd">        the relative orientation of the two stems that it connects.</span>

<span class="sd">        :param bulge: The name of the bulge.</span>
<span class="sd">        :param connections: The two stems that are connected by it.</span>
<span class="sd">        :return: The angle statistics in one direction and angle statistics in</span>
<span class="sd">                 the other direction</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">bulge</span> <span class="o">==</span> <span class="s1">&#39;start&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ftms</span><span class="o">.</span><span class="n">AngleStat</span><span class="p">(),</span> <span class="n">ftms</span><span class="o">.</span><span class="n">AngleStat</span><span class="p">())</span>

        <span class="n">connections</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge</span><span class="p">)</span>

        <span class="n">angle_stat1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_angle_stats_core</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="n">connections</span><span class="p">)</span>
        <span class="n">angle_stat2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_bulge_angle_stats_core</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">connections</span><span class="p">)))</span>

        <span class="k">assert</span> <span class="nb">round</span><span class="p">(</span><span class="n">angle_stat1</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(),</span><span class="mi">5</span><span class="p">)</span> <span class="o">==</span> <span class="nb">round</span><span class="p">(</span><span class="n">angle_stat2</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(),</span><span class="mi">5</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">!=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">angle_stat1</span><span class="o">.</span><span class="n">get_angle</span><span class="p">(),</span> <span class="n">angle_stat2</span><span class="o">.</span><span class="n">get_angle</span><span class="p">()))</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">angle_stat1</span><span class="p">,</span> <span class="n">angle_stat2</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_stacking_helices"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_stacking_helices">[docs]</a>    <span class="k">def</span> <span class="nf">get_stacking_helices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Tyagi&quot;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL</span>

<span class="sd">        Return all helices (longer stacking regions) as sets.</span>

<span class="sd">        Two stems and one bulge are in a stacking relation, if self.is_stacking(bulge) is true and the stems are connected to the bulge.</span>
<span class="sd">        Further more, a stem is in a stacking relation with itself.</span>
<span class="sd">        A helix is the transitive closure this stacking relation.</span>

<span class="sd">        :returns: A list of sets of element names.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">helices</span><span class="o">=</span><span class="p">[]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;mi&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_stacking</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
                <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
                <span class="n">helices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">d</span><span class="p">,</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;s&quot;</span><span class="p">:</span>
                <span class="n">helices</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">([</span><span class="n">d</span><span class="p">]))</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">j</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">helices</span><span class="p">)),</span><span class="mi">2</span><span class="p">):</span>
                <span class="n">stack_bag1</span> <span class="o">=</span> <span class="n">helices</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">stack_bag2</span> <span class="o">=</span> <span class="n">helices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">stack_bag1</span> <span class="o">&amp;</span> <span class="n">stack_bag2</span><span class="p">:</span>
                    <span class="n">stack_bag1</span><span class="o">|=</span><span class="n">stack_bag2</span>
                    <span class="k">del</span> <span class="n">helices</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="k">break</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">break</span>
        <span class="k">return</span> <span class="n">helices</span></div>
<div class="viewcode-block" id="CoarseGrainRNA.is_stacking"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.is_stacking">[docs]</a>    <span class="k">def</span> <span class="nf">is_stacking</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;Tyagi&quot;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL</span>

<span class="sd">        Reports, whether the stems connected by the given bulge are coaxially stacking.</span>

<span class="sd">        :param bulge: STRING. Name of a interior loop or multiloop (e.g. &quot;m3&quot;)</span>
<span class="sd">        :param method&quot;: STRING. &quot;Tyagi&quot;: Use cutoffs from doi:10.1261/rna.305307, PMCID: PMC1894924.</span>
<span class="sd">        :returns: A BOOLEAN.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">assert</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;Tyagi&quot;</span><span class="p">,</span> <span class="s2">&quot;CG&quot;</span> <span class="p">]</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;Tyagi&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stacking_tyagi</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_stacking_CG</span><span class="p">(</span><span class="n">bulge</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_is_stacking_CG</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge</span><span class="p">)</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">angle</span><span class="o">&gt;</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">angle</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">angle</span>
        <span class="k">if</span> <span class="n">angle</span><span class="o">&gt;</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">45</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Angle </span><span class="si">{}</span><span class="s2">&gt;45&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angle</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">shear_angle1</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">bulge</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">bulge</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">shear_angle1</span><span class="o">&gt;</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">shear_angle1</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">shear_angle1</span>
        <span class="n">shear_angle2</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                               <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">bulge</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">bulge</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">shear_angle2</span><span class="o">&gt;</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">shear_angle2</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">shear_angle2</span>
        <span class="k">if</span> <span class="n">shear_angle1</span><span class="o">&gt;</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span> <span class="ow">or</span> <span class="n">shear_angle2</span><span class="o">&gt;</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Shear angle 1 </span><span class="si">{}</span><span class="s2">&gt;60 or shear angle 2 </span><span class="si">{}</span><span class="s2">&gt;60&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">shear_angle1</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">shear_angle1</span><span class="p">)))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">_is_stacking_tyagi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bulge</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implementation of the method described in doi:10.1261/rna.305307 (Tyagi and Matthews) for</span>
<span class="sd">        the detection of coaxial stacking.</span>

<span class="sd">        Called by self.is_stacking(bulge, &quot;Tyagi&quot;)</span>

<span class="sd">        ..note::</span>
<span class="sd">            This does NOT implement the method for coaxial stacking prediction which is the main</span>
<span class="sd">            focus of the paper, only the method for the detection of stacking in pdb files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;mi&quot;</span>
        <span class="n">DISTANCE_CUTOFF</span> <span class="o">=</span> <span class="p">[</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">6</span> <span class="p">]</span>
        <span class="n">ANGLE_CUTOFF</span>    <span class="o">=</span> <span class="p">[</span>  <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="mf">0.75</span><span class="p">),</span> <span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="mf">0.8</span><span class="p">)</span> <span class="p">]</span>
        <span class="n">SHEAR_ANGLE_CUTOFF</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span> <span class="c1">#Relaxed compared to 60 in the paper, because we use</span>
                                              <span class="c1">#virtual atom positions</span>
        <span class="n">SHEAR_OFFSET_CUTOFF</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="k">if</span> <span class="n">bulge</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="s2">&quot;m&quot;</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">(</span><span class="n">bulge</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">is_flush</span> <span class="o">=</span> <span class="kc">True</span> <span class="c1">#flush-stack vs. mismatch-mediated stack</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">is_flush</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connections</span><span class="p">(</span><span class="n">bulge</span><span class="p">)</span>
        <span class="n">side_nts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_connected_residues</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1">#Distance</span>
        <span class="n">bp_center1</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_basepair_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side_nts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">bp_center2</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_basepair_center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side_nts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_distance</span><span class="p">(</span><span class="n">bp_center1</span><span class="p">,</span> <span class="n">bp_center2</span><span class="p">)</span><span class="o">&gt;</span><span class="n">DISTANCE_CUTOFF</span><span class="p">[</span><span class="n">is_flush</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Distance </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">vec_distance</span><span class="p">(</span><span class="n">bp_center1</span><span class="p">,</span> <span class="n">bp_center2</span><span class="p">),</span> <span class="n">DISTANCE_CUTOFF</span><span class="p">[</span><span class="n">is_flush</span><span class="p">]))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">normalvec1</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_basepair_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side_nts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">normalvec2</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_basepair_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">side_nts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1">#Coaxial</span>
        <span class="n">angle</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_angle</span><span class="p">(</span><span class="n">normalvec1</span><span class="p">,</span> <span class="n">normalvec2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">angle</span><span class="o">&gt;</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="c1">#Triggered frequently</span>
            <span class="c1">#warnings.warn(&quot;Angle &gt; 90 degrees: {} ({})&quot;.format(angle, math.degrees(angle)))</span>
            <span class="n">angle</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">angle</span>
        <span class="k">if</span> <span class="n">angle</span><span class="o">&gt;</span><span class="n">ANGLE_CUTOFF</span><span class="p">[</span><span class="n">is_flush</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Angle </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">ANGLE_CUTOFF</span><span class="p">[</span><span class="n">is_flush</span><span class="p">]))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1">#Shear Angle</span>
        <span class="n">shear_angle1</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_angle</span><span class="p">(</span><span class="n">normalvec1</span><span class="p">,</span> <span class="n">bp_center2</span><span class="o">-</span><span class="n">bp_center1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shear_angle1</span><span class="o">&gt;</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">shear_angle1</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">shear_angle1</span>
        <span class="k">if</span> <span class="n">shear_angle1</span><span class="o">&gt;</span><span class="n">SHEAR_ANGLE_CUTOFF</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Shear angle 1 </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shear_angle1</span><span class="p">,</span> <span class="n">SHEAR_ANGLE_CUTOFF</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">shear_angle2</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_angle</span><span class="p">(</span><span class="n">normalvec2</span><span class="p">,</span> <span class="n">bp_center1</span><span class="o">-</span><span class="n">bp_center2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">shear_angle2</span><span class="o">&gt;</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">shear_angle2</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">-</span><span class="n">shear_angle2</span>
        <span class="k">if</span> <span class="n">shear_angle2</span><span class="o">&gt;</span><span class="n">SHEAR_ANGLE_CUTOFF</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Shear angle 2 </span><span class="si">{}</span><span class="s2"> &gt; </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">shear_angle2</span><span class="p">,</span> <span class="n">SHEAR_ANGLE_CUTOFF</span><span class="p">))</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="c1">#Shear Offset</span>
        <span class="c1">#Formula for distance between a point and a line</span>
        <span class="c1">#from http://onlinemschool.com/math/library/analytic_geometry/p_line/</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">((</span><span class="n">bp_center1</span><span class="o">-</span><span class="n">bp_center2</span><span class="p">),</span> <span class="n">normalvec2</span><span class="p">))</span><span class="o">/</span>
                            <span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="n">normalvec2</span><span class="p">))</span><span class="o">&gt;</span><span class="n">SHEAR_OFFSET_CUTOFF</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Shear offset 1 wrong:&quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">((</span><span class="n">bp_center1</span><span class="o">-</span><span class="n">bp_center2</span><span class="p">),</span> <span class="n">normalvec2</span><span class="p">))</span><span class="o">/</span>
                                                         <span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="n">normalvec2</span><span class="p">)),</span> <span class="s2">&quot;&gt;&quot;</span> <span class="p">,</span> <span class="n">SHEAR_OFFSET_CUTOFF</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">((</span><span class="n">bp_center1</span><span class="o">-</span><span class="n">bp_center2</span><span class="p">),</span> <span class="n">normalvec1</span><span class="p">))</span><span class="o">/</span>
                            <span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="n">normalvec1</span><span class="p">))</span><span class="o">&gt;</span><span class="n">SHEAR_OFFSET_CUTOFF</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span> <span class="nb">print</span> <span class="p">(</span><span class="s2">&quot;Shear offset 2 wrong&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="kc">True</span>

<div class="viewcode-block" id="CoarseGrainRNA.get_stem_stats"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_stem_stats">[docs]</a>    <span class="k">def</span> <span class="nf">get_stem_stats</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the statistics for a stem and return them. These statistics will describe the</span>
<span class="sd">        length of the stem as well as how much it twists.</span>

<span class="sd">        :param stem: The name of the stem.</span>

<span class="sd">        :return: A StemStat structure containing the above information.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">ss</span> <span class="o">=</span> <span class="n">ftms</span><span class="o">.</span><span class="n">StemStat</span><span class="p">()</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">pdb_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span>
        <span class="c1">#ss.bp_length = abs(self.defines[stem][0] - self.defines[stem][1])</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">bp_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">stem</span><span class="p">)</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">phys_length</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">magnitude</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">twist_angle</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_twist_angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="p">[</span><span class="n">stem</span><span class="p">])</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">define</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">stem</span><span class="p">]</span>
        <span class="c1"># Stems may or may not have adjacent nucleotides, so we do not include the adj nucleotides</span>
        <span class="n">ss</span><span class="o">.</span><span class="n">seqs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_define_seq_str</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">adjacent</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ss</span></div>

    <span class="c1">#def get_loop_from_residue(self, residue) -&gt;  use BulgeGraph.get_node_from_residue_num()!</span>
    <span class="k">def</span> <span class="nf">_init_coords</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span> <span class="o">=</span> <span class="n">LineSegmentStorage</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">on_change</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_vatom_cache</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">twists</span> <span class="o">=</span> <span class="n">CoordinateStorage</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span> <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span><span class="s2">&quot;s&quot;</span><span class="p">],</span> <span class="n">on_change</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reset_vatom_cache</span><span class="p">)</span>
<div class="viewcode-block" id="CoarseGrainRNA.from_bpseq_str"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.from_bpseq_str">[docs]</a>    <span class="k">def</span> <span class="nf">from_bpseq_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bpseq_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">breakpoints</span> <span class="o">=</span> <span class="p">[]):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CoarseGrainRNA</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">from_bpseq_str</span><span class="p">(</span><span class="n">bpseq_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="p">,</span> <span class="n">breakpoints</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_coords</span><span class="p">()</span></div>
<div class="viewcode-block" id="CoarseGrainRNA.from_dotbracket"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.from_dotbracket">[docs]</a>    <span class="k">def</span> <span class="nf">from_dotbracket</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>  <span class="n">dotbracket_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">CoarseGrainRNA</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="p">,</span> <span class="n">dissolve_length_one_stems</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_coords</span><span class="p">()</span></div>
<div class="viewcode-block" id="CoarseGrainRNA.from_file"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.from_file">[docs]</a>    <span class="k">def</span> <span class="nf">from_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cg_filename</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Load this data structure from a file.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">cg_filename</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">())</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">from_cg_string</span><span class="p">(</span><span class="n">lines</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.from_cg_string"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.from_cg_string">[docs]</a>    <span class="k">def</span> <span class="nf">from_cg_string</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cg_string</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Populate this structure from the string</span>
<span class="sd">        representation of a graph.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Reading the bulge_graph-part of the file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">from_bg_string</span><span class="p">(</span><span class="n">cg_string</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_init_coords</span><span class="p">()</span>
        <span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;BG read. Now reading 3D information&quot;</span><span class="p">)</span>
        <span class="c1">#Reading the part of the file responsible for 3D information</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">cg_string</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
            <span class="n">line</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;coord&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">]))])</span>
            <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;twist&#39;</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">:</span><span class="mi">5</span><span class="p">])),</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">]))])</span>
            <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;longrange&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;sampled&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sampled</span><span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">parts</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span> <span class="o">+</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">parts</span><span class="p">[</span><span class="mi">3</span><span class="p">:]))</span>
            <span class="k">if</span> <span class="n">parts</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;project&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">project_from</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">float</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_bulge_coords_from_stems</span><span class="p">()</span> <span class="c1">#Old versions of the file may contain bulge coordinates in the wrong order.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">incomplete_elements</span> <span class="o">=</span> <span class="n">ftug</span><span class="o">.</span><span class="n">get_incomplete_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


<div class="viewcode-block" id="CoarseGrainRNA.to_cg_file"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.to_cg_file">[docs]</a>    <span class="k">def</span> <span class="nf">to_cg_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Save this structure as a string in a file.</span>

<span class="sd">        :param filename: The filename to save it to.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;to_cg_file is deprecated. Use to_file!&quot;</span><span class="p">,</span> <span class="n">stacklevel</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_cg_string</span><span class="p">()</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">s</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.radius_of_gyration"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.radius_of_gyration">[docs]</a>    <span class="k">def</span> <span class="nf">radius_of_gyration</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;vres&quot;</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the radius of gyration of this structure.</span>

<span class="sd">        :param method: A STRING. one of</span>
<span class="sd">                       &quot;fast&quot; (use only coordinates of coarse grained stems) or</span>
<span class="sd">                       &quot;vres&quot; (use virtual residue coordinates of stems)</span>

<span class="sd">        :return: A number with the radius of gyration of this structure.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">()))</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannnot calculate ROG (</span><span class="si">%s</span><span class="s2">) for structure </span><span class="si">%s</span><span class="s2"> without stems&quot;</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;nan&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;fast&quot;</span><span class="p">:</span>
            <span class="n">coords</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_ordered_stem_poss</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">method</span><span class="o">==</span><span class="s2">&quot;vres&quot;</span><span class="p">:</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_ordered_virtual_residue_poss</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Wrong method </span><span class="si">{}</span><span class="s2">. Choose one of &#39;fast&#39; and &#39;vres&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">method</span><span class="p">))</span>

        <span class="n">rog</span> <span class="o">=</span> <span class="n">ftud</span><span class="o">.</span><span class="n">radius_of_gyration</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rog</span></div>


<div class="viewcode-block" id="CoarseGrainRNA.assign_loop_roles"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.assign_loop_roles">[docs]</a>    <span class="k">def</span> <span class="nf">assign_loop_roles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL</span>

<span class="sd">        For 3-way junctions: Assign the roles P1, P2 and P3</span>
<span class="sd">        and J12, J31, J23 according to Lescoute and Westhof,</span>
<span class="sd">        RNA 2006 (doi: 10.1261/rna.2208106)</span>

<span class="sd">        We try to detect which helices stack and assign the roles in a way</span>
<span class="sd">        that J12 is always the stacking segment.</span>

<span class="sd">        :returns: None if no clear classification was possible,</span>
<span class="sd">                  a dictionary otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;junction_family is currentlty only implemented for 3-way junctions.&quot;</span><span class="p">)</span>
        <span class="c1"># Find out which helices stack.</span>
        <span class="c1"># Version 1: colinearity of helix axes:</span>
        <span class="n">stems</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">loop</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">loop</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">loop</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">stems</span><span class="p">)</span><span class="o">!=</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The multiloop segments do not form a 3-way junction.&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">log_to_exception</span><span class="p">(</span><span class="n">log</span><span class="p">,</span> <span class="n">e</span><span class="p">):</span>
                <span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;stems are </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">stems</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">e</span>
        <span class="n">collinearities</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">stems</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">line_segments_collinearity</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">])</span>
            <span class="n">collinearities</span><span class="p">[(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">c</span>
        <span class="c1"># The two helices that are most likely to stack.</span>
        <span class="n">stacking_stems</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">collinearities</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">k</span><span class="p">:</span><span class="n">collinearities</span><span class="p">[</span><span class="n">k</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">collinearities</span><span class="p">[</span><span class="n">stacking_stems</span><span class="p">]</span><span class="o">&lt;</span><span class="mf">0.8</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="c1"># The second best pair</span>
        <span class="n">second_best_pair</span><span class="p">,</span> <span class="n">second_best_score</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">collinearities</span><span class="o">.</span><span class="n">items</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">collinearities</span><span class="p">[</span><span class="n">stacking_stems</span><span class="p">]</span><span class="o">-</span><span class="n">second_best_score</span><span class="o">&lt;</span><span class="mf">0.5</span><span class="p">:</span>
            <span class="c1">#Two are possible. We look now which one has fewer offset to the 3rd stem.</span>
            <span class="c1"># The reference stem could stack with both.</span>
            <span class="n">reference</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stacking_stems</span><span class="p">)</span> <span class="o">&amp;</span> <span class="nb">set</span><span class="p">(</span><span class="n">second_best_pair</span><span class="p">)</span>
            <span class="n">other</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">stems</span><span class="p">)</span> <span class="o">-</span> <span class="n">reference</span>
            <span class="n">reference</span><span class="p">,</span> <span class="o">=</span> <span class="n">reference</span>
            <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span> <span class="o">=</span> <span class="n">other</span>
            <span class="n">o1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_offset</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">stem1</span><span class="p">)</span>
            <span class="n">o2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_offset</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">stem2</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">o1</span><span class="o">-</span><span class="n">o2</span><span class="p">)</span><span class="o">&lt;</span><span class="mf">0.2</span><span class="p">:</span>  <span class="c1"># Angstrom</span>
                <span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s2">&quot;Cannot assign loop roles. Stacking is ambiguous.&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="kc">None</span>
            <span class="k">elif</span> <span class="n">o1</span><span class="o">&lt;</span><span class="n">o2</span><span class="p">:</span>
                <span class="n">stacking_stems</span><span class="o">=</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">stem1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stacking_stems</span><span class="o">=</span><span class="p">(</span><span class="n">reference</span><span class="p">,</span> <span class="n">stem2</span><span class="p">)</span>
        <span class="c1"># We have clearly identified the stacking helices.</span>
        <span class="c1"># j12 is the ML-segment that connects the stacking helices.</span>
        <span class="n">j12</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">stacking_stems</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">stacking_stems</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
        <span class="c1"># stem P1 is at the 5&#39; side of the connecting multiloop...</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">j12</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
        <span class="c1"># ...and P2 at the 3&#39; side</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_a</span><span class="p">(</span><span class="n">j12</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">assert</span> <span class="nb">set</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">])</span><span class="o">==</span><span class="nb">set</span><span class="p">(</span><span class="n">stacking_stems</span><span class="p">)</span>
        <span class="k">assert</span> <span class="n">p1</span><span class="o">!=</span><span class="n">p2</span>
        <span class="c1"># p3 is the third stem,</span>
        <span class="n">p3</span><span class="p">,</span> <span class="o">=</span> <span class="n">stems</span> <span class="o">-</span> <span class="nb">set</span><span class="p">([</span><span class="n">p1</span><span class="p">,</span><span class="n">p2</span><span class="p">])</span>
        <span class="c1"># j31 and j23 are the remaining ml segments</span>
        <span class="n">j31</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">p1</span><span class="p">]</span>
        <span class="n">j23</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">p2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">p3</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;P1&quot;</span><span class="p">:</span><span class="n">p1</span><span class="p">,</span> <span class="s2">&quot;P2&quot;</span><span class="p">:</span><span class="n">p2</span><span class="p">,</span><span class="s2">&quot;P3&quot;</span><span class="p">:</span><span class="n">p3</span><span class="p">,</span><span class="s2">&quot;J12&quot;</span><span class="p">:</span><span class="n">j12</span><span class="p">,</span> <span class="s2">&quot;J31&quot;</span><span class="p">:</span><span class="n">j31</span><span class="p">,</span><span class="s2">&quot;J23&quot;</span><span class="p">:</span><span class="n">j23</span><span class="p">}</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.junction_family_westhof1"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.junction_family_westhof1">[docs]</a>    <span class="k">def</span> <span class="nf">junction_family_westhof1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL</span>

<span class="sd">        For 3-way junctions: Return the junction family according to</span>
<span class="sd">        Lescoute and Westhof, RNA 2006 (doi: 10.1261/rna.2208106).</span>

<span class="sd">        In this method, the junction family is defined via the relative</span>
<span class="sd">        lengths of fragments, not the orientation of the elements.</span>

<span class="sd">        :param loop: Either a dictionary, as returned by assign_loop_roles</span>
<span class="sd">                     or a list of 3 loop segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">j_roles</span><span class="o">=</span><span class="n">loop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j_roles</span> <span class="o">=</span> <span class="n">assign_loop_roles</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
        <span class="c1"># Now compare the lengths of J31 and J23 to determine the junction family</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">(</span><span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;J31&quot;</span><span class="p">])</span><span class="o">&gt;</span><span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">(</span><span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;J23&quot;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="s2">&quot;A&quot;</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">(</span><span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;J31&quot;</span><span class="p">])</span><span class="o">==</span><span class="bp">self</span><span class="o">.</span><span class="n">get_length</span><span class="p">(</span><span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;J23&quot;</span><span class="p">]):</span>
            <span class="k">return</span> <span class="s2">&quot;B&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;C&quot;</span></div>
<div class="viewcode-block" id="CoarseGrainRNA.junction_family_3d"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.junction_family_3d">[docs]</a>    <span class="k">def</span> <span class="nf">junction_family_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL</span>

<span class="sd">        For 3-way junctions: Return the junction family depending</span>
<span class="sd">        on the 3D orientation.</span>

<span class="sd">        :param loop: Either a dictionary, as returned by assign_loop_roles</span>
<span class="sd">                     or a list of 3 loop segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">j_roles</span><span class="o">=</span><span class="n">loop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j_roles</span> <span class="o">=</span> <span class="n">assign_loop_roles</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
        <span class="n">a31</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_angle</span><span class="p">(</span><span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;P3&quot;</span><span class="p">],</span> <span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;P1&quot;</span><span class="p">])</span>
        <span class="n">a23</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_angle</span><span class="p">(</span><span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;P2&quot;</span><span class="p">],</span> <span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;P3&quot;</span><span class="p">])</span>
        <span class="c1"># If the stack is perfectly straight, a31+a23=180 degrees.</span>
        <span class="k">if</span> <span class="n">a31</span><span class="o">&gt;</span><span class="n">a23</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">1</span></div>
<div class="viewcode-block" id="CoarseGrainRNA.junction_family_is_perpenticular"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.junction_family_is_perpenticular">[docs]</a>    <span class="k">def</span> <span class="nf">junction_family_is_perpenticular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">loop</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        EXPERIMENTAL</span>

<span class="sd">        For 3-way junctions Return whether or not the not-stacking loop</span>
<span class="sd">        is very roughly perpenticular to the stack.</span>

<span class="sd">        :param loop: Either a dictionary, as returned by assign_loop_roles</span>
<span class="sd">                     or a list of 3 loop segments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">loop</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">j_roles</span><span class="o">=</span><span class="n">loop</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">j_roles</span> <span class="o">=</span> <span class="n">assign_loop_roles</span><span class="p">(</span><span class="n">loop</span><span class="p">)</span>
        <span class="n">a31</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_angle</span><span class="p">(</span><span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;P3&quot;</span><span class="p">],</span> <span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;P1&quot;</span><span class="p">])</span>
        <span class="n">a23</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">stem_angle</span><span class="p">(</span><span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;P2&quot;</span><span class="p">],</span> <span class="n">j_roles</span><span class="p">[</span><span class="s2">&quot;P3&quot;</span><span class="p">])</span>
        <span class="c1"># If the stack is perfectly straight, a31+a23=180 degrees.</span>
        <span class="k">if</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span><span class="o">&lt;</span><span class="n">a31</span><span class="o">&lt;</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">120</span><span class="p">)</span> <span class="ow">or</span> <span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span><span class="o">&lt;</span><span class="n">a23</span><span class="o">&lt;</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="mi">120</span><span class="p">):</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="mi">0</span></div>


<div class="viewcode-block" id="CoarseGrainRNA.stem_offset"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.stem_offset">[docs]</a>    <span class="k">def</span> <span class="nf">stem_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ref_stem</span><span class="p">,</span> <span class="n">stem2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        How much is the offset between the start of stem 2</span>
<span class="sd">        and the axis of stem1.</span>

<span class="sd">        Assumes that stem1 and stem 2 are connected by a single bulge.</span>
<span class="sd">        Then the start of stem2 is defined to be the stem side</span>
<span class="sd">        closer to the bulge.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">common_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">ref_stem</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">stem2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">!=</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Stem1 and stem2 must be connected by a single bulge &quot;</span>
                             <span class="s2">&quot;to calculate stem_offset.&quot;</span><span class="p">)</span>
        <span class="n">bulge</span><span class="p">,</span> <span class="o">=</span> <span class="n">common_edges</span>
        <span class="n">side</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">point_line_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">][</span><span class="n">side</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">ref_stem</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">get_direction</span><span class="p">(</span><span class="n">ref_stem</span><span class="p">))</span></div>


<div class="viewcode-block" id="CoarseGrainRNA.stem_angle"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.stem_angle">[docs]</a>    <span class="k">def</span> <span class="nf">stem_angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the angle between two stems.</span>

<span class="sd">        If they are connected via a single element,</span>
<span class="sd">        use the direction pointing away from this element for both stems.</span>
<span class="sd">        Otherwise, use the direction from start to end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">vec1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">get_direction</span><span class="p">(</span><span class="n">stem1</span><span class="p">)</span>
        <span class="n">vec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">get_direction</span><span class="p">(</span><span class="n">stem2</span><span class="p">)</span>

        <span class="n">common_edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">stem1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">stem2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">common_edges</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">bulge</span><span class="p">,</span> <span class="o">=</span> <span class="n">common_edges</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">vec1</span> <span class="o">=</span> <span class="o">-</span><span class="n">vec1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">):</span>
                <span class="n">vec2</span> <span class="o">=</span> <span class="o">-</span><span class="n">vec2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">stem2</span><span class="p">,</span> <span class="n">bulge</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_angle</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span></div>


<div class="viewcode-block" id="CoarseGrainRNA.get_coordinates_list"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_coordinates_list">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinates_list</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;CoarseGrainRNA.get_coordinates_list is deprecated and being &quot;</span>
                      <span class="s2">&quot;replaced by get_coordinates_array!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates_array</span><span class="p">()</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_coordinates_array"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_coordinates_array">[docs]</a>    <span class="k">def</span> <span class="nf">get_coordinates_array</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get all of the coordinates in one large array.</span>

<span class="sd">        The coordinates are sorted in the order of the keys</span>
<span class="sd">        in coordinates dictionary.</span>

<span class="sd">        :return: A 2D numpy array containing all coordinates</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">all_coords</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span><span class="o">^</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">key</span><span class="p">])):</span>
                <span class="n">all_coords</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">key</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">all_coords</span><span class="p">)</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.load_coordinates_array"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.load_coordinates_array">[docs]</a>    <span class="k">def</span> <span class="nf">load_coordinates_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coords</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Read in an array of coordinates (as may be produced by get_coordinates_array)</span>
<span class="sd">        and replace the coordinates of this structure with it.</span>

<span class="sd">        :param coords: A 2D array of coordinates</span>
<span class="sd">        :return: self</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">keys</span><span class="p">())):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span> <span class="p">],</span> <span class="n">coords</span><span class="p">[</span> <span class="mi">2</span><span class="o">*</span><span class="n">j</span><span class="o">+</span><span class="mi">1</span> <span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.get_twists"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.get_twists">[docs]</a>    <span class="k">def</span> <span class="nf">get_twists</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Get the array of twists for this node. If the node is a stem,</span>
<span class="sd">        then the twists will simply those stored in the array.</span>
<span class="sd">        If the node is an interior loop or a junction segment,</span>
<span class="sd">        then the twists will be the ones that are adjacent to it.</span>
<span class="sd">        If the node is a hairpin loop or a free end, then the same twist</span>
<span class="sd">        will be duplicated and returned twice.</span>

<span class="sd">        :param node: The name of the node</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="k">if</span> <span class="n">node</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="p">[</span><span class="n">node</span><span class="p">]</span>

        <span class="n">connections</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">node</span><span class="p">])</span>
        <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">s1e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vec</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">vector_rejection</span><span class="p">(</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">s1b</span><span class="p">],</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>

            <span class="k">return</span> <span class="p">(</span><span class="n">vec</span><span class="p">,</span><span class="n">vec</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">connections</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># interior loop or junction segment</span>
            <span class="p">(</span><span class="n">s2b</span><span class="p">,</span> <span class="n">s2e</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">node</span><span class="p">)</span>
            <span class="n">bulge_vec</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">s1b</span><span class="p">]</span> <span class="o">-</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">s2b</span><span class="p">])</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">vector_rejection</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="n">s1b</span><span class="p">],</span> <span class="n">bulge_vec</span><span class="p">)),</span>
                    <span class="n">ftuv</span><span class="o">.</span><span class="n">normalize</span><span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">vector_rejection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="p">[</span><span class="n">connections</span><span class="p">[</span><span class="mi">1</span><span class="p">]][</span><span class="n">s2b</span><span class="p">],</span> <span class="n">bulge_vec</span><span class="p">)))</span>

        <span class="c1"># uh oh, this shouldn&#39;t happen since every node</span>
        <span class="c1"># should have either one or two edges</span>
        <span class="k">assert</span> <span class="kc">False</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.element_physical_distance"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.element_physical_distance">[docs]</a>    <span class="k">def</span> <span class="nf">element_physical_distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element1</span><span class="p">,</span> <span class="n">element2</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the physical distance between two coarse grain elements.</span>

<span class="sd">        :param element1: The name of the first element (e.g. &#39;s1&#39;)</span>
<span class="sd">        :param element2: The name of the first element (e.g. &#39;s2&#39;)</span>
<span class="sd">        :return: The closest distance between the two elements.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span> <span class="o">=</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">line_segment_distance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">element1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">element1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">element2</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                                              <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">element2</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">vec_distance</span><span class="p">(</span><span class="n">i1</span><span class="p">,</span> <span class="n">i2</span><span class="p">)</span></div>


<div class="viewcode-block" id="CoarseGrainRNA.longrange_iterator"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.longrange_iterator">[docs]</a>    <span class="k">def</span> <span class="nf">longrange_iterator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filter_connected</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Iterate over all long range interactions in this molecule.</span>

<span class="sd">        :param filter_connected: Filter interactions that are between elements</span>
<span class="sd">                                 which are connected (mostly meaning multiloops</span>
<span class="sd">                                 which connect to the same end of the same stem)</span>
<span class="sd">        :return: A generator yielding long-range interaction tuples (i.e. (&#39;s7&#39;, &#39;i2&#39;))</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>

        <span class="k">for</span> <span class="n">partner1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">partner2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">longrange</span><span class="p">[</span><span class="n">partner1</span><span class="p">]:</span>
                <span class="k">if</span> <span class="n">filter_connected</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">connected</span><span class="p">(</span><span class="n">partner1</span><span class="p">,</span> <span class="n">partner2</span><span class="p">):</span>
                        <span class="k">continue</span>

                <span class="n">interaction</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="nb">sorted</span><span class="p">([</span><span class="n">partner1</span><span class="p">,</span> <span class="n">partner2</span><span class="p">]))</span>

                <span class="c1"># check if we&#39;ve already seen this interaction</span>
                <span class="k">if</span> <span class="n">interaction</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">interaction</span><span class="p">)</span>

                <span class="k">yield</span> <span class="n">interaction</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.total_length"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.total_length">[docs]</a>    <span class="k">def</span> <span class="nf">total_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Calculate the combined length of all the elements.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">total_length</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">d</span><span class="p">)))</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">])</span>
        <span class="k">assert</span> <span class="n">total_length</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">seq_length</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.sorted_edges_for_mst"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.sorted_edges_for_mst">[docs]</a>    <span class="k">def</span> <span class="nf">sorted_edges_for_mst</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Keep track of all linked nodes. Used for the generation of the minimal spanning tree.</span>

<span class="sd">        This overrides the function in bulge graph and adds an additional sorting criterion</span>
<span class="sd">        with lowest priority.</span>
<span class="sd">        Elements that have no entry in self.sampled should be preferedly broken.</span>
<span class="sd">        This should ensure that the minimal spanning tree is the same after saving</span>
<span class="sd">        and loading an RNA to/from a file, if changes of the minimal spanning tree</span>
<span class="sd">        were performed by ernwin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">priority</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;s&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;i&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;m&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;f&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">it</span><span class="o">.</span><span class="n">chain</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">(),</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">iloop_iterator</span><span class="p">()),</span>
                       <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="p">(</span><span class="n">priority</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="nb">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_node_dimensions</span><span class="p">(</span><span class="n">x</span><span class="p">)),</span><span class="ow">not</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sampled</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">edges</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.coords_to_directions"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.coords_to_directions">[docs]</a>    <span class="k">def</span> <span class="nf">coords_to_directions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The directions of each coarse grain element. One line per cg-element.</span>

<span class="sd">        The array is sorted by the corresponding element names alphabetically (`sorted(defines.keys()`)</span>
<span class="sd">        The directions usually point away from the elemnt&#39;s lowest nucleotide.</span>
<span class="sd">        However h,t and f elements always point away from the connected stem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coordinates_array</span><span class="p">()</span>
        <span class="n">directions</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[</span><span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">directions</span></div>
<div class="viewcode-block" id="CoarseGrainRNA.coords_from_directions"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.coords_from_directions">[docs]</a>    <span class="k">def</span> <span class="nf">coords_from_directions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directions</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate coordinates from direction vectors (using also their lengths)</span>

<span class="sd">        Currently ignores the twists!</span>

<span class="sd">        :param directions: An array of vectors from the side of a cg-element with lower nucleotide number to the side with higher number</span>
<span class="sd">                           The array is sorted by the corresponding element names alphabetically (`sorted(defines.keys()`)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sorted_defines</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">sorted_defines</span><span class="p">)</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">),</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> != </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sorted_defines</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">directions</span><span class="p">))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="s2">&quot;s0&quot;</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="n">directions</span><span class="p">[</span><span class="n">sorted_defines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;s0&quot;</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">stem1</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">stem2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_order</span><span class="p">:</span> <span class="c1">#Bulges and stems</span>
            <span class="n">conn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">connection_ends</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">connection_type</span><span class="p">(</span><span class="n">link</span><span class="p">,</span> <span class="p">[</span><span class="n">stem1</span><span class="p">,</span><span class="n">stem2</span><span class="p">]))</span>
            <span class="n">link_dir</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_link_direction</span><span class="p">(</span><span class="n">stem1</span><span class="p">,</span> <span class="n">stem2</span><span class="p">,</span> <span class="n">link</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">link_dir</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">+</span><span class="n">directions</span><span class="p">[</span><span class="n">sorted_defines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">link</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">conn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">directions</span><span class="p">[</span><span class="n">sorted_defines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">stem2</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">directions</span><span class="p">[</span><span class="n">sorted_defines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">stem2</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">-</span> <span class="n">directions</span><span class="p">[</span><span class="n">sorted_defines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">link</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem1</span><span class="p">][</span><span class="n">conn</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">if</span> <span class="n">conn</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">directions</span><span class="p">[</span><span class="n">sorted_defines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">stem2</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem2</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">directions</span><span class="p">[</span><span class="n">sorted_defines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">stem2</span><span class="p">)],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">link</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;m&quot;</span> <span class="ow">and</span> <span class="n">d</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">mst</span><span class="p">:</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">])</span>
                <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
                <span class="p">(</span><span class="n">s2b</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">d</span><span class="p">)</span>
                <span class="n">mids1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                <span class="n">mids2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="c1">#Save coordinates in direction of the strand.</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_link_direction</span><span class="p">(</span><span class="n">edges</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">edges</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">d</span><span class="p">)</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mids1</span><span class="p">[</span><span class="n">s1b</span><span class="p">],</span> <span class="n">mids2</span><span class="p">[</span><span class="n">s2b</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">mids2</span><span class="p">[</span><span class="n">s2b</span><span class="p">],</span> <span class="n">mids1</span><span class="p">[</span><span class="n">s1b</span><span class="p">])</span>

            <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="s2">&quot;hft&quot;</span><span class="p">:</span> <span class="c1">#Loops</span>
                <span class="n">stem</span><span class="p">,</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">[</span><span class="n">d</span><span class="p">]</span>
                <span class="p">(</span><span class="n">s1b</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="n">stem</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">d</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="n">s1b</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">stem</span><span class="p">][</span><span class="n">s1b</span><span class="p">]</span> <span class="o">+</span> <span class="n">directions</span><span class="p">[</span><span class="n">sorted_defines</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">d</span><span class="p">)]</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.virtual_atoms"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.virtual_atoms">[docs]</a>    <span class="k">def</span> <span class="nf">virtual_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get virtual atoms for a key.</span>

<span class="sd">        :param key: An INTEGER: The number of the base in the RNA.</span>

<span class="sd">        :returns: A dict {atom:coords}, e.g. {&quot;C8&quot;:np.array([x,y,z]), ...}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
             <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">ftug</span><span class="o">.</span><span class="n">virtual_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Key </span><span class="si">{}</span><span class="s2"> not present. Need to recreate all virtual residues&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">e</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">add_all_virtual_residues</span><span class="p">()</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">=</span><span class="n">ftug</span><span class="o">.</span><span class="n">virtual_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)[</span><span class="n">key</span><span class="p">]</span>
             <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Expected an int, found </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span></div>

<div class="viewcode-block" id="CoarseGrainRNA.reset_vatom_cache"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.reset_vatom_cache">[docs]</a>    <span class="k">def</span> <span class="nf">reset_vatom_cache</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delete all cached information about virtual residues and virtual atoms.</span>
<span class="sd">        Used as on_call function for the observing of the self.coords dictionary.</span>

<span class="sd">        :param key: A coarse grain element name, e.g. &quot;s1&quot; or &quot;m15&quot;</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="p">:</span>
                <span class="k">return</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span> <span class="c1">#Happens during deepcopy</span>
            <span class="k">return</span>

        <span class="n">define</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">defines</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

        <span class="c1">#Delete virtual residues</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">vposs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">vbases</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">vvecs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span> <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">vinvs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span> <span class="k">pass</span>

        <span class="c1">#Delete virtual atoms</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">define</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">define</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">define</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">define</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">define</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_virtual_atom_cache</span><span class="p">[</span><span class="n">i</span><span class="p">]</span></div>
    <span class="c1">#def __deepcopy__(self, memo):</span>

<div class="viewcode-block" id="CoarseGrainRNA.rotate"><a class="viewcode-back" href="../../../../apidoc/forgi.threedee.model.coarse_grain.html#forgi.threedee.model.coarse_grain.CoarseGrainRNA.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;radians&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">unit</span><span class="o">==</span><span class="s2">&quot;degrees&quot;</span><span class="p">:</span>
            <span class="n">angle</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">radians</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">unit</span><span class="o">!=</span><span class="s2">&quot;radians&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Unit </span><span class="si">{}</span><span class="s2"> not understood. Use &#39;degrees&#39; or &#39;radians&#39;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">unit</span><span class="p">))</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">cosi</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">angle</span><span class="p">)</span>
        <span class="n">rotation_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">axis</span><span class="o">==</span><span class="s2">&quot;x&quot;</span><span class="p">:</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">cosi</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=-</span><span class="n">s</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">s</span>
        <span class="k">elif</span> <span class="n">axis</span><span class="o">==</span><span class="s2">&quot;y&quot;</span><span class="p">:</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">cosi</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=-</span><span class="n">s</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">s</span>
        <span class="k">elif</span> <span class="n">axis</span><span class="o">==</span><span class="s2">&quot;z&quot;</span><span class="p">:</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mi">1</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">cosi</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="n">s</span>
            <span class="n">rotation_matrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">twists</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">rotation_matrix</span><span class="p">)</span>

        <span class="c1">#Caching for virtual residues</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vposs</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vbases</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vvecs</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">v3dposs</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">vinvs</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">defaultdict</span><span class="p">(</span> <span class="nb">dict</span> <span class="p">)</span></div></div>
</pre></div>

      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016 Peter Kerpedjiev &lt;pkerp@tbi.univie.ac.at&gt;; 2015,2016 Bernhard Thiel &lt;thiel@tbi.univie.ac.at&gt;.
      Last updated on Oct 17, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.4.
    </div>
  </body>
</html>