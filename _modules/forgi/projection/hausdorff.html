

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>forgi.projection.hausdorff &#8212; forgi 1.1.0 documentation</title>
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1.1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="../../../_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../../index.html">
          <span>forgi 1.1.0 documentation</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <h1>Source code for forgi.projection.hausdorff</h1><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">__future__</span> <span class="k">import</span> <span class="n">print_function</span><span class="p">,</span> <span class="n">absolute_import</span><span class="p">,</span> <span class="n">division</span>
<span class="kn">from</span> <span class="nn">builtins</span> <span class="k">import</span> <span class="nb">range</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">math</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">..threedee.utilities</span> <span class="k">import</span> <span class="n">vector</span> <span class="k">as</span> <span class="n">ftuv</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="k">import</span> <span class="n">projection2d</span> <span class="k">as</span> <span class="n">fhp</span>
<span class="kn">import</span> <span class="nn">random</span>
<span class="kn">import</span> <span class="nn">itertools</span> <span class="k">as</span> <span class="nn">it</span>

<span class="n">__all__</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;offsets&quot;</span><span class="p">,</span> <span class="s2">&quot;modified_hausdorff_distance&quot;</span><span class="p">,</span> <span class="s2">&quot;hausdorff_distance&quot;</span><span class="p">,</span> 
         <span class="s2">&quot;locally_minimal_distance&quot;</span><span class="p">,</span> <span class="s2">&quot;globally_minimal_distance&quot;</span><span class="p">,</span> <span class="s2">&quot;get_box&quot;</span><span class="p">,</span> 
         <span class="s2">&quot;get_longest_img_diameter&quot;</span><span class="p">,</span> <span class="s2">&quot;try_parameters&quot;</span><span class="p">]</span>
<span class="n">__author__</span> <span class="o">=</span> <span class="s2">&quot;Bernhard Thiel&quot;</span>
<span class="n">__copyright__</span> <span class="o">=</span> <span class="s2">&quot;Copyright 2016&quot;</span>
<span class="n">__maintainer__</span> <span class="o">=</span> <span class="s2">&quot;Bernhard Thiel&quot;</span>
<span class="n">__email__</span> <span class="o">=</span> <span class="s2">&quot;thiel@tbi.univie.ac.at&quot;</span>


<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">A module for grid-based hausdorff distances.</span>
<span class="sd">This module calculates the distance between two boolean matrices and</span>
<span class="sd">the distance between a forgi.projection.projection2d.Projection2D object </span>
<span class="sd">and a boolean matrix</span>
<span class="sd">These distances are based on the location of True-values in the two matrices.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">profile</span>  <span class="c1">#The @profile decorator from line_profiler (kernprof)</span>
<span class="k">except</span> <span class="ne">NameError</span><span class="p">:</span>
    <span class="k">def</span> <span class="nf">profile</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> 
        <span class="k">return</span> <span class="n">x</span>

<span class="c1">##############################################################################</span>
<span class="c1"># Helper functions for iterating the grid in &quot;spirals&quot;</span>
<span class="c1">##############################################################################</span>

<span class="k">def</span> <span class="nf">norm</span><span class="p">(</span><span class="n">offset</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Euclidean norm.</span>
<span class="sd">    :param offset: A tuple of length 2.</span>
<span class="sd">    :returns: A float</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

<div class="viewcode-block" id="offsets"><a class="viewcode-back" href="../../../apidoc/forgi.projection.hausdorff.html#forgi.projection.hausdorff.offsets">[docs]</a><span class="k">def</span> <span class="nf">offsets</span><span class="p">(</span><span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">to_iterate</span><span class="o">=</span><span class="p">[],</span> <span class="n">toskip</span><span class="o">=</span><span class="p">{}):</span> <span class="c1">#pylint: disable=W0102</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An iterator over offsets and their length ((dx,dy), norm((dx,dy))) in the order </span>
<span class="sd">    of increasing norm((dx,dy))</span>
<span class="sd">    dx and dy are integers, starting at (0,0).</span>

<span class="sd">    :param skip: A float. The iterator may skip cell up to SKIP away from (0,0) </span>
<span class="sd">                 before returning the first value.</span>
<span class="sd">    :param to_iterate: Do not use this. The mutable default parameter is used as a hack for caching.</span>
<span class="sd">    :param toskip: Do not use this. The mutable default parameter is used as a hack for caching.</span>

<span class="sd">    :yields: A tuple ((dx,dy), n) where dx and dy are integers and n=norm((dx,dy)).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># We take advatage of mutable default parameter: to_iterate=[] in the function declaration.</span>
    <span class="c1"># If we iterate several times over offsets(), we only build to_iterate once!</span>
    <span class="k">if</span> <span class="n">skip</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">i</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">i</span><span class="o">=</span><span class="n">toskip</span><span class="p">[</span><span class="n">skip</span><span class="p">]</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="c1"># Iterate over to_iterate.</span>
        <span class="c1"># If we reached the end, increase to_iterate and </span>
        <span class="c1"># continue iteration with first added element.</span>
        <span class="n">len_to_iterate</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">to_iterate</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len_to_iterate</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">to_iterate</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>            
            <span class="n">i</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">increase_range</span><span class="p">(</span><span class="n">to_iterate</span><span class="p">,</span> <span class="n">toskip</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">increase_range</span><span class="p">(</span><span class="n">to_iterate</span><span class="p">,</span> <span class="n">to_skip</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Increase the range of offsets, which are ordered by their norm. Used by offsets().</span>

<span class="sd">    :param to_iterate: The list of offsets to be increased. </span>
<span class="sd">                       A list of coordinates and lengths ((dx,dy), norm((dx,dy))),</span>
<span class="sd">                       ordered by increasing norm((dx,dy))</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dists</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">if</span> <span class="n">to_iterate</span><span class="p">:</span>
        <span class="n">length</span><span class="o">=</span><span class="n">to_iterate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">newlength</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">length</span><span class="o">+</span><span class="mi">25</span><span class="p">)</span> <span class="c1">#25 could be anything.</span>
        <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">newlength</span><span class="p">,</span> <span class="n">newlength</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">newlength</span><span class="p">,</span> <span class="n">newlength</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dd</span><span class="o">=</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dd</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">dists</span><span class="p">:</span>
                    <span class="n">dists</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span><span class="o">=</span><span class="n">norm</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span>
        <span class="n">oldlen</span><span class="o">=</span><span class="n">to_iterate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">to_iterate</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1">#print (&quot;sorting {} elements for newlength {}&quot;.format(len(dists.keys()), newlength))</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dists</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dists</span><span class="p">[</span><span class="n">x</span><span class="p">]):</span>
            <span class="k">if</span> <span class="n">length</span><span class="o">&lt;</span><span class="n">dists</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">&lt;</span><span class="n">newlength</span><span class="p">:</span>
                <span class="n">to_iterate</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">dists</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>
                <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">&gt;</span><span class="n">oldlen</span><span class="p">:</span>
                    <span class="n">to_skip</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">to_iterate</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">length</span><span class="o">=</span><span class="mi">25</span> <span class="c1">#25 could be anything.</span>
        <span class="k">for</span> <span class="n">dx</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">dy</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dd</span><span class="o">=</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span><span class="n">dy</span><span class="p">)</span>
                <span class="n">dists</span><span class="p">[</span><span class="n">dd</span><span class="p">]</span><span class="o">=</span><span class="n">norm</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span>
        <span class="n">oldlen</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">dists</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">dists</span><span class="p">[</span><span class="n">x</span><span class="p">]):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">dists</span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="o">&lt;</span><span class="n">length</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">to_iterate</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span> <span class="n">dists</span><span class="p">[</span><span class="n">x</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">&gt;</span><span class="n">oldlen</span><span class="p">:</span>
                <span class="n">to_skip</span><span class="p">[</span><span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">to_iterate</span><span class="p">)</span><span class="o">-</span><span class="mi">2</span>

<span class="c1">##############################################################################</span>
<span class="c1"># Grid based distances</span>
<span class="c1">##############################################################################</span>
<span class="nd">@profile</span>
<span class="k">def</span> <span class="nf">hausdorff_helperdist</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="n">skip</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns the shorthest distance from a given point p to any non-zero cell in img.</span>
<span class="sd">    This is used by hausdorff_distance()</span>

<span class="sd">    :param p: a point in matrix coordinates</span>
<span class="sd">    :param img: A binary matrix</span>
<span class="sd">    :param cutoff: If the distance is larger cutoff, return float(&quot;inf&quot;). </span>
<span class="sd">                   Increases execution speed</span>
<span class="sd">    :param skip: The function does not have to search for a distance smaller than skip </span>
<span class="sd">                 (used for speedup)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dpi</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="n">p0</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">p1</span><span class="o">=</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">dd</span><span class="p">,</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">(</span><span class="n">skip</span><span class="p">):</span>
        <span class="n">x</span><span class="o">=</span><span class="n">p0</span><span class="o">+</span><span class="n">dd</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">y</span><span class="o">=</span><span class="n">p1</span><span class="o">+</span><span class="n">dd</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">x</span><span class="o">&lt;</span><span class="n">dpi</span> <span class="ow">and</span> <span class="mi">0</span><span class="o">&lt;=</span><span class="n">y</span><span class="o">&lt;</span><span class="n">dpi</span> <span class="ow">and</span> <span class="n">img</span><span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">]:</span>
            <span class="k">return</span> <span class="n">n</span>
        <span class="k">if</span> <span class="n">n</span><span class="o">&gt;</span><span class="n">cutoff</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="hausdorff_distance"><a class="viewcode-back" href="../../../apidoc/forgi.projection.hausdorff.html#forgi.projection.hausdorff.hausdorff_distance">[docs]</a><span class="k">def</span> <span class="nf">hausdorff_distance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ref_img</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the grid-based Hausdorff distance between two aligned boolean matrices.</span>

<span class="sd">    :param img, ref_img: Two aligned boolean 2D matrices with the same shape.</span>
<span class="sd">    :param cutoff: A float. If the distance is greater than cutoff, return float(&quot;inf&quot;).</span>
<span class="sd">                   (Used to increase execution speed in certain cases)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">hausdorff_distance_new</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ref_img</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span></div>
    <span class="c1">##Source: https://de.wikipedia.org/wiki/Hausdorff-Metrik</span>
    <span class="c1"># h1=max(hausdorff_helperdist([x,y], img, cutoff) for x,y in np.transpose(np.where(ref_img) ))</span>
    <span class="c1"># if h1==float(&quot;inf&quot;):</span>
    <span class="c1">#     return float(&quot;inf&quot;)</span>
    <span class="c1"># h2=max(hausdorff_helperdist([x,y], ref_img, cutoff) for x,y in np.transpose(np.where(img) ))</span>
    <span class="c1"># return max( h1, h2)</span>
<span class="nd">@profile</span>
<span class="k">def</span> <span class="nf">hausdorff_distance_new</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ref_img</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A faster implementation using skip, called by hausdorff_distance().</span>
<span class="sd">    This implementation is faster for high Hausdorff distances.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">y</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">oldx</span><span class="o">=</span><span class="kc">None</span>
    <span class="n">oldy</span><span class="o">=</span><span class="kc">None</span>
    <span class="n">skip</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">maxh</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">oldh</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ref_img</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">oldh</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">oldh</span><span class="o">=</span><span class="n">hausdorff_helperdist</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="n">img</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
                <span class="n">oldx</span><span class="o">=</span><span class="n">x</span>
                <span class="n">oldy</span><span class="o">=</span><span class="n">y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#skip always has to be strictly smaller than oldh-norm(dx,dy)!</span>
                <span class="n">skip</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">oldh</span><span class="o">-</span><span class="n">norm</span><span class="p">([</span><span class="n">x</span><span class="o">-</span><span class="n">oldx</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="n">oldy</span><span class="p">])</span><span class="o">-</span><span class="mf">0.1</span><span class="p">))</span> 
                <span class="n">oldh</span><span class="o">=</span><span class="n">hausdorff_helperdist</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="n">img</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">skip</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">oldx</span><span class="o">=</span><span class="n">x</span>
                <span class="n">oldy</span><span class="o">=</span><span class="n">y</span>
            <span class="k">if</span> <span class="n">oldh</span><span class="o">&gt;</span><span class="n">maxh</span><span class="p">:</span>
                <span class="n">maxh</span><span class="o">=</span><span class="n">oldh</span>
            <span class="k">if</span> <span class="n">oldh</span><span class="o">==</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">h1</span><span class="o">=</span><span class="n">maxh</span>
        <span class="n">maxh</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">oldh</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">oldh</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">oldh</span><span class="o">=</span><span class="n">hausdorff_helperdist</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="n">ref_img</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
                <span class="n">oldx</span><span class="o">=</span><span class="n">x</span>
                <span class="n">oldy</span><span class="o">=</span><span class="n">y</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">skip</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">oldh</span><span class="o">-</span><span class="n">norm</span><span class="p">([</span><span class="n">x</span><span class="o">-</span><span class="n">oldx</span><span class="p">,</span> <span class="n">y</span><span class="o">-</span><span class="n">oldy</span><span class="p">])</span><span class="o">-</span><span class="mf">0.1</span><span class="p">))</span>
                <span class="n">oldh</span><span class="o">=</span><span class="n">hausdorff_helperdist</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="n">ref_img</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">skip</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
                <span class="n">oldx</span><span class="o">=</span><span class="n">x</span>
                <span class="n">oldy</span><span class="o">=</span><span class="n">y</span>
            <span class="k">if</span> <span class="n">oldh</span><span class="o">&gt;</span><span class="n">maxh</span><span class="p">:</span>
                <span class="n">maxh</span><span class="o">=</span><span class="n">oldh</span>
            <span class="k">if</span> <span class="n">oldh</span><span class="o">==</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="n">h2</span><span class="o">=</span><span class="n">maxh</span>
        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">KeyboardInterrupt</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;x: </span><span class="si">{}</span><span class="s2">, y: </span><span class="si">{}</span><span class="s2">, oldx: </span><span class="si">{}</span><span class="s2">, oldy: </span><span class="si">{}</span><span class="s2">, oldh: </span><span class="si">{}</span><span class="s2">, maxh: </span><span class="si">{}</span><span class="s2">, &quot;</span> 
              <span class="s2">&quot;h1: </span><span class="si">{}</span><span class="s2">, skip=</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">oldx</span><span class="p">,</span><span class="n">oldy</span><span class="p">,</span><span class="n">oldh</span><span class="p">,</span><span class="n">maxh</span><span class="p">,</span><span class="n">h1</span><span class="p">,</span><span class="n">skip</span><span class="p">))</span>
        <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">interpolation</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s1">&#39;gray&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Reference&quot;</span><span class="p">)</span>
        <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s2">&quot;Image&quot;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="k">raise</span>

<div class="viewcode-block" id="modified_hausdorff_distance"><a class="viewcode-back" href="../../../apidoc/forgi.projection.hausdorff.html#forgi.projection.hausdorff.modified_hausdorff_distance">[docs]</a><span class="k">def</span> <span class="nf">modified_hausdorff_distance</span><span class="p">(</span> <span class="n">img</span><span class="p">,</span> <span class="n">ref_img</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return the grid-based Modified Hausdorff distance between two aligned boolean matrices.</span>
<span class="sd">    This distance was proposed in the following paper: TODO</span>
<span class="sd">    It uses the mean of all distances instead of the max.</span>
<span class="sd">    The current implementation is not optimized</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#Source: </span>
    <span class="n">h1</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">hausdorff_helperdist</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="n">img</span><span class="p">)</span> 
          <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ref_img</span><span class="p">)))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ref_img</span><span class="p">)</span>
    <span class="n">h2</span><span class="o">=</span><span class="nb">sum</span><span class="p">(</span><span class="n">hausdorff_helperdist</span><span class="p">([</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">],</span> <span class="n">ref_img</span><span class="p">)</span> 
           <span class="k">for</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span><span class="p">)))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">max</span><span class="p">(</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">tp_fp_distance</span><span class="p">(</span> <span class="n">img</span><span class="p">,</span> <span class="n">ref_img</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">tp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ref_img</span><span class="p">))</span>
    <span class="n">alle</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">ref_img</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">alle</span><span class="o">/</span><span class="n">tp</span>

<span class="k">def</span> <span class="nf">combined_distance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ref_img</span><span class="p">,</span> <span class="n">_</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">tp_fp_distance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ref_img</span><span class="p">)</span> <span class="o">+</span> <span class="n">hausdorff_distance</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">ref_img</span><span class="p">)</span>
<span class="c1">##############################################################################</span>
<span class="c1"># Helper functions for working with projections</span>
<span class="c1">##############################################################################</span>


<span class="k">def</span> <span class="nf">to_polar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ftuv</span><span class="o">.</span><span class="n">spherical_cartesian_to_polar</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>

<span class="k">def</span> <span class="nf">from_polar</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">ftuv</span><span class="o">.</span><span class="n">spherical_polar_to_cartesian</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

<div class="viewcode-block" id="get_box"><a class="viewcode-back" href="../../../apidoc/forgi.projection.hausdorff.html#forgi.projection.hausdorff.get_box">[docs]</a><span class="k">def</span> <span class="nf">get_box</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))):</span>
    <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">down</span><span class="p">,</span> <span class="n">up</span><span class="o">=</span><span class="n">projection</span><span class="o">.</span><span class="n">get_bounding_square</span><span class="p">()</span>
    <span class="n">center_hor</span><span class="o">=</span><span class="n">left</span><span class="o">+</span><span class="p">(</span><span class="n">right</span><span class="o">-</span><span class="n">left</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">center_ver</span><span class="o">=</span><span class="n">down</span><span class="o">+</span><span class="p">(</span><span class="n">up</span><span class="o">-</span><span class="n">down</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">box</span><span class="o">=</span><span class="p">(</span><span class="n">center_hor</span><span class="o">-</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center_hor</span><span class="o">+</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
        <span class="n">center_ver</span><span class="o">-</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">center_ver</span><span class="o">+</span><span class="n">width</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">box</span></div>

<div class="viewcode-block" id="locally_minimal_distance"><a class="viewcode-back" href="../../../apidoc/forgi.projection.hausdorff.html#forgi.projection.hausdorff.locally_minimal_distance">[docs]</a><span class="nd">@profile</span>
<span class="k">def</span> <span class="nf">locally_minimal_distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> 
                             <span class="n">start_rot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">proj_dir</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">maxiter</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">advanced</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">virtual_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                             <span class="n">distance</span><span class="o">=</span><span class="n">hausdorff_distance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Local optimization of the Hausdorff distance between a image and a CoarseGrainRNA</span>

<span class="sd">    For a given reference image and a given CoarseGrainRNA, the distance is a function of</span>
<span class="sd">    continuouse variables (projection direction, offset and rotation), but is a stepfunction, </span>
<span class="sd">    because it is grid-based. Therefor traditional optimization approaches, </span>
<span class="sd">    which rely on a gradient, fail.</span>
<span class="sd">    This implementation tests, whether the distance is increasing or decreasing in </span>
<span class="sd">    different directions, no matter how far one has to walk in that direction before </span>
<span class="sd">    the distance changes. It then follows the deepest decrease (not the steepest decrease!) </span>
<span class="sd"> </span>
<span class="sd">    :param ref_img: The reference image. A boolean square matrix.</span>
<span class="sd">    :param scale: The edge length in Angstrom of the reference image.</span>
<span class="sd">    :param cg: The coarse grain RNA to match to the projection.</span>
<span class="sd">    :param start_rot: The in-plane rotation of the projection.</span>
<span class="sd">    :param offset: The offset that will be applied to the projection in Angstrom. A np.array([x,y]).</span>
<span class="sd">    :param proj_dir: The starting projection direction in spherical polar coordinates.</span>
<span class="sd">                     If this is not given: uses cg.project_from.</span>
<span class="sd">    :param maxiter: Maximal number of iterations. An int.</span>
<span class="sd">    :param distance: a function with signature like hausdorff_distance </span>
<span class="sd">    :param advanced: Try steps in more directions (takes longer)</span>
<span class="sd">    :param virtual_atoms: Whether or not to project the virtual atoms. A boolean.</span>

<span class="sd">    :returns: A triple: (distance, image, parameters)</span>
<span class="sd">              Where distance is a float,image a matrix and params is a triple:</span>
<span class="sd">              np.array([theta, phi]), degrees, np.array([x_offset, y_offset])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">dpi</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_img</span><span class="p">)</span>
    <span class="n">cell_length</span><span class="o">=</span><span class="n">scale</span><span class="o">/</span><span class="n">dpi</span>
    <span class="c1">####### Heuristical parameters</span>
    <span class="c1">#: The minimal stepwidth in Angstrom for offsets is determined by the width a single pixel.</span>
    <span class="n">offset_stepwidth</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_length</span><span class="o">/</span><span class="mf">2.5</span><span class="p">))</span>
    <span class="c1">#: The change in projection direction also depends on the resolution, but the correlation is less straight forward.</span>
    <span class="n">scale_projectionsteps</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">cell_length</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span><span class="o">*</span><span class="mi">4</span><span class="p">)</span>
    <span class="c1">#print(&quot;Projection Step is {}, scale {}&quot;.format(0.002*scale_projectionsteps, scale_projectionsteps))</span>
    <span class="k">if</span> <span class="n">start_rot</span><span class="p">:</span>
        <span class="n">curr_best_rotation</span><span class="o">=</span><span class="n">start_rot</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_best_rotation</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_best_offs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_best_offs</span><span class="o">=</span><span class="n">offset</span>
    <span class="k">if</span> <span class="n">proj_dir</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">curr_best_pro</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">proj_dir</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">curr_best_pro</span><span class="o">=</span><span class="n">to_polar</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">project_from</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1">#Initial projection object and initial score</span>
    <span class="n">projection</span><span class="o">=</span><span class="n">fhp</span><span class="o">.</span><span class="n">Projection2D</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">from_polar</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_best_pro</span><span class="p">)),</span> 
                                <span class="n">project_virtual_atoms</span><span class="o">=</span><span class="n">virtual_atoms</span><span class="p">)</span>
    <span class="n">box</span><span class="o">=</span><span class="n">get_box</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">curr_best_offs</span><span class="p">)</span>
    <span class="n">img</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="n">projection</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span><span class="n">dpi</span><span class="p">,</span> <span class="n">bounding_square</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                         <span class="n">rotate</span><span class="o">=</span><span class="n">curr_best_rotation</span><span class="p">)</span>
    <span class="n">curr_best_score</span><span class="o">=</span><span class="n">distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>

    <span class="c1">#Stepwise improve score</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">maxiter</span><span class="p">):</span>
        <span class="n">found</span><span class="o">=</span><span class="kc">False</span>
        <span class="c1"># ---------------</span>
        <span class="c1"># Optimize offset      </span>
        <span class="c1"># --------------- </span>
        <span class="n">best_change_offs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span> <span class="c1">#Angstrom dx,dy</span>
        <span class="n">directions</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))]</span>
        <span class="k">if</span> <span class="n">advanced</span><span class="p">:</span>
            <span class="n">directions</span><span class="o">+=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">))]</span>
        <span class="k">for</span> <span class="n">co</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
            <span class="n">co</span><span class="o">=</span><span class="n">co</span><span class="o">*</span><span class="n">offset_stepwidth</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                <span class="n">box</span><span class="o">=</span><span class="n">get_box</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">curr_best_offs</span><span class="o">+</span><span class="n">co</span><span class="p">)</span>
                <span class="n">img</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="n">projection</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span><span class="n">dpi</span><span class="p">,</span> <span class="n">bounding_square</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                     <span class="n">rotate</span><span class="o">=</span><span class="n">curr_best_rotation</span><span class="p">)</span>
                <span class="n">tmp_score</span><span class="o">=</span><span class="n">distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">curr_best_score</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmp_score</span><span class="o">&gt;</span><span class="n">curr_best_score</span><span class="p">:</span>
                    <span class="c1">#print(&quot;co was {}&quot;.format(co)) #This was used to find the optimal stepwidth</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">tmp_score</span><span class="o">&lt;</span><span class="n">curr_best_score</span><span class="p">:</span>
                    <span class="n">curr_best_score</span><span class="o">=</span><span class="n">tmp_score</span>
                    <span class="n">best_change_offs</span><span class="o">=</span><span class="n">co</span>
                    <span class="c1">#print(&quot;co was {}&quot;.format(co))</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#Function value did not change. Our stepwidth was to small.</span>
                    <span class="n">co</span><span class="o">=</span><span class="n">co</span><span class="o">*</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1">#print (&quot;Offset: No change in direction &quot;, co)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">best_change_offs</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))):</span>
            <span class="n">found</span><span class="o">=</span><span class="kc">True</span>
        <span class="c1">#Save the new currently best offset</span>
        <span class="n">curr_best_offs</span><span class="o">=</span><span class="n">curr_best_offs</span><span class="o">+</span><span class="n">best_change_offs</span>

        <span class="c1">#The Box to be used in the following steps</span>
        <span class="n">box</span><span class="o">=</span><span class="n">get_box</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">curr_best_offs</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_best_score</span><span class="p">:</span> <span class="k">break</span> <span class="c1">#We reached zero</span>
        <span class="c1"># ----------------</span>
        <span class="c1"># Optimize rotation      </span>
        <span class="c1"># -----------------</span>
        <span class="n">best_change_rot</span><span class="o">=</span><span class="mi">0</span> <span class="c1">#degrees</span>
        <span class="k">for</span> <span class="n">cr</span> <span class="ow">in</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                <span class="n">img</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="n">projection</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span><span class="n">dpi</span><span class="p">,</span> <span class="n">bounding_square</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                     <span class="n">rotate</span><span class="o">=</span><span class="n">curr_best_rotation</span><span class="o">+</span><span class="n">cr</span><span class="p">)</span>
                <span class="n">tmp_score</span><span class="o">=</span><span class="n">distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">curr_best_score</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmp_score</span><span class="o">&gt;</span><span class="n">curr_best_score</span><span class="p">:</span>
                    <span class="c1">#print(&quot;cr was {}&quot;.format(cr))</span>
                    <span class="k">break</span>
                <span class="k">elif</span> <span class="n">tmp_score</span><span class="o">&lt;</span><span class="n">curr_best_score</span><span class="p">:</span>
                    <span class="n">curr_best_score</span><span class="o">=</span><span class="n">tmp_score</span>
                    <span class="n">best_change_rot</span><span class="o">=</span><span class="n">cr</span>
                    <span class="c1">#print(&quot;cr was {}&quot;.format(cr))</span>
                    <span class="k">break</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#Function value did not change. Our stepwidth was to small.</span>
                    <span class="n">cr</span><span class="o">=</span><span class="n">cr</span><span class="o">*</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1">#print (&quot;Rotation: No change in direction &quot;, cr)</span>
        <span class="k">if</span> <span class="n">best_change_rot</span><span class="o">!=</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">found</span><span class="o">=</span><span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">pass</span> <span class="c1"># If we didn&#39;t change the offset and didn&#39;t change the rotation, found stays True</span>
        <span class="n">curr_best_rotation</span><span class="o">=</span><span class="n">curr_best_rotation</span><span class="o">+</span><span class="n">best_change_rot</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">curr_best_score</span><span class="p">:</span> <span class="k">break</span> <span class="c1">#We reached zero</span>
        <span class="c1"># -----------------------------</span>
        <span class="c1"># Optimize projection direction      </span>
        <span class="c1"># -----------------------------</span>
        <span class="n">change_pro</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">))</span> <span class="c1">#polar coordinates</span>
        <span class="n">directions</span><span class="o">=</span><span class="p">[(</span><span class="mi">0</span><span class="p">,</span><span class="mf">0.002</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.002</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mf">0.002</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.002</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mf">0.002</span><span class="p">,</span><span class="mf">0.002</span><span class="p">),</span>
                                  <span class="p">(</span><span class="o">-</span><span class="mf">0.002</span><span class="p">,</span><span class="o">-</span><span class="mf">0.002</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.002</span><span class="p">,</span><span class="o">-</span><span class="mf">0.002</span><span class="p">),(</span><span class="o">-</span><span class="mf">0.002</span><span class="p">,</span><span class="mf">0.002</span><span class="p">)]</span>
        <span class="k">if</span> <span class="n">advanced</span><span class="p">:</span>
            <span class="n">directions</span><span class="o">+=</span><span class="p">[(</span><span class="mf">0.001</span><span class="p">,</span><span class="mf">0.002</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.001</span><span class="p">,</span> <span class="mf">0.002</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.002</span><span class="p">,</span><span class="mf">0.001</span><span class="p">),</span> <span class="p">(</span><span class="mf">0.002</span><span class="p">,</span><span class="o">-</span><span class="mf">0.001</span><span class="p">),(</span><span class="mf">0.001</span><span class="p">,</span><span class="o">-</span><span class="mf">0.002</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.001</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.002</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.002</span><span class="p">,</span><span class="mf">0.001</span><span class="p">),</span> <span class="p">(</span><span class="o">-</span><span class="mf">0.002</span><span class="p">,</span><span class="o">-</span><span class="mf">0.001</span><span class="p">)]</span>
        <span class="k">for</span> <span class="n">cp</span> <span class="ow">in</span> <span class="n">directions</span><span class="p">:</span>
            <span class="n">cp</span><span class="o">=</span><span class="p">(</span><span class="n">cp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">scale_projectionsteps</span><span class="p">,</span> <span class="n">cp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">scale_projectionsteps</span><span class="p">)</span>
            <span class="c1">#print(&quot;=======================================&quot;)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">):</span>
                <span class="n">tmp_projection</span><span class="o">=</span><span class="n">fhp</span><span class="o">.</span><span class="n">Projection2D</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">from_polar</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_best_pro</span><span class="o">+</span><span class="n">cp</span><span class="p">)),</span> 
                                <span class="n">project_virtual_atoms</span><span class="o">=</span><span class="n">virtual_atoms</span><span class="p">)</span>
                <span class="n">box</span><span class="o">=</span><span class="n">get_box</span><span class="p">(</span><span class="n">tmp_projection</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">curr_best_offs</span><span class="p">)</span>
                <span class="n">img</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="n">tmp_projection</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span><span class="n">dpi</span><span class="p">,</span> <span class="n">bounding_square</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                               <span class="n">rotate</span><span class="o">=</span><span class="n">curr_best_rotation</span><span class="p">)</span>
                <span class="n">tmp_score</span><span class="o">=</span><span class="n">distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">curr_best_score</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">tmp_score</span><span class="o">&gt;</span><span class="n">curr_best_score</span><span class="p">:</span>
                    <span class="c1">#print(&quot;Raising from {} to {}, cp was {}&quot;.format(curr_best_score, tmp_score, cp))</span>
                    <span class="k">break</span>                    
                    <span class="c1">#cp=np.array(cp)*2</span>
                <span class="k">elif</span> <span class="n">tmp_score</span><span class="o">&lt;</span><span class="n">curr_best_score</span><span class="p">:</span>                    
                    <span class="c1">#print(&quot;FALLING from {} to {}, cp was {}&quot;.format(curr_best_score, tmp_score, cp))</span>
                    <span class="n">curr_best_score</span><span class="o">=</span><span class="n">tmp_score</span>
                    <span class="n">projection</span><span class="o">=</span><span class="n">tmp_projection</span>
                    <span class="n">change_pro</span><span class="o">=</span><span class="n">cp</span>
                    <span class="k">break</span>
                    <span class="c1">#cp=np.array(cp)*2</span>
                <span class="k">else</span><span class="p">:</span>                
                    <span class="c1">#print (&quot;Score stays at {} in direction {}&quot;.format(tmp_score, cp))</span>
                    <span class="c1">#Function value did not change. Our stepwidth was to small.</span>
                    <span class="n">cp</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span> <span class="c1">#print (&quot;Projection: No change in direction &quot;, cp)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">change_pro</span><span class="o">==</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">0.</span><span class="p">,</span><span class="mf">0.</span><span class="p">))):</span>
            <span class="c1"># If we didn&#39;t change offset, projection or rotation, found still stays True</span>
            <span class="n">found</span><span class="o">=</span><span class="kc">False</span>
        <span class="n">curr_best_pro</span><span class="o">=</span><span class="n">curr_best_pro</span><span class="o">+</span><span class="n">change_pro</span>
        <span class="k">if</span> <span class="n">found</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">curr_best_score</span><span class="p">:</span>
            <span class="k">break</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">pass</span>
        <span class="c1">#print(&quot;Max-iter reached:&quot;, maxiter)</span>

    <span class="c1">##### This is just to detect bugs:</span>
    <span class="n">tmp_projection</span><span class="o">=</span><span class="n">fhp</span><span class="o">.</span><span class="n">Projection2D</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">from_polar</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">curr_best_pro</span><span class="p">)),</span> 
                                  <span class="n">project_virtual_atoms</span><span class="o">=</span><span class="n">virtual_atoms</span><span class="p">)</span>
    <span class="n">box</span><span class="o">=</span><span class="n">get_box</span><span class="p">(</span><span class="n">tmp_projection</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">curr_best_offs</span><span class="p">)</span>
    <span class="n">img</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="n">tmp_projection</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span><span class="n">dpi</span><span class="p">,</span> <span class="n">bounding_square</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                               <span class="n">rotate</span><span class="o">=</span><span class="n">curr_best_rotation</span><span class="p">)</span>
    <span class="n">best_score</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">best_score</span><span class="o">==</span><span class="n">curr_best_score</span>
    <span class="n">box</span><span class="o">=</span><span class="n">get_box</span><span class="p">(</span><span class="n">projection</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">curr_best_offs</span><span class="p">)</span>
    <span class="n">img</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="n">projection</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span><span class="n">dpi</span><span class="p">,</span> <span class="n">bounding_square</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> 
                                               <span class="n">rotate</span><span class="o">=</span><span class="n">curr_best_rotation</span><span class="p">)</span>
    <span class="n">best_score</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
    <span class="k">assert</span> <span class="n">best_score</span><span class="o">==</span><span class="n">curr_best_score</span>
    <span class="c1">######</span>

    <span class="k">return</span> <span class="n">curr_best_score</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="p">[</span> <span class="n">curr_best_pro</span><span class="p">,</span> <span class="n">curr_best_rotation</span><span class="p">,</span> <span class="n">curr_best_offs</span> <span class="p">]</span></div>

<div class="viewcode-block" id="try_parameters"><a class="viewcode-back" href="../../../apidoc/forgi.projection.hausdorff.html#forgi.projection.hausdorff.try_parameters">[docs]</a><span class="k">def</span> <span class="nf">try_parameters</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> 
                   <span class="n">rotations</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">180</span><span class="p">),</span> <span class="n">offsets</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),),</span> <span class="n">proj_directions</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                   <span class="n">virtual_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Try all combinations of the given starting parameters </span>
<span class="sd">    (offset, in-plane rotation and projection direction)</span>
<span class="sd">    and find the ones with the shorthest Huasdorff distance.</span>
<span class="sd">    </span>
<span class="sd">    :param ref_img: The reference image. A boolean square matrix.</span>
<span class="sd">    :param scale: The edge length in Angstrom of the reference image.</span>
<span class="sd">    :param cg: The coarse grain RNA to match to the projection.</span>

<span class="sd">    :param rotations: A list of in-plane rotations in degrees.</span>
<span class="sd">    :param offsets: A list/array of np.arrays of the type np.array([x,y]).</span>
<span class="sd">    :param proj_directions: A list of projection_directions (tuples theta, phi) or None.</span>
<span class="sd">                            If None, uses cg.project_from.</span>
<span class="sd">    :param virtual_atoms: Boolean. If False, do not project virtual atoms (faster)</span>

<span class="sd">    :returns: A triple: (best_distance, best_image, best_parameters)</span>
<span class="sd">              Where best_distance is a float, best_image a matrix and best params is a triple:</span>
<span class="sd">              np.array([theta, phi]), degrees, np.array([x_offset, y_offset])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">proj_directions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">proj_directions</span><span class="o">=</span><span class="p">[</span><span class="n">to_polar</span><span class="p">(</span><span class="n">cg</span><span class="o">.</span><span class="n">project_from</span><span class="p">)[</span><span class="mi">1</span><span class="p">:]]</span>
    <span class="n">best_distance</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="n">params</span><span class="o">=</span><span class="p">[</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span>
    <span class="n">best_img</span><span class="o">=</span><span class="kc">None</span>
    <span class="k">for</span> <span class="n">rot</span> <span class="ow">in</span> <span class="n">rotations</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">offsets</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">proj</span> <span class="ow">in</span> <span class="n">proj_directions</span><span class="p">:</span>
                <span class="n">dist</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">locally_minimal_distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span>  <span class="n">rot</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">proj</span><span class="p">,</span>
                                            <span class="n">maxiter</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">virtual_atoms</span><span class="o">=</span><span class="n">virtual_atoms</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">dist</span><span class="o">&lt;</span><span class="n">best_distance</span><span class="p">:</span>
                    <span class="n">best_distance</span><span class="o">=</span><span class="n">dist</span>
                    <span class="n">best_params</span><span class="o">=</span><span class="n">params</span>
                    <span class="n">best_img</span><span class="o">=</span><span class="n">img</span>
    <span class="k">return</span> <span class="n">best_distance</span><span class="p">,</span> <span class="n">best_img</span><span class="p">,</span> <span class="n">best_params</span></div>

<span class="k">def</span> <span class="nf">get_start_points</span><span class="p">(</span><span class="n">numPoints</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Return numPoints equally-distributed points on the unit sphere in polar coordinates.</span>

<span class="sd">    Implements the 2nd algorithm from https://www.cmu.edu/biolphys/deserno/pdf/sphere_equi.pdf</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">a</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">numPoints</span>
    <span class="n">d</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">Mt</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>
    <span class="n">dt</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">Mt</span>
    <span class="n">df</span><span class="o">=</span><span class="n">a</span><span class="o">/</span><span class="n">dt</span>
    <span class="n">points</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Mt</span><span class="p">):</span>
        <span class="n">theta</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">Mt</span>
        <span class="n">Mf</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Mf</span><span class="p">):</span>
            <span class="n">phi</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">Mf</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">points</span>

<span class="k">def</span> <span class="nf">arclength</span><span class="p">(</span><span class="n">theta1</span><span class="p">,</span> <span class="n">phi1</span><span class="p">,</span> <span class="n">theta2</span><span class="p">,</span> <span class="n">phi2</span><span class="p">):</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">acos</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">+</span>
            <span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta1</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta2</span><span class="p">)</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">phi1</span><span class="o">-</span><span class="n">phi2</span><span class="p">)))</span>

<span class="k">def</span> <span class="nf">get_start_points_near</span><span class="p">(</span><span class="n">numPoints</span><span class="p">,</span> <span class="n">ref_theta</span><span class="p">,</span> <span class="n">ref_phi</span><span class="p">):</span>
    <span class="n">a</span><span class="o">=</span><span class="mi">4</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">numPoints</span>
    <span class="n">d</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">Mt</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">d</span><span class="p">)</span>
    <span class="n">dt</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">Mt</span>
    <span class="n">df</span><span class="o">=</span><span class="n">a</span><span class="o">/</span><span class="n">dt</span>
    <span class="n">points</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Mt</span><span class="p">):</span>
        <span class="n">theta</span><span class="o">=</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="p">(</span><span class="n">m</span><span class="o">+</span><span class="mf">0.5</span><span class="p">)</span><span class="o">/</span><span class="n">Mt</span>
        <span class="n">Mf</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">/</span><span class="n">df</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">Mf</span><span class="p">):</span>
            <span class="n">phi</span><span class="o">=</span><span class="mi">2</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">n</span><span class="o">/</span><span class="n">Mf</span>
            <span class="n">points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)))</span>
    <span class="k">return</span> <span class="p">[</span> <span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">points</span> <span class="k">if</span> <span class="n">arclength</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ref_theta</span><span class="p">,</span> <span class="n">ref_phi</span><span class="p">)</span><span class="o">&lt;</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">6</span><span class="p">]</span>

<div class="viewcode-block" id="get_longest_img_diameter"><a class="viewcode-back" href="../../../apidoc/forgi.projection.hausdorff.html#forgi.projection.hausdorff.get_longest_img_diameter">[docs]</a><span class="k">def</span> <span class="nf">get_longest_img_diameter</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">scale</span><span class="p">):</span>
    <span class="n">maxl</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">x1</span><span class="p">,</span><span class="n">y1</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span><span class="p">)):</span>
        <span class="k">for</span> <span class="n">x2</span><span class="p">,</span><span class="n">y2</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">img</span><span class="p">)):</span>
            <span class="n">l</span><span class="o">=</span><span class="p">(</span><span class="n">x1</span><span class="o">-</span><span class="n">x2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">y2</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
            <span class="k">if</span> <span class="n">l</span><span class="o">&gt;</span><span class="n">maxl</span><span class="p">:</span>
                <span class="n">maxl</span><span class="o">=</span><span class="n">l</span>
    <span class="k">return</span> <span class="n">math</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">maxl</span><span class="p">)</span><span class="o">*</span><span class="n">scale</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">img</span><span class="p">)</span></div>

<span class="k">def</span> <span class="nf">_try_startpoints</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> <span class="n">start_points</span><span class="p">,</span> <span class="n">starting_rotations</span><span class="p">,</span> 
                     <span class="n">starting_offsets</span><span class="p">,</span> <span class="n">local_maxiter</span><span class="p">,</span> <span class="n">virtual_atoms</span><span class="p">,</span> <span class="n">use_heuristic</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">verbose</span><span class="p">):</span>
    <span class="c1">#Longest extention in the image</span>
    <span class="n">longest_distance_image</span><span class="o">=</span><span class="n">get_longest_img_diameter</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">longest_distance_image</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Reference image probably empty&quot;</span><span class="p">)</span>

    <span class="c1">#We count, how often certain heuristics kicked in</span>
    <span class="n">la_heur</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">no_heur</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">score_heur</span><span class="o">=</span><span class="mi">0</span>
    <span class="c1">#</span>
    <span class="n">dpi</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">ref_img</span><span class="p">)</span>
    <span class="n">best_score</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s1">&#39;inf&#39;</span><span class="p">)</span>
    <span class="n">decrease</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">project_dir</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">start_points</span><span class="p">):</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:2.0%}</span><span class="se">\r</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">/</span><span class="nb">len</span><span class="p">(</span><span class="n">start_points</span><span class="p">)))</span><span class="c1">#Progress</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="n">proj</span><span class="o">=</span><span class="n">fhp</span><span class="o">.</span><span class="n">Projection2D</span><span class="p">(</span><span class="n">cg</span><span class="p">,</span> <span class="n">from_polar</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="nb">list</span><span class="p">(</span><span class="n">project_dir</span><span class="p">)),</span> 
                              <span class="n">project_virtual_atoms</span><span class="o">=</span><span class="n">virtual_atoms</span><span class="p">)</span>
        
        <span class="k">if</span> <span class="n">use_heuristic</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">proj</span><span class="o">.</span><span class="n">longest_axis</span><span class="o">-</span><span class="n">longest_distance_image</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">6</span><span class="o">*</span><span class="n">scale</span><span class="o">/</span><span class="n">dpi</span><span class="p">:</span> <span class="c1">#4 pixels is arbitrary heuristic</span>
                <span class="c1">#print(&quot;abs({}-{})={}&gt;{}&quot;.format(proj.longest_axis, longest_distance_image, abs(proj.longest_axis-longest_distance_image), 6*scale/dpi))                </span>
                <span class="c1">#proj.plot(show=True)</span>
                <span class="n">la_heur</span><span class="o">+=</span><span class="mi">1</span>
                <span class="k">continue</span>
        <span class="n">loc_best_rot</span><span class="o">=</span><span class="mi">0</span>
        <span class="n">loc_best_offs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>           
        <span class="n">loc_best_score</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">rot</span><span class="p">,</span> <span class="n">offset</span> <span class="ow">in</span> <span class="n">it</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">starting_rotations</span><span class="p">,</span> <span class="n">starting_offsets</span><span class="p">):</span>
            <span class="n">box</span><span class="o">=</span><span class="n">get_box</span><span class="p">(</span><span class="n">proj</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
            <span class="n">img</span><span class="p">,</span><span class="n">_</span><span class="o">=</span><span class="n">proj</span><span class="o">.</span><span class="n">rasterize</span><span class="p">(</span><span class="n">dpi</span><span class="p">,</span> <span class="n">bounding_square</span><span class="o">=</span><span class="n">box</span><span class="p">,</span> <span class="n">warn</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rotate</span><span class="o">=</span><span class="n">rot</span><span class="p">)</span>
            <span class="n">score</span> <span class="o">=</span> <span class="n">distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">img</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">score</span><span class="o">&lt;</span><span class="n">loc_best_score</span><span class="p">:</span>
                <span class="n">loc_best_score</span><span class="o">=</span><span class="n">score</span>
                <span class="n">loc_best_rot</span><span class="o">=</span><span class="n">rot</span>
                <span class="n">loc_best_offs</span><span class="o">=</span><span class="n">offset</span>
                <span class="c1">#loc_best_img=img</span>
        <span class="c1">#print(&quot;HEUR?&quot;, loc_best_score, best_score, best_score+(decrease*1.5))</span>
        <span class="k">if</span> <span class="n">use_heuristic</span> <span class="ow">and</span> <span class="n">loc_best_score</span><span class="o">&gt;</span><span class="n">best_score</span><span class="o">+</span><span class="p">(</span><span class="n">decrease</span><span class="o">*</span><span class="mf">1.75</span><span class="p">):</span>
            <span class="n">score_heur</span><span class="o">+=</span><span class="mi">1</span> 
            <span class="c1">#print(&quot;Score&quot;)</span>
            <span class="c1">#proj.plot(show=True)</span>
            <span class="k">continue</span>
        <span class="c1">#import matplotlib.pyplot as plt</span>
        <span class="c1">#fig, ax=plt.subplots(3)</span>
        <span class="c1">#ax[0].imshow(ref_img, interpolation=&quot;none&quot;, cmap=&#39;gray&#39;)</span>
        <span class="c1">#ax[1].imshow(loc_best_img, interpolation=&quot;none&quot;, cmap=&#39;gray&#39;)</span>
        <span class="c1">#ax[0].set_title(&quot;Reference&quot;)</span>
        <span class="c1">#ax[1].set_title(&quot;Initial distance {}&quot;.format(loc_best_score))</span>
        <span class="n">no_heur</span><span class="o">+=</span><span class="mi">1</span>
        <span class="n">score</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">locally_minimal_distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> 
                                                      <span class="n">loc_best_rot</span><span class="p">,</span> <span class="n">loc_best_offs</span><span class="p">,</span> <span class="n">project_dir</span><span class="p">,</span>
                                                      <span class="n">maxiter</span><span class="o">=</span><span class="n">local_maxiter</span><span class="p">,</span> 
                                                      <span class="n">virtual_atoms</span><span class="o">=</span><span class="n">virtual_atoms</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">)</span>
        <span class="c1">#ax[2].imshow(img, interpolation=&quot;none&quot;, cmap=&#39;gray&#39;)</span>
        <span class="c1">#ax[2].set_title(&quot;Optimized to {}&quot;.format(score))</span>
        <span class="c1">#plt.show()</span>
        <span class="k">if</span> <span class="n">score</span><span class="o">&lt;</span><span class="n">best_score</span><span class="p">:</span>
            <span class="n">best_score</span><span class="o">=</span><span class="n">score</span>
            <span class="n">best_img</span><span class="o">=</span><span class="n">img</span>
            <span class="n">best_params</span><span class="o">=</span><span class="n">params</span>
            <span class="n">decrease</span><span class="o">=</span><span class="n">loc_best_score</span><span class="o">-</span><span class="n">score</span> <span class="c1">#Can increase or decrease</span>
            <span class="c1">#print(&quot;Decrease {} to {}&quot;.format(loc_best_score, score), decrease)</span>
        <span class="k">if</span> <span class="n">best_score</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span> 
            <span class="k">break</span>
    <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;   </span><span class="se">\r</span><span class="s2">&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Global optimization performe!</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{}</span><span class="s2"> local optimizations performed</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{}</span><span class="s2"> skipped (longest distance)</span><span class="se">\n</span><span class="s2">&quot;</span>
              <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{}</span><span class="s2"> skipped (score)&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">no_heur</span><span class="p">,</span> <span class="n">la_heur</span><span class="p">,</span> <span class="n">score_heur</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">no_heur</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;During global optimization, NO SMALL DISTANCE could be found.</span><span class="se">\n</span><span class="s2">&quot;</span>
                  <span class="s2">&quot;</span><span class="se">\t</span><span class="si">{}</span><span class="s2"> attempts were skipped because the diameters didn&#39;t match.</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">la_heur</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">),</span> <span class="kc">None</span><span class="p">,</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">])]</span>
    <span class="k">return</span> <span class="n">best_score</span><span class="p">,</span> <span class="n">best_img</span><span class="p">,</span> <span class="n">best_params</span>

<div class="viewcode-block" id="globally_minimal_distance"><a class="viewcode-back" href="../../../apidoc/forgi.projection.hausdorff.html#forgi.projection.hausdorff.globally_minimal_distance">[docs]</a><span class="k">def</span> <span class="nf">globally_minimal_distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span>                               
                              <span class="n">start_points</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span>
                              <span class="n">starting_rotations</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">180</span><span class="p">),</span> 
                              <span class="n">starting_offsets</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]),</span> <span class="p">),</span> 
                              <span class="n">local_maxiter</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">use_heuristic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">virtual_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                              <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">hausdorff_distance</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Global minimization of Hausdorff distance.</span>

<span class="sd">    Uses several Heuristics to speed up the process.</span>
<span class="sd">    </span>
<span class="sd">    :param ref_img: The reference image. A boolean square matrix.</span>
<span class="sd">    :param scale: The edge length in Angstrom of the reference image.</span>
<span class="sd">    :param cg: The coarse grain RNA to match to the projection.</span>

<span class="sd">    :param start_points: Number of starting projection directions. For each, local</span>
<span class="sd">                         optimization with maxiter steps is performed.</span>
<span class="sd">    :param starting_rotations: A list of in-plane rotations in degrees.</span>
<span class="sd">    :param starting_offsets: A list/array of np.arrays of the type np.array([x,y]).</span>

<span class="sd">    :param local_maxiter: Maximal iteration for each local optimization</span>
<span class="sd">    :param use_heuristic: A Boolean</span>
<span class="sd">    :param virtual_atoms: Boolean. If False, do not project virtual atoms (faster)</span>
<span class="sd">    :param verbose: If True, print a summary at the end.</span>

<span class="sd">    :returns: A triple: (best_distance, best_image, best_parameters)</span>
<span class="sd">              Where best_distance is a float, best_image a matrix and best params is a triple:</span>
<span class="sd">              np.array([theta, phi]), degrees, np.array([x_offset, y_offset])</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">best_score</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="n">decrease</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">)</span>
    <span class="n">sp</span><span class="o">=</span><span class="n">get_start_points</span><span class="p">(</span><span class="n">start_points</span><span class="p">)</span>

    <span class="c1">#We want to cover many different directions with the first few iterations.</span>
    <span class="n">r</span><span class="o">=</span><span class="n">random</span><span class="o">.</span><span class="n">Random</span><span class="p">()</span>
    <span class="n">r</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">r</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">sp</span><span class="p">)</span>
    <span class="c1">#random.shuffle(sp)</span>

    <span class="n">best_score</span><span class="p">,</span> <span class="n">best_img</span><span class="p">,</span> <span class="n">best_params</span> <span class="o">=</span><span class="n">_try_startpoints</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> 
                      <span class="n">starting_rotations</span><span class="p">,</span> <span class="n">starting_offsets</span><span class="p">,</span> <span class="n">local_maxiter</span><span class="p">,</span> <span class="n">virtual_atoms</span><span class="p">,</span> 
                      <span class="n">use_heuristic</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="c1">#import matplotlib.pyplot as plt</span>
    <span class="c1">#fig, ax=plt.subplots(2)</span>
    <span class="c1">#ax[0].imshow(ref_img, interpolation=&quot;none&quot;, cmap=&#39;gray&#39;)</span>
    <span class="c1">#ax[1].imshow(best_img, interpolation=&quot;none&quot;, cmap=&#39;gray&#39;)</span>
    <span class="c1">#ax[0].set_title(&quot;Reference&quot;)</span>
    <span class="c1">#ax[1].set_title(&quot;distance {}&quot;.format(best_score))</span>
    <span class="c1">#plt.show()</span>

    <span class="c1">#Global search in vicinity of best match</span>
    <span class="n">sp</span> <span class="o">=</span> <span class="n">get_start_points_near</span><span class="p">(</span><span class="mi">10</span><span class="o">*</span><span class="n">start_points</span><span class="p">,</span> <span class="n">best_params</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">best_params</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Current best score </span><span class="si">{}</span><span class="s2">, refining on </span><span class="si">{}</span><span class="s2"> points&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">best_score</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sp</span><span class="p">)))</span>
    <span class="n">best_score1</span><span class="p">,</span> <span class="n">best_img1</span><span class="p">,</span> <span class="n">best_params1</span> <span class="o">=</span><span class="n">_try_startpoints</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span>
                      <span class="p">[</span><span class="n">best_params</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="n">best_params</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="n">local_maxiter</span><span class="p">,</span> <span class="n">virtual_atoms</span><span class="p">,</span>
                      <span class="n">use_heuristic</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">best_score1</span><span class="o">&lt;</span><span class="n">best_score</span><span class="p">:</span>
        <span class="n">best_score</span><span class="o">=</span><span class="n">best_score1</span>
        <span class="n">best_params</span><span class="o">=</span><span class="n">best_params1</span>
        <span class="n">best_img</span><span class="o">=</span><span class="n">best_img1</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Refinement helped.&quot;</span><span class="p">,</span> <span class="n">best_score</span><span class="p">)</span>
    <span class="c1">#import matplotlib.pyplot as plt</span>
    <span class="c1">#fig, ax=plt.subplots(2)</span>
    <span class="c1">#ax[0].imshow(ref_img, interpolation=&quot;none&quot;, cmap=&#39;gray&#39;)</span>
    <span class="c1">#ax[1].imshow(best_img, interpolation=&quot;none&quot;, cmap=&#39;gray&#39;)</span>
    <span class="c1">#ax[0].set_title(&quot;Reference&quot;)</span>
    <span class="c1">#ax[1].set_title(&quot;distance {}&quot;.format(best_score))</span>
    <span class="c1">#plt.show()</span>

    <span class="c1">#Refinement of the best match</span>
    <span class="n">score</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">params</span> <span class="o">=</span> <span class="n">locally_minimal_distance</span><span class="p">(</span><span class="n">ref_img</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">cg</span><span class="p">,</span> 
                                                  <span class="n">best_params</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">best_params</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">best_params</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                                                  <span class="n">maxiter</span><span class="o">=</span><span class="mi">20</span><span class="o">*</span><span class="n">local_maxiter</span><span class="p">,</span>
                                                  <span class="n">advanced</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                  <span class="n">virtual_atoms</span><span class="o">=</span><span class="n">virtual_atoms</span><span class="p">,</span> <span class="n">distance</span><span class="o">=</span><span class="n">distance</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">score</span><span class="p">,</span> <span class="n">img</span><span class="p">,</span> <span class="n">params</span></div>


</pre></div>

      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016 Peter Kerpedjiev &lt;pkerp@tbi.univie.ac.at&gt;; 2015,2016 Bernhard Thiel &lt;thiel@tbi.univie.ac.at&gt;.
      Last updated on Feb 06, 2018.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.7.
    </div>
  </body>
</html>