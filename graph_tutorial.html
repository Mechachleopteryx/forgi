

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>RNA Secondary Structure as a Graph Using the forgi Library &#8212; forgi 1.0 documentation</title>
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="RNA 3D Structure Using forgi.threedee" href="threedee_tutorial.html" />
    <link rel="prev" title="RNA Secondary Structure Utilities Using the forgi.utilities Submodule" href="utilities_tutorial.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>forgi 1.0 documentation</span></a></h1>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="utilities_tutorial.html">RNA Secondary Structure Utilities Using the forgi.utilities Submodule</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="threedee_tutorial.html">RNA 3D Structure Using forgi.threedee</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="rna-secondary-structure-as-a-graph-using-the-forgi-library">
<span id="forgi-graph-tutorial"></span><h1>RNA Secondary Structure as a Graph Using the forgi Library<a class="headerlink" href="#rna-secondary-structure-as-a-graph-using-the-forgi-library" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>forgi is a library for manipulating RNA as a graph-like
structure. It provides classes for reading, storing, manipulating and
outputting RNA structures. It classifies and stores RNA secondary
structure in a data structure that quickly allows one to determine
which elements are connected and which nucleotides they contain.</p>
<p>The secondary structure of an RNA molecule can be divided into
five different types of ‘elements’. Each element is assigned a name that
can be used to refer to it and to determine its identity:</p>
<ul class="simple">
<li><strong>fiveprime:</strong> The unpaired nucleotides at the 5’ end of a molecule/ chain. Always start with ‘f’ (e.g. ‘f0’).</li>
<li><strong>threeprime</strong>: The unpaired nucleotides at the 3’ end of a molecule/ chain. Always start with ‘t’ (e.g. ‘t0’)</li>
<li><dl class="first docutils">
<dt><strong>stem:</strong> Regions of contiguous canonical Watson-Crick base-paired nucleotides.</dt>
<dd>Always start with ‘s’ (e.g., ‘s0’, ‘s1’, ‘s2’, …)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>interior loop:</strong> Bulged out nucleotides. Unpaird double stranded regions, flanked by stems on either side.</dt>
<dd>Always start with ‘i’ (‘i0’, ‘i1’, ‘i2’,…)</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt><strong>multiloop segment:</strong> Single-stranded unpaired regions. Always start with ‘m’. (‘m0’, ‘m1’, ‘m2’…)</dt>
<dd>In the current version of forgi, pseudo-knots and exterior loops segments between stems are treated as multiloop segments.</dd>
</dl>
</li>
<li><strong>hairpin loop:</strong> Always start with ‘h’.</li>
</ul>
</div>
<div class="section" id="a-simple-example">
<h2>A Simple Example<a class="headerlink" href="#a-simple-example" title="Permalink to this headline">¶</a></h2>
<p>The use of forgi is perhaps best illustrated with an
example.</p>
<p>Let’s take an RNA sequence:</p>
<p><code class="docutils literal"><span class="pre">CGCUUCAUAUAAUCCUAAUGAUAUGGUUUGGGAGUUUCUACCAAGAGCCUUAAACUCUUGAUUAUGAAGUG</span></code></p>
<p>We can predict its secondary structure using one of a number of tools,
including the Vienna RNA Package’s RNAfold program:</p>
<p><a class="reference external" href="http://rna.tbi.univie.ac.at/cgi-bin/RNAWebSuite/RNAfold.cgi">http://rna.tbi.univie.ac.at/cgi-bin/RNAWebSuite/RNAfold.cgi</a></p>
<p>This will return a minimum free energy structure which can be represented using
dot-bracket notation:</p>
<p><code class="docutils literal"><span class="pre">(((((((((...((((((.........))))))........((((((.......))))))..)))))))))</span></code></p>
<p>This notation corresponds to a structure containing the base pairs shown in the
following figure:</p>
<a class="reference internal image-reference" href="_images/1y26_ss.png"><img alt="_images/1y26_ss.png" class="align-center" src="_images/1y26_ss.png" style="width: 260px; height: 260px;" /></a>
<p>Evident in this image are six structural elements.</p>
<blockquote>
<div><ul class="simple">
<li>3 stems</li>
<li>2 hairpin loops</li>
<li>1 multiloop</li>
</ul>
</div></blockquote>
<p>The multiloop itself can be divided into three unpaired sections of
nucleotides. Each of these elements is connected to certain other elements. For
example, the stem at the top is connected to two unpaired regions of the
multi-loop. Both of the hairpin loops are connected one stem each. If we
abstract away the sequence information, we can imagine the structure as being
represented by a graph.</p>
<p>The forgi package can be used to do just this by using the
dotbracket_to_bulge_graph.py script:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ python examples/rnaConvert.py examples/input/1y26_ss.dotbracket -T forgi
name untitled
length 71
define m2 34 41
define h1 48 54
define s2 42 47 55 60
define s1 13 18 28 33
define s0 1 9 63 71
define m1 10 12
define h0 19 27
define m0 61 62
connect s2 h1 m0 m2
connect s1 h0 m1 m2
connect s0 m1 m0
</pre></div>
</div>
<p>The result is an adjacency list of all the elements. The stems are defined with
names starting with ‘s’, hairpins with an ‘h’, multiloops with an ‘m’, interior
loops with an ‘i’, five-prime unpaired regions with an ‘f’ and three-prime
unpaired regions with a ‘t’. The numbers indicate the nucleotides that are
present in each element. So the stem s0 is composed of nucleotides 1 to 9 on
one strand and 63 to 71 on the other. The other elements are described in a
similar manner. The hairpin <em>h0</em> includes the nucleotides 19 to 27.</p>
<p>In this case it is difficult to picture which section is which from the text
representation. To make it easier, we will generate a file
readable by graphviz. The <em>neato</em> program can take that as input and create a
nice visualization of the graph:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="n">examples</span><span class="o">/</span><span class="n">rnaConvert</span><span class="o">.</span><span class="n">py</span> <span class="n">examples</span><span class="o">/</span><span class="nb">input</span><span class="o">/</span><span class="mi">1</span><span class="n">y26_ss</span><span class="o">.</span><span class="n">dotbracket</span> <span class="o">-</span><span class="n">T</span> <span class="n">neato</span> <span class="o">|</span> <span class="n">neato</span> <span class="o">-</span><span class="n">Tpng</span> <span class="o">-</span><span class="n">o</span> <span class="mi">1</span><span class="n">y26_neato</span><span class="o">.</span><span class="n">png</span>
</pre></div>
</div>
<p>The result is the following graph representation of the structure.</p>
<a class="reference internal image-reference" href="_images/1y26_neato.png"><img alt="_images/1y26_neato.png" class="align-center" src="_images/1y26_neato.png" style="width: 200px; height: 200px;" /></a>
<p>Here square nodes represent stems and round nodes represent other elements.
The connections in this representation do not contain any nucleotides,
but simply illustrate which coarse grained elements are connected to each other.</p>
<p>The label of the nodes are the element names (as described above), so “s0” means stem number 0.
The numbers in parenthesis below the element names represent the number of nucleotides in the element.
In case of interior loops (not shown in this example), there can be two numbers, if the RNA has
unpaired nucleotides on both sides of the bulge.</p>
<p>Notice the similarity to the original base paired image? The top stem can be
identified as <em>s0</em>. The two hairpin loops are <em>h0</em> and <em>h1</em>. The regions in the
multiloop are given their own names.</p>
<p>This graph visualization is useful to get an idea of the coarse grained representation
of the RNA introduced by forgi. However, some information is lost in this picture:
This graph only shows, which stem is connected to which bulge, but it does not show which
side of the stem and bulge is involved in the connection.</p>
<div class="section" id="getting-a-condensed-representation-of-the-element-types">
<h3>Getting a Condensed Representation of the Element Types<a class="headerlink" href="#getting-a-condensed-representation-of-the-element-types" title="Permalink to this headline">¶</a></h3>
<p>Mapping nucleotide positions to secondary structure element types (stems,
hairpins, multiloops) is easily done using an example script:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span>$ python examples/rnaConvert.py examples/input/1y26_ss.dotbracket -T element_string
(((((((((...((((((.........))))))........((((((.......))))))..)))))))))
sssssssssmmmsssssshhhhhhhhhssssssmmmmmmmmsssssshhhhhhhssssssmmsssssssss
</pre></div>
</div>
<p>In this example, one can clearly see that the paired regions are stems. Some
multiloops are present as well as two hairpin regions.</p>
</div>
<div class="section" id="another-example">
<h3>Another Example<a class="headerlink" href="#another-example" title="Permalink to this headline">¶</a></h3>
<p>Here’s an example with a longer sequence.</p>
<p>Let’s take an RNA sequence:</p>
<p><code class="docutils literal"><span class="pre">GAAUUGCGGGAAAGGGGUCAACAGCCGUUCAGUACCAAGUCUCAGGGGAAACUUUGAGAUGGCCUUGCAAAGGGUAUGGUAAUAAGCUGACGGACAUGGUCCUAACCACGCAGCCAAGUCCUAAGUCAACAGAUCUUCUGUUGAUAUGGAUGCAGUUC</span></code></p>
<p>With a secondary structure:</p>
<p><code class="docutils literal"><span class="pre">....((((((....((.......((((.((((.(((...(((((..........)))))...((.......))....)))......))))))))......))...)).))))......(((....((((((((...))))))))...)))........</span></code></p>
<p>Which looks like this:</p>
<a class="reference internal image-reference" href="_images/1gid_ss.png"><img alt="_images/1gid_ss.png" class="align-center" src="_images/1gid_ss.png" style="width: 360px; height: 360px;" /></a>
<p>Can be transformed using the command:</p>
<p><code class="docutils literal"><span class="pre">python</span> <span class="pre">examples/rnaConvert.py</span> <span class="pre">-T</span> <span class="pre">neato</span> <span class="pre">examples/input/1gid_ss.dotbracket</span> <span class="pre">|</span> <span class="pre">neato</span> <span class="pre">-Tpng</span> <span class="pre">-o</span> <span class="pre">1gid_neato.png</span></code></p>
<p>Into a graph that looks like this:</p>
<a class="reference internal image-reference" href="_images/1gid_neato.png"><img alt="_images/1gid_neato.png" class="align-center" src="_images/1gid_neato.png" style="width: 500px; height: 500px;" /></a>
<p>Note that the graph and the secondary structure representation are oriented
differently. The multiloop at the top of the graph is at the bottom of the
secondary structure. Furthermore, some of the small bulges clearly visible in
the graph (as yellow nodes) are hard to see in the secondary structure although
they are indeed present.</p>
</div>
</div>
<div class="section" id="loading-structures">
<h2>Loading Structures<a class="headerlink" href="#loading-structures" title="Permalink to this headline">¶</a></h2>
<p>There are a number of ways to represent an RNA secondary structure and forgi
provides functionality for reading a number of them.</p>
<div class="section" id="loading-a-structure-from-a-dot-bracket-string">
<h3>Loading a Structure from a Dot-Bracket String<a class="headerlink" href="#loading-a-structure-from-a-dot-bracket-string" title="Permalink to this headline">¶</a></h3>
<p>A pseudoknot-free secondary structure can be represented a sequence of dots and
brackets where the dots represent unpaired bases and the matching brackets
represent base pairs. This representation is often delivered as the output of
secondary structure prediction tools such as <a class="reference external" href="http://rna.tbi.univie.ac.at/cgi-bin/RNAfold.cgi">RNAfold</a> and <a class="reference external" href="http://mfold.rna.albany.edu/?q=mfold">Mfold</a>. It can
also be used as input to create a skeleton graph in <code class="code docutils literal"><span class="pre">forgi</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="s1">&#39;((..))..((..))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">bg</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>
<span class="go">name untitled</span>
<span class="go">length 14</span>
<span class="go">seq_ids</span>
<span class="go">define h1 11 12</span>
<span class="go">define s1 9 10 13 14</span>
<span class="go">define s0 1 2 5 6</span>
<span class="go">define m0 7 8</span>
<span class="go">define h0 3 4</span>
<span class="go">connect s1 h1 m0</span>
<span class="go">connect s0 h0 m0</span>
</pre></div>
</div>
</div>
<div class="section" id="loading-a-structure-from-a-bpseq-formatted-file">
<h3>Loading a Structure from a BPSEQ Formatted File:<a class="headerlink" href="#loading-a-structure-from-a-bpseq-formatted-file" title="Permalink to this headline">¶</a></h3>
<p>A bpseq-formatted file stores the sequence and base-pair content of an RNA
secondary structure using one line for each nucleotide in the sequence. Each
line has three columns, the index of the nucleotide being described, it’s
identity (A, C, G, or U) and the index of its pairing partner (0 if none). We
can load this file and create graph structure from it using the
<code class="code docutils literal"><span class="pre">from_bpseq_str</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bpstr</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;1 A 0</span>
<span class="gp">... </span><span class="s2">2 A 12</span>
<span class="gp">... </span><span class="s2">3 A 11</span>
<span class="gp">... </span><span class="s2">4 A 9</span>
<span class="gp">... </span><span class="s2">5 A 8</span>
<span class="gp">... </span><span class="s2">6 A 0</span>
<span class="gp">... </span><span class="s2">7 A 0</span>
<span class="gp">... </span><span class="s2">8 A 5</span>
<span class="gp">... </span><span class="s2">9 A 4</span>
<span class="gp">... </span><span class="s2">10 A 0</span>
<span class="gp">... </span><span class="s2">11 A 3</span>
<span class="gp">... </span><span class="s2">12 A 2</span>
<span class="gp">... </span><span class="s2">13 A 0</span>
<span class="gp">... </span><span class="s2">14 A 0</span>
<span class="gp">... </span><span class="s2">15 A 20</span>
<span class="gp">... </span><span class="s2">16 A 19</span>
<span class="gp">... </span><span class="s2">17 A 0</span>
<span class="gp">... </span><span class="s2">18 A 0</span>
<span class="gp">... </span><span class="s2">19 A 16</span>
<span class="gp">... </span><span class="s2">20 A 15</span>
<span class="gp">... </span><span class="s2">21 A 0</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span>
<span class="go">&gt;&gt;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">from_bpseq_str</span><span class="p">(</span><span class="n">bpstr</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">bg</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>
<span class="go">name untitled</span>
<span class="go">length 21</span>
<span class="go">seq AAAAAAAAAAAAAAAAAAAAA</span>
<span class="go">seq_ids</span>
<span class="go">define f1 1 1</span>
<span class="go">define i0 10 10</span>
<span class="go">define h1 17 18</span>
<span class="go">define s2 15 16 19 20</span>
<span class="go">define s1 4 5 8 9</span>
<span class="go">define s0 2 3 11 12</span>
<span class="go">define t1 21 21</span>
<span class="go">define h0 6 7</span>
<span class="go">define m0 13 14</span>
<span class="go">connect s2 h1 m0 t1</span>
<span class="go">connect s1 i0 h0</span>
<span class="go">connect s0 f1 m0 i0</span>
</pre></div>
</div>
</div>
<div class="section" id="loading-a-structure-from-a-fasta-file">
<h3>Loading a Structure from a Fasta File<a class="headerlink" href="#loading-a-structure-from-a-fasta-file" title="Permalink to this headline">¶</a></h3>
<p>A fasta file containing an id, a sequence and a secondary structure in
dot-bracket notation can be used to create a BulgeGraph structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">from_fasta_text</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;&gt;blah</span>
<span class="gp">... </span><span class="s2">AAAACCGGGCCUUUUACCCCAAAUUGGAA</span>
<span class="gp">... </span><span class="s2">((((..(((..)))..))))...((..))</span>
<span class="gp">... </span><span class="s2">&quot;&quot;&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">bg</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>
<span class="go">name blah</span>
<span class="go">length 29</span>
<span class="go">seq AAAACCGGGCCUUUUACCCCAAAUUGGAA</span>
<span class="go">seq_ids</span>
<span class="go">define s0 1 4 17 20</span>
<span class="go">define i0 5 6 15 16</span>
<span class="go">define s1 7 9 12 14</span>
<span class="go">define h0 10 11</span>
<span class="go">define m0 21 23</span>
<span class="go">define s2 24 25 28 29</span>
<span class="go">define h1 26 27</span>
<span class="go">connect s2 h1 m0</span>
<span class="go">connect s1 i0 h0</span>
<span class="go">connect s0 i0 m0</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="querying-the-secondary-structure">
<h2>Querying the Secondary Structure<a class="headerlink" href="#querying-the-secondary-structure" title="Permalink to this headline">¶</a></h2>
<div class="section" id="finding-the-partner-of-a-base-pair">
<h3>Finding the Partner of a Base Pair<a class="headerlink" href="#finding-the-partner-of-a-base-pair" title="Permalink to this headline">¶</a></h3>
<p>Consider the situation where we have a secondary structure and we want to know
the base-pairing partner of nucleotide <em>n</em>. This is easily done with forgi:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">cgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">cgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="s1">&#39;(((((((((...((((((.........))))))........((((((.......))))))..)))))))))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">71</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">pairing_partner</span><span class="p">(</span><span class="mi">13</span><span class="p">)</span>
<span class="go">33</span>
</pre></div>
</div>
</div>
<div class="section" id="extracting-a-pair-table">
<h3>Extracting a Pair Table<a class="headerlink" href="#extracting-a-pair-table" title="Permalink to this headline">¶</a></h3>
<p>We can obtain a pair table describing the pairing pattern of the nucleotides in
this molecule. The first element of the pair table always contains the number
of nucleotides in the secondary structure. Every subsequent element <strong>i</strong>
either contains the number 0, indicating the nucleotide <strong>i</strong> is unpaired or an
integer <strong>j</strong> which is the pairing partner of <strong>i</strong>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">cgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">cgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="s1">&#39;(((((((((...((((((.........))))))........((((((.......))))))..)))))))))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">to_pair_table</span><span class="p">()</span>
<span class="go">[71, 71, 70, 69, 68, 67, 66, 65, 64, 63, 0, 0, 0, 33, 32, 31, 30, 29, 28, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 17, 16, 15, 14, 13, 0, 0, 0, 0, 0, 0, 0, 0, 60, 59, 58, 57, 56, 55, 0, 0, 0, 0, 0, 0, 0, 47, 46, 45, 44, 43, 42, 0, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1]</span>
</pre></div>
</div>
</div>
<div class="section" id="getting-the-name-of-an-element-from-the-residue-number">
<h3>Getting the Name of an Element from the Residue Number<a class="headerlink" href="#getting-the-name-of-an-element-from-the-residue-number" title="Permalink to this headline">¶</a></h3>
<p>Various applictions of <code class="docutils literal"><span class="pre">forgi</span></code> require knowledge of the internal name
of a particular element. As these names are generated by <code class="docutils literal"><span class="pre">forgi</span></code> itself, it’s
useful to be to retrieve the name of an element given the number of a
residue which is part of it. To demonstrate how to do this we will first need
to load a secondary structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;((..))..((..))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">bg</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>
<span class="go">name untitled</span>
<span class="go">length 14</span>
<span class="go">seq_ids</span>
<span class="go">define s0 1 2 5 6</span>
<span class="go">define h0 3 4</span>
<span class="go">define m0 7 8</span>
<span class="go">define s1 9 10 13 14</span>
<span class="go">define h1 11 12</span>
<span class="go">connect s1 h1 m0</span>
<span class="go">connect s0 h0 m0</span>
</pre></div>
</div>
<p>Then we can simply query for the element name based on the residue number:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;s0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">&#39;h0&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_node_from_residue_num</span><span class="p">(</span><span class="mi">9</span><span class="p">)</span>
<span class="go">&#39;s1&#39;</span>
</pre></div>
</div>
<p>This can then be used to in other applications such as <a class="reference internal" href="#loop-dimensions"><span class="std std-ref">Retrieving the Dimensions of a Loop</span></a>,
<a class="reference internal" href="#dissolving-stems"><span class="std std-ref">Dissolving Stems</span></a>, <a class="reference internal" href="#iloop-iterating"><span class="std std-ref">Iterating Over the Nucleotides of an Interior Loop</span></a>, etc…</p>
<div class="section" id="finding-the-length-of-the-longest-stem">
<h4>Finding the Length of the Longest Stem<a class="headerlink" href="#finding-the-length-of-the-longest-stem" title="Permalink to this headline">¶</a></h4>
<p>For whatever reason, one may be interested in finding out how long the longest
stem in a secondary structure is. Initially, one may assume that this can
easily be done by searching for the longest string of ‘(‘ or ‘)’ in the
dot-bracket file. Unfortunately, structures with an interior loop which has an
unpaired base on only one strand will lead to an erronous result in this
example. The decomposition provided by forgi will, however, take this into
account in enumerating the structural elements. It then becomes a matter of
iterating over the stems and checking their lengths:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">bg</span> <span class="o">=</span> <span class="n">cgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">()</span>
<span class="n">bg</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="n">brackets</span><span class="p">)</span>
<span class="n">biggest_stem</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">():</span>
    <span class="k">if</span> <span class="n">bg</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">biggest_stem</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">biggest_stem</span> <span class="o">=</span> <span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">stem_length</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="n">s</span><span class="p">)</span>
</pre></div>
</div>
<p>This is best illustrated with two examples:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">echo</span> <span class="s1">&#39;..((((..))))..&#39;</span> <span class="o">|</span> <span class="n">python</span> <span class="n">examples</span><span class="o">/</span><span class="n">longest_stem</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span>
<span class="mi">4</span>
<span class="n">echo</span> <span class="s1">&#39;..((((..).)))..&#39;</span> <span class="o">|</span> <span class="n">python</span> <span class="n">examples</span><span class="o">/</span><span class="n">longest_stem</span><span class="o">.</span><span class="n">py</span> <span class="o">-</span>
<span class="mi">3</span>
</pre></div>
</div>
<p>In the first case, the longest stem is the only stem. In the second case, what
appears to be one large stem of length 4, is actually two stems of length 1 and
3.</p>
</div>
</div>
<div class="section" id="getting-the-sequence-of-an-element-and-its-neighbors">
<h3>Getting the Sequence of an Element and its Neighbors<a class="headerlink" href="#getting-the-sequence-of-an-element-and-its-neighbors" title="Permalink to this headline">¶</a></h3>
<p>Suppose we want to find out not only the sequence of an element, but also the
elements that surround it? This is easily done using the
<code class="code docutils literal"><span class="pre">get_flanking_sequence</span></code> function. To illustrate, let’s create a graph from a
fasta representation:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>

<span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">()</span>

<span class="n">fa</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;&gt;blah</span>
<span class="s2">AAAACCGGGCCUUUUACCCCAAAUUGGAA</span>
<span class="s2">((((..(((..)))..))))...((..))</span>
<span class="s2">&quot;&quot;&quot;</span>
<span class="n">bg</span><span class="o">.</span><span class="n">from_fasta</span><span class="p">(</span><span class="n">fa</span><span class="p">)</span>
</pre></div>
</div>
<p>From the structure, we can see that there are two hairpins (<code class="code docutils literal"><span class="pre">h0</span></code> and <code class="code docutils literal"><span class="pre">h1</span></code>), one
interior loop (<code class="code docutils literal"><span class="pre">i0</span></code>) and one multiloop (<code class="code docutils literal"><span class="pre">m0</span></code>). We can get the sequence for <code class="code docutils literal"><span class="pre">h0</span></code>
and it’s neighboring node (<code class="code docutils literal"><span class="pre">s0</span></code>) like so:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_flanking_sequence</span><span class="p">(</span><span class="s1">&#39;h0&#39;</span><span class="p">)</span>
<span class="go">&#39;GGGCCUUU&#39;</span>
</pre></div>
</div>
<p>The same can be done for the multiloop (<code class="code docutils literal"><span class="pre">m0</span></code>):</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_flanking_sequence</span><span class="p">(</span><span class="s1">&#39;m0&#39;</span><span class="p">)</span>
<span class="go">&#39;CCCCAAAUU&#39;</span>
</pre></div>
</div>
<p>The interior loop is a little more tricky because it is double stranded. From
the interior loop, we need to pass in a parameter indicating which side we want
(0 or 1). The 0’th strand corresponds to the one with the lower numbered
nucleotides, whereas the 1’st strand is the other. The default is the 0’th
strand:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_flanking_sequence</span><span class="p">(</span><span class="s1">&#39;i0&#39;</span><span class="p">)</span>
<span class="go">&#39;AAAACCGGG&#39;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_flanking_sequence</span><span class="p">(</span><span class="s1">&#39;i0&#39;</span><span class="p">,</span> <span class="n">side</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="go">&#39;UUUUACCCC&#39;</span>
</pre></div>
</div>
</div>
<div class="section" id="retrieving-the-dimensions-of-a-loop">
<span id="loop-dimensions"></span><h3>Retrieving the Dimensions of a Loop<a class="headerlink" href="#retrieving-the-dimensions-of-a-loop" title="Permalink to this headline">¶</a></h3>
<p>Each loop can be said to have a size or dimension. For interior loops, the
dimensions take the form of a tuple and indicate how many unpaired nucleotides
are on each side. For multiloops each segment is represented individually and
thus should have only one dimension (how many unpaired nucleotides are in that
segment), but in order to maintain consistency with interior loops, we make it
a tuple by attaching 1000 as the second value:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;((.(.))..((..)))&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bg</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="s1">&#39;i0&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bg</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="s1">&#39;m0&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bg</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="s1">&#39;m1&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">bg</span><span class="o">.</span><span class="n">get_bulge_dimensions</span><span class="p">(</span><span class="s1">&#39;m2&#39;</span><span class="p">)</span>
<span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="section" id="dissolving-stems">
<span id="id1"></span><h3>Dissolving Stems<a class="headerlink" href="#dissolving-stems" title="Permalink to this headline">¶</a></h3>
<p>To remove a stem from the skeleton graph, use the <code class="docutils literal"><span class="pre">dissolve_stem()</span></code> member
function. This will remove the base pairs that were part of the stem and merge
them with the adjacent unpaired regions:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;((..))..((..))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">dissolve_stem</span><span class="p">(</span><span class="s1">&#39;s0&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">bg</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">()</span>
<span class="go">........((..))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">dissolve_stem</span><span class="p">(</span><span class="s1">&#39;s1&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">bg</span><span class="o">.</span><span class="n">to_dotbracket_string</span><span class="p">()</span>
<span class="go">..............</span>
</pre></div>
</div>
</div>
<div class="section" id="finding-out-which-side-of-a-stem-a-loop-is-on">
<h3>Finding Out Which Side of a Stem a Loop Is On<a class="headerlink" href="#finding-out-which-side-of-a-stem-a-loop-is-on" title="Permalink to this headline">¶</a></h3>
<p>If one imagines a stem as having a direction where its start is the position of
the lowest numbered nucleotide within it, then a loop adjacent to the stem will
be on one side of it. Which side it’s on can be elucidated using the
<code class="docutils literal"><span class="pre">get_sides</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s2">&quot;..((..((..))..))..&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="s1">&#39;s0&#39;</span><span class="p">,</span> <span class="s1">&#39;i0&#39;</span><span class="p">)</span>
<span class="go">(1, 0)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_sides</span><span class="p">(</span><span class="s1">&#39;s1&#39;</span><span class="p">,</span> <span class="s1">&#39;i0&#39;</span><span class="p">)</span>
<span class="go">(0, 1)</span>
</pre></div>
</div>
<p>The result shows that the loop <code class="code docutils literal"><span class="pre">i0</span></code> is on side 1 of stem <code class="code docutils literal"><span class="pre">s0</span></code> and side 0 of
stem <code class="code docutils literal"><span class="pre">s1</span></code>. If <code class="code docutils literal"><span class="pre">bg.get_sides(s,b)</span></code> return a tuple <code class="code docutils literal"><span class="pre">(sb,</span> <span class="pre">se)</span></code>, where the nucleotides
in <code class="code docutils literal"><span class="pre">bg.coords[sb]</span></code> are on the side of the loop.</p>
</div>
</div>
<div class="section" id="iteration">
<h2>Iteration<a class="headerlink" href="#iteration" title="Permalink to this headline">¶</a></h2>
<p>forgi provides iterators for the various elements, and base pairing in the structure.</p>
<div class="section" id="iterating-over-the-nucleotides-of-an-interior-loop">
<span id="iloop-iterating"></span><h3>Iterating Over the Nucleotides of an Interior Loop<a class="headerlink" href="#iterating-over-the-nucleotides-of-an-interior-loop" title="Permalink to this headline">¶</a></h3>
<p>Imagine that we have a model of an RNA structure, and we want to list all of
the nucleotides which are in interior loop regions. This is can be done by
combining an iterator which yields all of the interior loops and another
iterator which iterates over the nucleotides within a particular element:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">sys</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">cgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">cgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">from_dotbracket</span><span class="p">(</span><span class="s2">&quot;((..((..))..))..((..((..))..))&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">iloop</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">iloop_iterator</span><span class="p">():</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">rn</span> <span class="ow">in</span> <span class="n">bg</span><span class="o">.</span><span class="n">define_residue_num_iterator</span><span class="p">(</span><span class="n">iloop</span><span class="p">):</span>
<span class="gp">... </span>            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rn</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
<span class="gp">...</span>
<span class="go">10 11 12 13 2 3 4 5 26 27 28 29 18 19 20 21</span>
</pre></div>
</div>
</div>
<div class="section" id="iterating-over-the-list-of-elements">
<h3>Iterating Over The List of Elements<a class="headerlink" href="#iterating-over-the-list-of-elements" title="Permalink to this headline">¶</a></h3>
<p>** Stems **</p>
<p>To iterate over each stem in the structure, use the <code class="code docutils literal"><span class="pre">stem_iterator()</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;((..((..))..))..((..((..))...)).&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">stem_iterator</span><span class="p">())</span>
<span class="go">[&#39;s3&#39;, &#39;s2&#39;, &#39;s1&#39;, &#39;s0&#39;]</span>
</pre></div>
</div>
<p>** Interior Loops **</p>
<p>To iterate over each interior loop in the structures, use the <code class="code docutils literal"><span class="pre">iloop_iterator()</span></code>:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">iloop_iterator</span><span class="p">())</span>
<span class="go">[&#39;i1&#39;, &#39;i0&#39;]</span>
</pre></div>
</div>
<p>** Others **</p>
<p>For multiloops, hairpin loops, fiveprime regions and threeprimes regions  use
<code class="code docutils literal"><span class="pre">mloop_iterator()</span></code>, <code class="code docutils literal"><span class="pre">hloop_iterator()</span></code>, <code class="code docutils literal"><span class="pre">floop_iterator</span></code> and <code class="code docutils literal"><span class="pre">tloop_iterator</span></code>,
respectively:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">mloop_iterator</span><span class="p">())</span>
<span class="go">[&#39;m0&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">hloop_iterator</span><span class="p">())</span>
<span class="go">[&#39;h1&#39;, &#39;h0&#39;]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">floop_iterator</span><span class="p">())</span>
<span class="go">[]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="nb">list</span><span class="p">(</span><span class="n">bg</span><span class="o">.</span><span class="n">tloop_iterator</span><span class="p">())</span>
<span class="go">[&#39;t1&#39;]</span>
</pre></div>
</div>
<p>Notice that <code class="code docutils literal"><span class="pre">floop_iterator()</span></code> doesn’t yield any values. This is because there
is no 3’ unpaired region in this structure.</p>
</div>
</div>
<div class="section" id="graph-functions">
<h2>Graph Functions<a class="headerlink" href="#graph-functions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="finding-the-minimum-spanning-tree-of-a-graph">
<h3>Finding the Minimum Spanning Tree of a Graph<a class="headerlink" href="#finding-the-minimum-spanning-tree-of-a-graph" title="Permalink to this headline">¶</a></h3>
<p>Can we create a subgraph such that all stems are connected and no cycles
remain? Recall that cycles only occur in multiloop sections (junctions). Can we
return a representation of the structure such that all stems are connected with
the least number of nucleotides between them? If interior loops and multiloop
segements were considered edges, then this would be the equivalent of a minimum
spanning tree. Since they are nodes, then the result is not a minimum spanning
tree but simply a representation of the secondary structure with broken
multiloops.</p>
<p>As an example, consider the following structure:</p>
<a class="reference internal image-reference" href="_images/mst_init.png"><img alt="_images/mst_init.png" class="align-center" src="_images/mst_init.png" style="width: 200px;" /></a>
<p>To break the cycle, we would like to remove the segment ‘m0’. This is easily
done using the <code class="code docutils literal"><span class="pre">get_mst()</span></code> function of the <code class="code docutils literal"><span class="pre">BulgeGraph</span></code> data structure:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s2">&quot;((..((.)).(.).))&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">get_mst</span><span class="p">()</span>
<span class="go">set([&#39;s2&#39;, &#39;s1&#39;, &#39;s0&#39;, &#39;m1&#39;, &#39;m2&#39;])</span>
</pre></div>
</div>
<p>The result contains all the nodes except the ones removed to break the cycles.
The implementation uses a slightly modified version of Kruskal’s algorithm.</p>
</div>
<div class="section" id="traversing-the-graph">
<h3>Traversing the Graph<a class="headerlink" href="#traversing-the-graph" title="Permalink to this headline">¶</a></h3>
<p>We can traverse all of the loops in a graph in breadth-first manner using the
<code class="code docutils literal"><span class="pre">traverse_graph</span></code> function:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;(.(.(.(.).(.).).(.).))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">traverse_graph</span><span class="p">()</span>
<span class="go">[(&#39;s0&#39;, &#39;i0&#39;, &#39;s1&#39;), (&#39;s1&#39;, &#39;m1&#39;, &#39;s5&#39;), (&#39;s5&#39;, &#39;m4&#39;, &#39;s2&#39;), (&#39;s2&#39;, &#39;m3&#39;, &#39;s4&#39;), (&#39;s4&#39;, &#39;m5&#39;, &#39;s3&#39;)]</span>
</pre></div>
</div>
<p>Starting with the first stem, <em>s0</em>, we visit each loop that connects it to
another stem and return all the visited loops as a list of tuples. Each tuple
has the following three elements: (from_stem, loop, to_stem).</p>
</div>
<div class="section" id="finding-the-elements-which-form-the-multiloops-of-a-structure">
<h3>Finding the elements which form the multiloops of a structure<a class="headerlink" href="#finding-the-elements-which-form-the-multiloops-of-a-structure" title="Permalink to this headline">¶</a></h3>
<p>The <code class="code docutils literal"><span class="pre">find_multiloop_loops()</span></code> function returns a list of sets where each set
contains the elements that are part of a particular junction.</p>
<a class="reference internal image-reference" href="_images/find_loops.png"><img alt="_images/find_loops.png" class="align-center" src="_images/find_loops.png" style="width: 290px;" /></a>
<p>Example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;(.(.(.(.).(.).).(.).))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">bg</span><span class="o">.</span><span class="n">find_multiloop_loops</span><span class="p">()</span>
<span class="go">[set([&#39;s3&#39;, &#39;s2&#39;, &#39;s4&#39;, &#39;m5&#39;, &#39;m3&#39;, &#39;m2&#39;]), set([&#39;s2&#39;, &#39;s1&#39;, &#39;s5&#39;, &#39;m4&#39;, &#39;m1&#39;, &#39;m0&#39;])]</span>
</pre></div>
</div>
<div class="section" id="calculating-the-minimum-secondary-structure-distance-between-two-elements">
<h4>Calculating the Minimum Secondary Structure Distance Between Two Elements<a class="headerlink" href="#calculating-the-minimum-secondary-structure-distance-between-two-elements" title="Permalink to this headline">¶</a></h4>
<p>The secondary structure distance, in our case, will be calculated as the
distance along the backbone or along base-pair links. When calculated between
two elements, it is the minimum distance between any two pairs of nucleotides
in each of the two elements.</p>
<p>Consider the following example:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;((..))..((..))((..))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">ss_distance</span><span class="p">(</span><span class="s1">&#39;s0&#39;</span><span class="p">,</span> <span class="s1">&#39;s1&#39;</span><span class="p">)</span>
<span class="go">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">ss_distance</span><span class="p">(</span><span class="s1">&#39;s0&#39;</span><span class="p">,</span> <span class="s1">&#39;s2&#39;</span><span class="p">)</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span><span class="o">.</span><span class="n">ss_distance</span><span class="p">(</span><span class="s1">&#39;s0&#39;</span><span class="p">,</span> <span class="s1">&#39;h2&#39;</span><span class="p">)</span>
<span class="go">7</span>
</pre></div>
</div>
<p>The first distance requires going over three backbone edges. The second distance
Requires three backbone, one base pair, and one more backbone. The last distance
requires three backbone, one base pair, and three more backbone links.</p>
</div>
</div>
<div class="section" id="selecting-a-random-subgraph">
<h3>Selecting a Random Subgraph<a class="headerlink" href="#selecting-a-random-subgraph" title="Permalink to this headline">¶</a></h3>
<p>The <code class="code docutils literal"><span class="pre">random_subgraph</span></code> function picks a random quantity of elements which will
become part of the subgraph. A random element is chosen as a starting point and
the graph is traversed in a random manner until at least the chosen number of
nodes have been added. When that number is exceeded, the traversal stops. In
cases where an interior loop or a multiloop segment is added, the stem on the
other end is automatically added as well. Example, using the graph in the
previous section:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">forgi.graph.bulge_graph</span> <span class="k">as</span> <span class="nn">fgb</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">bg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">BulgeGraph</span><span class="p">(</span><span class="n">dotbracket_str</span><span class="o">=</span><span class="s1">&#39;(.(.(.(.).(.).).(.).))&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sg</span> <span class="o">=</span> <span class="n">bg</span><span class="o">.</span><span class="n">random_subgraph</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">sg</span>
<span class="go">[&#39;s3&#39;, &#39;s2&#39;, &#39;m2&#39;, &#39;s4&#39;, &#39;m5&#39;]</span>
</pre></div>
</div>
<p>From this we can create a new graph, compete with defines and connections. Only
the sequence and its related information (length, ids) will not be carried
over:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nbg</span> <span class="o">=</span> <span class="n">fgb</span><span class="o">.</span><span class="n">bg_from_subgraph</span><span class="p">(</span><span class="n">bg</span><span class="p">,</span> <span class="n">sg</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span> <span class="n">nbg</span><span class="o">.</span><span class="n">to_bg_string</span><span class="p">()</span>
<span class="go">name untitled</span>
<span class="go">length 0</span>
<span class="go">seq_ids</span>
<span class="go">define s3 7 7 9 9</span>
<span class="go">define s2 5 5 15 15</span>
<span class="go">define s4 11 11 13 13</span>
<span class="go">define m5 10 10</span>
<span class="go">define m2 6 6</span>
<span class="go">connect s3 m5 m2</span>
<span class="go">connect s2 m2</span>
<span class="go">connect s4 m5</span>
</pre></div>
</div>
<p>Which, when visualized, looks like this:</p>
<a class="reference internal image-reference" href="_images/subgraph.png"><img alt="_images/subgraph.png" class="align-center" src="_images/subgraph.png" style="height: 200px;" /></a>
</div>
</div>
<div class="section" id="applications">
<h2>Applications<a class="headerlink" href="#applications" title="Permalink to this headline">¶</a></h2>
<div class="section" id="rosetta-rna-denovo-constraint-file-creation">
<h3>Rosetta rna_denovo Constraint File Creation<a class="headerlink" href="#rosetta-rna-denovo-constraint-file-creation" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="http://www.rosettacommons.org/">Rosetta</a> protein structure prediction
package provides a program for RNA 3D structure prediction called <a class="reference external" href="http://www.rosettacommons.org/manuals/rosetta3.3_user_guide/d2/d82/rna_denovo.html">rna_denovo</a>.
To specify the secondary structure of an RNA molecule, one needs to pass in a
parameter file indicating which nucleotides are paired.</p>
<p>Given an dot-bracket sequence as input, forgi can be easily be used to generate
the parameter file for rna_denovo.Using the secondary structure of 1y26 (shown
in the first example) one can run the appropriate example:</p>
<p><code class="docutils literal"><span class="pre">python</span> <span class="pre">examples/dotbracket_to_rosetta_constraints.py</span> <span class="pre">examples/1y26_ss.dotbracket</span></code></p>
<p>And get an appropriately formatted parameter file:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">42</span> <span class="mi">60</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">43</span> <span class="mi">59</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">44</span> <span class="mi">58</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">45</span> <span class="mi">57</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">46</span> <span class="mi">56</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">47</span> <span class="mi">55</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">13</span> <span class="mi">33</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">14</span> <span class="mi">32</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">15</span> <span class="mi">31</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">16</span> <span class="mi">30</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">17</span> <span class="mi">29</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">18</span> <span class="mi">28</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">19</span> <span class="mi">27</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">1</span> <span class="mi">71</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">2</span> <span class="mi">70</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">3</span> <span class="mi">69</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">4</span> <span class="mi">68</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">5</span> <span class="mi">67</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">6</span> <span class="mi">66</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">7</span> <span class="mi">65</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">8</span> <span class="mi">64</span>
<span class="n">STEM</span> <span class="n">PAIR</span> <span class="mi">9</span> <span class="mi">63</span>
</pre></div>
</div>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="utilities_tutorial.html">RNA Secondary Structure Utilities Using the forgi.utilities Submodule</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="threedee_tutorial.html">RNA 3D Structure Using forgi.threedee</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2012-2016 Peter Kerpedjiev &lt;pkerp@tbi.univie.ac.at&gt;; 2015,2016 Bernhard Thiel &lt;thiel@tbi.univie.ac.at&gt;.
      Last updated on Oct 12, 2017.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.6.4.
    </div>
  </body>
</html>